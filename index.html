<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>å…±è¯†ç¼–å¹´å² | GenLayer</title>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <style>
    *{margin:0;padding:0;box-sizing:border-box}
    body{font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',sans-serif;background:linear-gradient(135deg,#0a0a12,#12121f);color:#f0f0f5;min-height:100vh}
    .btn{padding:.7rem 1.4rem;border:none;border-radius:12px;font-weight:600;cursor:pointer;transition:all .2s}
    .btn-primary{background:linear-gradient(135deg,#a78bfa,#f472b6);color:#fff}
    .btn-primary:hover{transform:translateY(-2px);box-shadow:0 4px 20px rgba(167,139,250,0.4)}
    .btn:disabled{opacity:.5;cursor:not-allowed}
    .card{background:rgba(255,255,255,0.03);border:1px solid rgba(255,255,255,0.08);border-radius:16px;padding:1.5rem}
    .input{width:100%;padding:.8rem 1rem;background:rgba(255,255,255,0.05);border:1px solid rgba(255,255,255,0.1);border-radius:10px;color:#fff;font-size:1rem;outline:none}
    .input:focus{border-color:rgba(167,139,250,0.5)}
    @keyframes spin{to{transform:rotate(360deg)}}
    .loading{animation:spin 1s linear infinite}
  </style>
</head>
<body>
<div id="root"></div>
<script type="text/babel">
const { useState, useEffect, useRef, useCallback } = React;

// =============================================================================
// é…ç½®
// =============================================================================
const CONFIG = {
  // ä½¿ç”¨æœ¬åœ° API ä»£ç†ï¼ˆè§£å†³ CORSï¼‰
  RPC_URL: '/api/genlayer',
  
  // âš ï¸ éƒ¨ç½²åˆçº¦åå¡«å…¥åœ°å€
  CONTRACT_ADDRESS: '0x4547e3E9742B4b4e6039e59C7219e40040cE',
  
  POLL_INTERVAL: 3000,
  TOTAL_ROUNDS: 5,
  ENTRY_FEE: 10
};

// æ•…äº‹æ•°æ®
const STORIES = {
  fantasy: {
    name: "é»‘é¾™è§‰é†’", icon: "ğŸ‰",
    rounds: [
      { ctx: "é»‘é¾™è‹é†’ï¼Œç‹å›½å±åœ¨æ—¦å¤•ã€‚", A: { text: "å‡ºå…µæ”»æ‰“é¾™ç©´", tag: "æ¿€è¿›" }, B: { text: "å¯»æ±‚ç²¾çµè”ç›Ÿ", tag: "å¤–äº¤" }},
      { ctx: "å±€åŠ¿å‘å±•...", ctxA: "å†›é˜Ÿå‘ç°é¾™è›‹", ctxB: "ç²¾çµè¦æ±‚åœ£å‰‘ä½œä¸ºä¿¡ç‰©",
        A: { text: "æ‘§æ¯é¾™è›‹", tag: "æ–©è‰é™¤æ ¹" }, B: { text: "ä¿æŠ¤é¾™è›‹è°ˆåˆ¤", tag: "ç•™æœ‰ä½™åœ°" }},
      { ctx: "æˆ˜æ–—ç™½çƒ­åŒ–", ctxAA: "é»‘é¾™æš´æ€’", ctxAB: "å†…éƒ¨åˆ†è£‚", ctxBA: "ç‹¬è‡ªä½œæˆ˜è‰°éš¾", ctxBB: "ç²¾çµæ´å†›åˆ°æ¥",
        A: { text: "ä½¿ç”¨ç¦å¿Œé­”æ³•", tag: "ç‰ºç‰²" }, B: { text: "æˆ˜ç•¥æ’¤é€€", tag: "ä¿å­˜å®åŠ›" }},
      { ctx: "è½¬æŠ˜ç‚¹", ctxA: "é»‘é¾™é‡ä¼¤", ctxB: "æ–°çš„ç›Ÿå‹å‡ºç°",
        A: { text: "è¶èƒœè¿½å‡»", tag: "å†³æˆ˜" }, B: { text: "å°è¯•å’Œå¹³æ²Ÿé€š", tag: "å’Œè°ˆ" }},
      { ctx: "æœ€ç»ˆç« ", ctxA: "å†³æˆ˜æ—¶åˆ»", ctxB: "é»‘é¾™æ­ç¤ºçœŸç›¸",
        A: { text: "ä¸æƒœä»£ä»·æ¶ˆç­é»‘é¾™", tag: "ç‰çŸ³ä¿±ç„š", end: "é»‘é¾™è¢«æ¶ˆç­ï¼Œç‹å›½ä¹Ÿå‡ ä¹åŒ–ä¸ºåºŸå¢Ÿã€‚å¹¸å­˜è€…å¼€å§‹æ¼«é•¿çš„é‡å»ºã€‚" },
        B: { text: "ä¸é»‘é¾™ç»“ç›Ÿ", tag: "å…±å­˜", end: "äººç±»ä¸é»‘é¾™è¾¾æˆå‰æ‰€æœªæœ‰çš„ç›Ÿçº¦ï¼Œä¸€ä¸ªæ–°æ—¶ä»£å¼€å¯ã€‚" }}
    ]
  },
  scifi: {
    name: "æœ«æ—¥æ–¹èˆŸ", icon: "ğŸš€",
    rounds: [
      { ctx: "å°è¡Œæ˜Ÿå°†æ’å‡»åœ°çƒï¼Œåªèƒ½æ•‘ä¸€åŠäººã€‚", A: { text: "æŠ½ç­¾å†³å®š", tag: "å…¬å¹³" }, B: { text: "è¿½æŸ¥ä¿¡å·æ¥æº", tag: "å¸Œæœ›" }},
      { ctx: "å±æœºåŠ æ·±", ctxA: "è½é€‰è€…æš´åŠ¨", ctxB: "å¤–æ˜Ÿæ–‡æ˜é‚€è¯·äººç±»",
        A: { text: "æ­¦åŠ›é•‡å‹", tag: "ç§©åº" }, B: { text: "è°ˆåˆ¤ä¿®æ”¹æ–¹æ¡ˆ", tag: "äººé“" }},
      { ctx: "å…³é”®æŠ‰æ‹©", ctxAA: "è¶…è½½å¯å¤šæ•‘30%ä½†é£é™©å¤§", ctxAB: "å…ˆé£é˜Ÿå¤±è”", ctxBA: "æç«¯åˆ†å­ç ´åè®¡åˆ’", ctxBB: "å†·å†»æŠ€æœ¯ä¸æˆç†Ÿ",
        A: { text: "æ¥å—é£é™©æ–¹æ¡ˆ", tag: "èµŒåš" }, B: { text: "åšæŒåŸè®¡åˆ’", tag: "ç¨³å¦¥" }},
      { ctx: "æ–°å‘ç°", ctxA: "å¯ä»¥æ”¹å˜å°è¡Œæ˜Ÿè½¨é“", ctxB: "å¤–æ˜Ÿäººå¯æ‘§æ¯å°è¡Œæ˜Ÿä½†æœ‰æ¡ä»¶",
        A: { text: "å°è¯•æ”¹å˜è½¨é“", tag: "è‹±é›„" }, B: { text: "ç»§ç»­æ’¤ç¦»", tag: "è°¨æ…" }},
      { ctx: "æœ€åæ—¶åˆ»", ctxA: "èƒ½é‡ç”¨äº†80%ï¼Œè¿˜å·®ä¸€ç‚¹", ctxB: "å¤–æ˜Ÿäººè¦æ±‚é”€æ¯æ ¸æ­¦",
        A: { text: "å…¨éƒ¨æŠ¼ä¸Š", tag: "èƒŒæ°´ä¸€æˆ˜", end: "å¥‡è¿¹å‘ç”Ÿï¼å°è¡Œæ˜Ÿåç¦»è½¨é“ï¼Œäººç±»ç”¨å‹‡æ°”æˆ˜èƒœå‘½è¿ã€‚" },
        B: { text: "æ¥å—éƒ¨åˆ†æŸå¤±", tag: "åŠ¡å®", end: "å°è¡Œæ˜Ÿæ“¦è¿‡åœ°çƒé€ æˆç¾éš¾ï¼Œä½†äººç±»å­˜æ´»ï¼Œå¼€å§‹é‡å»ºã€‚" }}
    ]
  },
  mystery: {
    name: "é™ˆåºœç–‘æ¡ˆ", icon: "ğŸ”",
    rounds: [
      { ctx: "å¯Œè±ªé™ˆè€çˆ·è¢«æ¯’æ€åœ¨å¯†å®¤ä¸­ã€‚", A: { text: "æœæŸ¥ç°åœº", tag: "ç‰©è¯" }, B: { text: "å®¡é—®å«Œç–‘äºº", tag: "å¿ƒç†" }},
      { ctx: "çº¿ç´¢æµ®ç°", ctxA: "å‘ç°å…³äºé—äº§çš„çƒ§æ¯ä¿¡ä»¶", ctxB: "ç®¡å®¶ç¥è‰²æ…Œå¼ ï¼Œå¥³å„¿æåˆ°å¨èƒä¿¡",
        A: { text: "è¿½æŸ¥é—äº§é—®é¢˜", tag: "é‡‘é’±" }, B: { text: "è°ƒæŸ¥ç¥ç§˜å•†äººæå…ˆç”Ÿ", tag: "å¤–äºº" }},
      { ctx: "æ·±å…¥è°ƒæŸ¥", ctxAA: "å¤§å„¿å­æœ‰èµŒå€ºï¼Œå¥³ä»†æ˜¯ä»–çš„ä¸åœ¨åœºè¯äºº", ctxAB: "æµ·å¤–è´¦æˆ·æˆ·ä¸»åŠ å¯†", ctxBA: "æå…ˆç”Ÿæ˜¯ç§ç”Ÿå­", ctxBB: "æå…ˆç”Ÿå¸¦æ¥20å¹´å‰æ—§æ¡ˆçº¿ç´¢",
        A: { text: "éªŒè¯å¥³ä»†è¯è¯", tag: "è´¨ç–‘" }, B: { text: "è°ƒæŸ¥é™ˆå¹´æ—§æ¡ˆ", tag: "è¿½æº¯" }},
      { ctx: "çœŸç›¸é€¼è¿‘", ctxA: "ä¼ªè¯è¢«æ‹†ç©¿", ctxB: "20å¹´å‰çš„ç«ç¾æ˜¯äººä¸ºçºµç«",
        A: { text: "äº¤å‰å®¡é—®å…„å¦¹", tag: "å¯¹è´¨" }, B: { text: "è¿½æŸ¥æ¯’è¯æ¥æº", tag: "ç§‘å­¦" }},
      { ctx: "æœ€ç»ˆçœŸç›¸", ctxA: "é™ˆæœˆä¸æ˜¯äº²ç”Ÿå¥³å„¿", ctxB: "ç®¡å®¶å¿ƒè„ç—…å‘ï¼šçœŸç›¸åœ¨è€æ§æ ‘ä¸‹",
        A: { text: "å…¬å¼€å…¨éƒ¨çœŸç›¸", tag: "æ­£ä¹‰", end: "çœŸç›¸å¤§ç™½ï¼šç®¡å®¶æ˜¯å‡¶æ‰‹ï¼Œ20å¹´å‰çš„ç§˜å¯†ç»ˆäºæ­å¼€ã€‚" },
        B: { text: "ç»™ç›¸å…³äººé€‰æ‹©æœºä¼š", tag: "ä»æ…ˆ", end: "éƒ¨åˆ†çœŸç›¸è¢«æ©åŸ‹ï¼Œæ´»ç€çš„äººéƒ½æœ‰äº†æ–°çš„å¼€å§‹ã€‚" }}
    ]
  },
  political: {
    name: "å¤ºå«¡é£äº‘", icon: "ğŸ‘‘",
    rounds: [
      { ctx: "è€çš‡å¸é©¾å´©ï¼Œé—è¯ï¼šçš‡ä½ä¼ ç»™æœ€èƒ½ä»£è¡¨æ°‘å¿ƒè€…ã€‚", A: { text: "æ”¯æŒå¤ªå­æŒ‰ä¼ ç»Ÿç»§ä½", tag: "ä¿å®ˆ" }, B: { text: "ä¸‰çš‡å­å„é™ˆæ–½æ”¿çº²é¢†", tag: "é©æ–°" }},
      { ctx: "æƒåŠ›æ–—äº‰", ctxA: "äºŒçš‡å­è”ç»œè¾¹ç–†å°†å†›è°‹å", ctxB: "æœ‰äººæ­å‘ä¸‰çš‡å­é€šæ•Œ",
        A: { text: "è°ƒåŠ¨å¾¡æ—å†›åˆ†åŒ–äºŒçš‡å­åŒç›Ÿ", tag: "æƒè°‹" }, B: { text: "ä¸»åŠ¨ä¸äºŒçš‡å­è°ˆåˆ¤", tag: "å†’é™©" }},
      { ctx: "å±æœºå››ä¼", ctxAA: "è¢«ç­–åçš„å°†é¢†è¦æ±‚å°ä¾¯æ‹œç›¸", ctxAB: "æ­å‘ä¿¡å‡ºè‡ªå¤ªåäº²ä¿¡", ctxBA: "äºŒçš‡å­æ¡ä»¶è‹›åˆ»", ctxBB: "å¤ªåå¼€å§‹å¹²æ”¿",
        A: { text: "æš‚æ—¶ç­”åº”æ¡ä»¶", tag: "æƒå®œ" }, B: { text: "æ­éœ²å¹•åé»‘æ‰‹è”åˆçš‡å­", tag: "å›¢ç»“" }},
      { ctx: "å¤–æ•Œæ¥è¢­", ctxA: "åŒ—æ–¹æ¸¸ç‰§æ°‘æ—å¤§å†›å‹å¢ƒ", ctxB: "çš‡å­ä»¬æ”¾ä¸‹äº‰ç«¯",
        A: { text: "ä¸‰çš‡å­äº²å¾ï¼Œè°é€€æ•Œè°ä¸ºå¸", tag: "ä»¥æˆ˜å®šå¸" }, B: { text: "å…ˆé€‰æ–°å¸å†åº”å¯¹å¤–æ•Œ", tag: "å…ˆå†…åå¤–" }},
      { ctx: "å°˜åŸƒè½å®š", ctxA: "ä¸‰çš‡å­å„æœ‰æˆ˜åŠŸï¼Œéš¾åˆ†é«˜ä¸‹", ctxB: "å‘ç°å¦ä¸€ä»½é—è¯æŒ‡å‘ä½ ",
        A: { text: "å»ºç«‹ä¸‰ç‹è®®æ”¿æ–°åˆ¶åº¦", tag: "å…±æ²»", end: "å¤§é½è¿›å…¥ä¸‰ç‹æ—¶ä»£ï¼Œåœ¨ä½ çš„è°ƒå’Œä¸‹è¿è½¬èµ·æ¥ã€‚" },
        B: { text: "æŒ‰å†›åŠŸå®šå¸ä½", tag: "åŠŸå‹‹", end: "äºŒçš‡å­å‡­æˆ˜åŠŸç™»åŸºï¼Œæˆä¸ºä¸€ä»£æ˜å›ã€‚" }}
    ]
  }
};

// =============================================================================
// GenLayer RPC æœåŠ¡
// =============================================================================
const GenLayer = {
  requestId: 0,
  
  async rpc(method, params = []) {
    this.requestId++;
    console.log(`[RPC] ${method}`, params);
    
    const body = { jsonrpc: '2.0', method, params, id: this.requestId };
    
    const response = await fetch(CONFIG.RPC_URL, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(body)
    });
    
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}`);
    }
    
    const data = await response.json();
    console.log(`[RPC] Response:`, data);
    
    if (data.error) {
      throw new Error(data.error.message || JSON.stringify(data.error));
    }
    
    return data.result;
  },
  
  async call(contractMethod, args = []) {
    return this.rpc('sim_call', [{
      contract_address: CONFIG.CONTRACT_ADDRESS,
      method: contractMethod,
      args: args
    }]);
  },
  
  // å°è£…çš„åˆçº¦æ–¹æ³•
  registerPlayer: (name, avatar) => GenLayer.call('register_player', [name, avatar]),
  getBalance: (addr) => GenLayer.call('get_balance', [addr]),
  createRoom: (theme) => GenLayer.call('create_room', [theme]),
  joinRoom: (roomId) => GenLayer.call('join_room', [roomId]),
  listRooms: () => GenLayer.call('list_rooms', []),
  startGame: (roomId) => GenLayer.call('start_game', [roomId]),
  submitVote: (roomId, round, choice) => GenLayer.call('submit_vote', [roomId, round, choice]),
  finalizeRound: (roomId) => GenLayer.call('finalize_round', [roomId]),
  getGameState: (roomId) => GenLayer.call('get_game_state', [roomId]),
  getLeaderboard: (limit) => GenLayer.call('get_leaderboard', [limit || 20])
};

// =============================================================================
// ä¸»åº”ç”¨
// =============================================================================
function App() {
  const [view, setView] = useState('home');
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');
  const [player, setPlayer] = useState(null);
  const [address, setAddress] = useState('');
  const [rooms, setRooms] = useState([]);
  const [currentRoom, setCurrentRoom] = useState(null);
  const [gameState, setGameState] = useState(null);
  const [leaderboard, setLeaderboard] = useState([]);
  const pollRef = useRef(null);
  
  // ç”Ÿæˆé’±åŒ…åœ°å€
  const genAddress = () => '0x' + Array(40).fill(0).map(() => Math.floor(Math.random()*16).toString(16)).join('');
  
  // è½®è¯¢
  const startPolling = useCallback((roomId) => {
    if (pollRef.current) clearInterval(pollRef.current);
    pollRef.current = setInterval(async () => {
      try {
        const state = await GenLayer.getGameState(roomId);
        if (state) {
          setGameState(state);
          setCurrentRoom(state.room);
          if (state.room?.status === 'playing' && view === 'room') {
            setView('game');
          }
        }
      } catch (e) { console.error('Poll error:', e); }
    }, CONFIG.POLL_INTERVAL);
  }, [view]);
  
  const stopPolling = useCallback(() => {
    if (pollRef.current) { clearInterval(pollRef.current); pollRef.current = null; }
  }, []);
  
  useEffect(() => () => stopPolling(), [stopPolling]);
  
  // æ³¨å†Œ
  const register = async (name) => {
    setLoading(true);
    setError('');
    try {
      const addr = genAddress();
      setAddress(addr);
      const result = await GenLayer.registerPlayer(name, 'ğŸ®');
      if (result?.success) {
        setPlayer({ address: addr, name, balance: result.balance || 100 });
        setView('lobby');
        loadRooms();
      } else {
        throw new Error(result?.error || 'æ³¨å†Œå¤±è´¥');
      }
    } catch (e) {
      setError(e.message);
    }
    setLoading(false);
  };
  
  const loadRooms = async () => {
    try { setRooms(await GenLayer.listRooms() || []); } catch (e) { console.error(e); }
  };
  
  const loadLeaderboard = async () => {
    try { setLeaderboard(await GenLayer.getLeaderboard(20) || []); } catch (e) { console.error(e); }
  };
  
  // åˆ›å»ºæˆ¿é—´
  const createRoom = async (theme) => {
    setLoading(true);
    setError('');
    try {
      const result = await GenLayer.createRoom(theme);
      if (result?.success) {
        setCurrentRoom(result.room);
        setPlayer(p => ({ ...p, balance: result.balance }));
        setView('room');
        startPolling(result.room_id);
      } else {
        throw new Error(result?.error || 'åˆ›å»ºå¤±è´¥');
      }
    } catch (e) { setError(e.message); }
    setLoading(false);
  };
  
  // åŠ å…¥æˆ¿é—´
  const joinRoom = async (roomId) => {
    setLoading(true);
    setError('');
    try {
      const result = await GenLayer.joinRoom(roomId);
      if (result?.success) {
        setCurrentRoom(result.room);
        setPlayer(p => ({ ...p, balance: result.balance }));
        setView('room');
        startPolling(roomId);
      } else {
        throw new Error(result?.error || 'åŠ å…¥å¤±è´¥');
      }
    } catch (e) { setError(e.message); }
    setLoading(false);
  };
  
  // å¼€å§‹æ¸¸æˆ
  const startGame = async () => {
    setLoading(true);
    try {
      const result = await GenLayer.startGame(currentRoom.id);
      if (result?.success) {
        setCurrentRoom(result.room);
        setView('game');
      }
    } catch (e) { setError(e.message); }
    setLoading(false);
  };
  
  // æŠ•ç¥¨
  const submitVote = async (choice) => {
    setLoading(true);
    try {
      const result = await GenLayer.submitVote(currentRoom.id, currentRoom.round, choice);
      if (result?.all_voted) {
        await GenLayer.finalizeRound(currentRoom.id);
      }
    } catch (e) { setError(e.message); }
    setLoading(false);
  };
  
  // è·å–å½“å‰å‰§æƒ…
  const getContext = () => {
    if (!currentRoom || !gameState) return '';
    const rd = STORIES[currentRoom.theme]?.rounds[currentRoom.round - 1];
    if (!rd) return '';
    const path = gameState.path || [];
    if (currentRoom.round > 1 && path.length > 0) {
      return rd[`ctx${path.slice(-2).join('')}`] || rd[`ctx${path[path.length-1]}`] || rd.ctx;
    }
    return rd.ctx;
  };
  
  const getOptions = () => {
    const rd = STORIES[currentRoom?.theme]?.rounds[currentRoom?.round - 1];
    return { A: rd?.A, B: rd?.B };
  };

  // ==========================================================================
  // æ¸²æŸ“
  // ==========================================================================
  
  // é¦–é¡µ
  if (view === 'home') {
    return (
      <div style={{ minHeight: '100vh', display: 'flex', alignItems: 'center', justifyContent: 'center', padding: '2rem' }}>
        <div style={{ maxWidth: '400px', width: '100%', textAlign: 'center' }}>
          <div style={{ fontSize: '4rem', marginBottom: '1rem' }}>ğŸ“œ</div>
          <h1 style={{ fontSize: '2rem', background: 'linear-gradient(135deg,#a78bfa,#f472b6)', WebkitBackgroundClip: 'text', WebkitTextFillColor: 'transparent', marginBottom: '0.5rem' }}>å…±è¯†ç¼–å¹´å²</h1>
          <p style={{ color: '#888', marginBottom: '2rem' }}>GenLayer é“¾ä¸Šå¤šäººåä½œæ¸¸æˆ</p>
          <div className="card">
            <h3 style={{ marginBottom: '1rem' }}>è¾“å…¥ä½ çš„åå­—</h3>
            <input 
              className="input" 
              placeholder="ä½ çš„åå­—..." 
              style={{ marginBottom: '1rem', textAlign: 'center' }} 
              onKeyDown={e => e.key === 'Enter' && e.target.value.trim() && register(e.target.value.trim())} 
            />
            {error && <p style={{ color: '#ef4444', marginBottom: '1rem', fontSize: '0.9rem' }}>{error}</p>}
            <button 
              className="btn btn-primary" 
              style={{ width: '100%' }} 
              disabled={loading}
              onClick={e => {
                const input = e.target.parentElement.querySelector('input');
                if (input.value.trim()) register(input.value.trim());
              }}
            >
              {loading ? <span className="loading">â³</span> : 'è¿›å…¥æ¸¸æˆ â†’'}
            </button>
          </div>
          <p style={{ marginTop: '1.5rem', fontSize: '0.75rem', color: '#666' }}>
            åˆçº¦: {CONFIG.CONTRACT_ADDRESS.slice(0,10)}...
          </p>
        </div>
      </div>
    );
  }
  
  // å¤§å…
  if (view === 'lobby') {
    return (
      <div style={{ minHeight: '100vh', padding: '2rem' }}>
        <div style={{ maxWidth: '900px', margin: '0 auto' }}>
          <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '2rem' }}>
            <h1 style={{ fontSize: '1.5rem' }}>ğŸ“œ å…±è¯†ç¼–å¹´å²</h1>
            <div style={{ display: 'flex', alignItems: 'center', gap: '1rem' }}>
              <span>ğŸ® {player?.name}</span>
              <span style={{ color: '#fbbf24' }}>ğŸ’° {player?.balance} GLT</span>
            </div>
          </div>
          
          {error && <div style={{ background: 'rgba(239,68,68,0.1)', padding: '1rem', borderRadius: '8px', marginBottom: '1rem', color: '#ef4444' }}>{error}</div>}
          
          <h2 style={{ marginBottom: '1rem', color: '#a78bfa' }}>ğŸ® é€‰æ‹©ä¸»é¢˜åˆ›å»ºæˆ¿é—´</h2>
          <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(180px, 1fr))', gap: '1rem', marginBottom: '2rem' }}>
            {Object.entries(STORIES).map(([key, s]) => (
              <button key={key} className="card" style={{ textAlign: 'center', cursor: loading ? 'not-allowed' : 'pointer' }} onClick={() => !loading && createRoom(key)}>
                <div style={{ fontSize: '2.5rem', marginBottom: '0.5rem' }}>{s.icon}</div>
                <div style={{ fontWeight: 600, marginBottom: '0.3rem' }}>{s.name}</div>
                <div style={{ fontSize: '0.8rem', color: '#fbbf24' }}>ğŸ« {CONFIG.ENTRY_FEE} GLT</div>
              </button>
            ))}
          </div>
          
          <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '1rem' }}>
            <h2 style={{ color: '#a78bfa' }}>ğŸšª åŠ å…¥æˆ¿é—´</h2>
            <button className="btn" style={{ background: 'rgba(255,255,255,0.1)' }} onClick={loadRooms}>ğŸ”„ åˆ·æ–°</button>
          </div>
          
          {rooms.length === 0 ? (
            <div className="card" style={{ textAlign: 'center', color: '#666' }}>æš‚æ— æˆ¿é—´</div>
          ) : (
            <div style={{ display: 'flex', flexDirection: 'column', gap: '0.5rem' }}>
              {rooms.map(room => (
                <div key={room.id} className="card" style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', padding: '1rem' }}>
                  <div>
                    <span style={{ fontSize: '1.5rem', marginRight: '0.5rem' }}>{STORIES[room.theme]?.icon}</span>
                    <span style={{ fontWeight: 600 }}>{room.host}</span>
                    <span style={{ color: '#888', marginLeft: '1rem' }}>ğŸ‘¥ {room.player_count}/8</span>
                  </div>
                  <button className="btn btn-primary" onClick={() => joinRoom(room.id)}>åŠ å…¥</button>
                </div>
              ))}
            </div>
          )}
          
          <h2 style={{ color: '#fbbf24', marginTop: '2rem', marginBottom: '1rem' }}>ğŸ† æ’è¡Œæ¦œ</h2>
          <button className="btn" style={{ background: 'rgba(255,255,255,0.1)', marginBottom: '1rem' }} onClick={loadLeaderboard}>åŠ è½½</button>
          {leaderboard.length > 0 && (
            <div className="card">
              {leaderboard.slice(0,10).map((e, i) => (
                <div key={i} style={{ display: 'flex', justifyContent: 'space-between', padding: '0.5rem 0' }}>
                  <span style={{ color: i < 3 ? '#fbbf24' : '#888' }}>#{i+1} {e.name}</span>
                  <span style={{ color: '#a78bfa' }}>{e.score} pts</span>
                </div>
              ))}
            </div>
          )}
        </div>
      </div>
    );
  }
  
  // ç­‰å¾…æˆ¿é—´
  if (view === 'room' && currentRoom) {
    const story = STORIES[currentRoom.theme];
    const isHost = currentRoom.host === address;
    
    return (
      <div style={{ minHeight: '100vh', padding: '2rem' }}>
        <div style={{ maxWidth: '600px', margin: '0 auto' }}>
          <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '2rem' }}>
            <button className="btn" style={{ background: 'rgba(255,255,255,0.1)' }} onClick={() => { stopPolling(); setView('lobby'); }}>â† è¿”å›</button>
            <div>
              <span style={{ fontSize: '1.5rem' }}>{story?.icon}</span>
              <span style={{ fontWeight: 600, marginLeft: '0.5rem' }}>{story?.name}</span>
            </div>
            <span style={{ color: '#666', fontSize: '0.8rem' }}>{currentRoom.id}</span>
          </div>
          
          <h3 style={{ color: '#888', marginBottom: '1rem' }}>ç©å®¶ ({currentRoom.players?.length || 0}/8)</h3>
          <div style={{ display: 'grid', gridTemplateColumns: 'repeat(4, 1fr)', gap: '1rem', marginBottom: '2rem' }}>
            {(currentRoom.players || []).map(addr => (
              <div key={addr} className="card" style={{ textAlign: 'center', padding: '1rem' }}>
                <div style={{ fontSize: '2rem' }}>ğŸ®</div>
                <div style={{ fontSize: '0.85rem' }}>{currentRoom.player_names?.[addr] || addr.slice(-6)}</div>
                {addr === currentRoom.host && <div style={{ fontSize: '0.7rem', color: '#fbbf24' }}>æˆ¿ä¸»</div>}
              </div>
            ))}
          </div>
          
          {isHost ? (
            <button 
              className="btn btn-primary" 
              style={{ width: '100%', padding: '1rem' }}
              disabled={loading || (currentRoom.players?.length || 0) < 2}
              onClick={startGame}
            >
              {(currentRoom.players?.length || 0) < 2 ? 'ç­‰å¾…ç©å®¶åŠ å…¥...' : 'ğŸ® å¼€å§‹æ¸¸æˆ'}
            </button>
          ) : (
            <p style={{ textAlign: 'center', color: '#888' }}>ç­‰å¾…æˆ¿ä¸»å¼€å§‹...</p>
          )}
        </div>
      </div>
    );
  }
  
  // æ¸¸æˆä¸­
  if (view === 'game' && currentRoom) {
    const story = STORIES[currentRoom.theme];
    const context = getContext();
    const options = getOptions();
    const myVote = gameState?.current_votes?.[address];
    const voteCount = Object.values(gameState?.current_votes || {}).length;
    const totalPlayers = currentRoom.players?.length || 0;
    
    // æ¸¸æˆç»“æŸ
    if (currentRoom.status === 'finished') {
      return (
        <div style={{ minHeight: '100vh', display: 'flex', alignItems: 'center', justifyContent: 'center', padding: '2rem' }}>
          <div className="card" style={{ maxWidth: '500px', textAlign: 'center' }}>
            <h1 style={{ color: '#fbbf24', marginBottom: '1.5rem' }}>ğŸ† æ¸¸æˆç»“æŸï¼</h1>
            <div style={{ marginBottom: '2rem' }}>
              {Object.entries(gameState?.scores || {}).sort((a,b) => b[1] - a[1]).map(([addr, score], i) => (
                <div key={addr} style={{ display: 'flex', justifyContent: 'space-between', padding: '0.5rem', background: i === 0 ? 'rgba(251,191,36,0.1)' : 'transparent', borderRadius: '8px' }}>
                  <span>#{i+1} {currentRoom.player_names?.[addr] || addr.slice(-6)}</span>
                  <span style={{ color: '#a78bfa' }}>{score} pts</span>
                </div>
              ))}
            </div>
            <button className="btn btn-primary" onClick={() => { stopPolling(); setView('lobby'); loadRooms(); }}>è¿”å›å¤§å…</button>
          </div>
        </div>
      );
    }
    
    return (
      <div style={{ minHeight: '100vh', padding: '2rem' }}>
        <div style={{ maxWidth: '800px', margin: '0 auto' }}>
          {/* çŠ¶æ€æ  */}
          <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '2rem', padding: '1rem', background: 'rgba(0,0,0,0.3)', borderRadius: '12px' }}>
            <div>
              <span style={{ fontSize: '1.3rem' }}>{story?.icon}</span>
              <span style={{ fontWeight: 600, marginLeft: '0.5rem' }}>{story?.name}</span>
            </div>
            <div>ç¬¬ <span style={{ color: '#a78bfa', fontWeight: 700 }}>{currentRoom.round}</span> / {CONFIG.TOTAL_ROUNDS} è½®</div>
            <div>æŠ•ç¥¨: <span style={{ color: '#4ade80' }}>{voteCount}</span> / {totalPlayers}</div>
          </div>
          
          {/* å‰§æƒ… */}
          <div className="card" style={{ marginBottom: '1.5rem' }}>
            <h3 style={{ color: '#a78bfa', marginBottom: '1rem' }}>ğŸ“œ å‰§æƒ…</h3>
            {(gameState?.path || []).map((c, i) => (
              <p key={i} style={{ color: '#4ade80', marginBottom: '0.3rem' }}>ç¬¬{i+1}è½®: é€‰æ‹©äº† {c}</p>
            ))}
            <p style={{ color: '#fbbf24', marginTop: '1rem', fontSize: '1.1rem', lineHeight: 1.6 }}>{context}</p>
          </div>
          
          {/* é€‰é¡¹ */}
          <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '1rem' }}>
            {['A', 'B'].map(key => {
              const opt = options[key];
              if (!opt) return null;
              const color = key === 'A' ? '#ef4444' : '#3b82f6';
              const isMyVote = myVote === key;
              
              return (
                <button 
                  key={key}
                  className="card"
                  style={{ 
                    textAlign: 'left',
                    cursor: myVote ? 'default' : 'pointer',
                    border: `2px solid ${isMyVote ? color : 'rgba(255,255,255,0.08)'}`,
                    background: isMyVote ? `${color}20` : 'rgba(255,255,255,0.03)'
                  }}
                  onClick={() => !myVote && !loading && submitVote(key)}
                  disabled={loading || !!myVote}
                >
                  <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '0.8rem' }}>
                    <span style={{ fontWeight: 700, fontSize: '1.2rem', color }}>{key}</span>
                    <span style={{ fontSize: '0.8rem', padding: '2px 8px', background: 'rgba(255,255,255,0.1)', borderRadius: '12px' }}>{opt.tag}</span>
                  </div>
                  <p style={{ lineHeight: 1.6 }}>{opt.text}</p>
                  {isMyVote && <p style={{ color, marginTop: '0.8rem', fontWeight: 600 }}>âœ“ å·²æŠ•ç¥¨</p>}
                </button>
              );
            })}
          </div>
          
          {myVote && (
            <p style={{ textAlign: 'center', marginTop: '1.5rem', color: '#888' }}>
              ç­‰å¾…å…¶ä»–ç©å®¶æŠ•ç¥¨... ({voteCount}/{totalPlayers})
            </p>
          )}
        </div>
      </div>
    );
  }
  
  return (
    <div style={{ minHeight: '100vh', display: 'flex', alignItems: 'center', justifyContent: 'center' }}>
      <span className="loading" style={{ fontSize: '3rem' }}>â³</span>
    </div>
  );
}

ReactDOM.createRoot(document.getElementById('root')).render(<App />);
</script>
</body>
</html>
