<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Consensus Chronicle</title>
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-database-compat.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: system-ui, -apple-system, sans-serif; background: #0a0a0a; color: #e8e8e8; }
    ::-webkit-scrollbar { width: 6px; }
    ::-webkit-scrollbar-track { background: rgba(0,0,0,0.3); }
    ::-webkit-scrollbar-thumb { background: #d4a574; border-radius: 3px; }
  </style>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
    const { useState, useEffect, useRef } = React;

    const CONFIG = {
      ROOM_SIZE: { min: 2, max: 8 },
      DEBATE_DURATION: 60,
      VOTE_DURATION: 20,
      TOTAL_ROUNDS: 5,
      ROOM_TIMEOUT_AI: 60000,
      ROOM_TIMEOUT_CLOSE: 120000,
      GENLAYER_CONTRACT: '0x4F5F132ba540f1C685B0188D59990302903aE186',
      FIREBASE: {
        apiKey: "AIzaSyBX4tOb30jWKK6aBUsqERQaOAF4CxCfMmQ",
        authDomain: "consensus-chronicle.firebaseapp.com",
        databaseURL: "https://consensus-chronicle-default-rtdb.firebaseio.com",
        projectId: "consensus-chronicle"
      }
    };

    const C = { bg: '#0a0a0a', bgLight: '#111', bgCard: '#1a1a1a', gold: '#d4a574', goldLight: '#e8c9a0', goldDark: '#a67c52', accent: '#fbbf24', text: '#e8e8e8', muted: '#888', border: 'rgba(212,165,116,0.3)', success: '#4ade80', error: '#ef4444', optA: '#ef4444', optB: '#3b82f6' };

    const THEMES = {
      fantasy: { name: 'Fantasy Quest', icon: 'üè∞', opening: 'The ancient prophecy has come true - the Black Dragon awakens after a thousand years. The kingdom is in peril, and the King summons heroes from across the land...', rounds: [{ context: 'The dragon threat is imminent. The kingdom must make its first crucial decision.', a: { text: 'Assemble the army and strike the dragon lair before it fully awakens.', tag: 'Aggressive' }, b: { text: 'Send envoys to seek help from the Elven kingdom who sealed the dragon before.', tag: 'Diplomatic' } }, { context: 'The situation develops further, new choices emerge.', a: { text: 'Take a more aggressive strategy, spare no cost.', tag: 'Bold' }, b: { text: 'Seek more allies, build a united front.', tag: 'Cautious' } }, { context: 'A critical moment arrives, every decision affects the final outcome.', a: { text: 'Use forbidden magic, sacrifice the few to save the many.', tag: 'Sacrifice' }, b: { text: 'Preserve strength, wait for a better opportunity.', tag: 'Patient' } }, { context: 'The battle reaches its climax.', a: { text: 'Launch the final assault, all or nothing.', tag: 'Decisive' }, b: { text: 'Attempt negotiation, seek a peaceful solution.', tag: 'Peaceful' } }, { context: 'The moment of final choice.', a: { text: 'Victory at any cost.', tag: 'Victory' }, b: { text: 'Reach consensus with the enemy, start a new era.', tag: 'Coexist' } }], endings: { default: 'Through difficult choices, the heroes wrote their own legend. Whatever the outcome, this story will be passed down forever.' } },
      scifi: { name: 'Sci-Fi Future', icon: 'üöÄ', opening: 'Year 2157, Mars colony "New Hope" receives a mysterious signal from deep space - Earth will be hit by an asteroid in 100 days...', rounds: [{ context: 'After the news breaks, the colony falls into panic.', a: { text: 'Launch the Ark Plan, lottery decides who escapes.', tag: 'Fair' }, b: { text: 'Focus resources on researching the signal source.', tag: 'Explore' } }, { context: 'New situations emerge, further decisions needed.', a: { text: 'Prioritize protecting key personnel and technology.', tag: 'Elite' }, b: { text: 'Insist on equality for all.', tag: 'Equal' } }, { context: 'Resources become more scarce.', a: { text: 'Implement rationing, strict control.', tag: 'Control' }, b: { text: 'Maintain free distribution.', tag: 'Freedom' } }, { context: 'External contact shows promise.', a: { text: 'Accept alien civilization help conditions.', tag: 'Cooperate' }, b: { text: 'Insist on human independence.', tag: 'Independent' } }, { context: 'The final moment.', a: { text: 'Risk everything, try to change the asteroid trajectory.', tag: 'Risk' }, b: { text: 'Accept fate, focus on civilization continuation.', tag: 'Accept' } }], endings: { default: 'At the crossroads of destiny, humanity made its own choice. Whatever the result, it was humanity\'s own decision.' } },
      mystery: { name: 'Mystery Detective', icon: 'üîç', opening: 'On a stormy night, wealthy Mr. Chen is poisoned in his study. The door locked from inside, five suspects each hiding secrets...', rounds: [{ context: 'As the detective, you must begin investigating.', a: { text: 'Search the victim\'s study for evidence.', tag: 'Evidence' }, b: { text: 'Interview each person present.', tag: 'Interview' } }, { context: 'Investigation reveals new findings.', a: { text: 'Deep dive into the inheritance issue.', tag: 'Money' }, b: { text: 'Investigate the mysterious visitor\'s identity.', tag: 'Identity' } }, { context: 'The case becomes complex.', a: { text: 'Verify suspects\' alibis.', tag: 'Verify' }, b: { text: 'Investigate connection to old cases.', tag: 'History' } }, { context: 'Truth begins to surface.', a: { text: 'Directly confront the main suspect.', tag: 'Confront' }, b: { text: 'Re-examine key evidence.', tag: 'Evidence' } }, { context: 'Final judgment moment.', a: { text: 'Reveal all truth, let law decide.', tag: 'Justice' }, b: { text: 'Give involved parties a choice.', tag: 'Mercy' } }], endings: { default: 'This case concludes in an unexpected way, becoming a legendary tale people discuss.' } },
      political: { name: 'Palace Intrigue', icon: 'üëë', opening: 'The Qi Dynasty, year 30 of Yong\'an. The old Emperor has passed. The edict states the throne goes to "whoever best represents the people\'s will". Three princes each scheme...', rounds: [{ context: 'As the Cabinet Chief, you must maintain order.', a: { text: 'Support the Crown Prince by tradition.', tag: 'Traditional' }, b: { text: 'Propose open selection, let the worthy rule.', tag: 'Reform' } }, { context: 'Various factions begin to struggle.', a: { text: 'Ally with the military to stabilize.', tag: 'Military' }, b: { text: 'Win over the civil official faction.', tag: 'Civil' } }, { context: 'External forces begin to intervene.', a: { text: 'Be firm externally, show national might.', tag: 'Strong' }, b: { text: 'Prioritize peace, avoid conflict.', tag: 'Peaceful' } }, { context: 'Internal conflicts intensify.', a: { text: 'Decisively eliminate opposition.', tag: 'Decisive' }, b: { text: 'Seek compromise, balance all sides.', tag: 'Balance' } }, { context: 'The final choice.', a: { text: 'Establish a new power structure.', tag: 'Reform' }, b: { text: 'Maintain traditional order.', tag: 'Preserve' } }], endings: { default: 'In the game of power, every choice affects countless lives. This is the weight of history.' } }
    };

    const AI_PLAYERS = [
      { id: 'ai_1', name: 'Sage Iris', avatar: 'üßô‚Äç‚ôÄÔ∏è', exp: 0, isAI: true, style: 'analytical' },
      { id: 'ai_2', name: 'Knight Kane', avatar: '‚öîÔ∏è', exp: 0, isAI: true, style: 'bold' },
      { id: 'ai_3', name: 'Scholar Noah', avatar: 'üìö', exp: 0, isAI: true, style: 'cautious' }
    ];

    const genAIDebate = (style) => {
      const d = { analytical: { A: ['Logically, A has higher success rate', 'Data suggests A is optimal'], B: ['After analysis, B yields better long-term results', 'Considering all factors, B is wiser'] }, bold: { A: ['Fortune favors the bold! A is the hero\'s choice!', 'Strike now! Support A!'], B: ['True courage lies in B!', 'Smart and brave choose B!'] }, cautious: { A: ['Though risky, A might be necessary', 'Lesser of two evils, support A'], B: ['To be safe, B is better', 'Steady wins the race, choose B'] } };
      const c = Math.random() > 0.5 ? 'A' : 'B';
      return { text: (d[style]?.[c] || d.analytical[c])[Math.floor(Math.random() * 2)] || d.analytical[c][0], choice: c };
    };

    function App() {
      const [db, setDb] = useState(null);
      const [wallet, setWallet] = useState(null);
      const [connecting, setConnecting] = useState(false);
      const [showRules, setShowRules] = useState(false);
      const [tab, setTab] = useState('game');
      const [view, setView] = useState('home');
      const [player, setPlayer] = useState({ id: '', name: '', avatar: 'üéÆ', exp: 0 });
      const [roomId, setRoomId] = useState(null);
      const [myRoomId, setMyRoomId] = useState(null);
      const [roomData, setRoomData] = useState(null);
      const [players, setPlayers] = useState([]);
      const [game, setGame] = useState(null);
      const [msgs, setMsgs] = useState([]);
      const [rooms, setRooms] = useState([]);
      const [input, setInput] = useState('');
      const [myVote, setMyVote] = useState(null);
      const [timer, setTimer] = useState(0);
      const [lb, setLb] = useState([]);
      const [hist, setHist] = useState([]);
      const [loading, setLoading] = useState(false);
      const timerRef = useRef(null);
      const msgsEndRef = useRef(null);
      const roomChkRef = useRef(null);

      useEffect(() => {
        try {
          if (!firebase.apps.length) firebase.initializeApp(CONFIG.FIREBASE);
          const database = firebase.database();
          setDb(database);
          // Leaderboard: group by wallet, sort by exp descending
          database.ref('players').orderByChild('exp').on('value', s => {
            if (s.val()) {
              const list = Object.entries(s.val()).map(([id, p]) => ({ ...p, id })).filter(p => p.exp > 0).sort((a, b) => b.exp - a.exp);
              setLb(list.slice(0, 50));
            }
          });
        } catch (e) { console.error(e); }
        const sw = localStorage.getItem('cc_wallet');
        const sp = localStorage.getItem('cc_player');
        const sr = localStorage.getItem('cc_myroom');
        if (sw && sp) { try { setWallet(sw); setPlayer(JSON.parse(sp)); } catch {} }
        if (sr) setMyRoomId(sr);
        if (window.ethereum && sw) { window.ethereum.request({ method: 'eth_accounts' }).then(a => { if (a[0]?.toLowerCase() === sw.toLowerCase()) setWallet(a[0]); }); }
        return () => { if (timerRef.current) clearInterval(timerRef.current); if (roomChkRef.current) clearInterval(roomChkRef.current); };
      }, []);

      // Load user history
      useEffect(() => {
        if (!db || !wallet) return;
        db.ref('gameHistory').orderByChild('wallet').equalTo(wallet).on('value', s => {
          if (s.val()) {
            const list = Object.values(s.val()).sort((a, b) => b.timestamp - a.timestamp);
            setHist(list);
          } else {
            setHist([]);
          }
        });
      }, [db, wallet]);

      useEffect(() => {
        if (!db) return;
        db.ref('rooms').on('value', s => {
          const d = s.val(); const now = Date.now();
          if (d) {
            const r = [];
            Object.entries(d).forEach(([id, rm]) => {
              if (rm.status === 'waiting' && (now - rm.createdAt) < CONFIG.ROOM_TIMEOUT_CLOSE) r.push({ id, ...rm });
              if (rm.status === 'waiting' && (now - rm.createdAt) > CONFIG.ROOM_TIMEOUT_CLOSE) db.ref(`rooms/${id}`).update({ status: 'closed' });
            });
            setRooms(r);
          } else setRooms([]);
        });
      }, [db]);

      useEffect(() => {
        if (!db || !roomId) return;
        const rRef = db.ref(`rooms/${roomId}`);
        const gRef = db.ref(`games/${roomId}`);
        rRef.on('value', s => {
          const d = s.val();
          if (d) {
            setRoomData(d);
            if (d.players) setPlayers(Object.values(d.players));
            if (d.status === 'closed') { alert('Room closed'); reset(); }
            if (d.status === 'playing' && view !== 'game') { setView('game'); setMyVote(null); }
          }
        });
        gRef.on('value', s => {
          const d = s.val();
          if (d) {
            setGame(d);
            if (d.messages) setMsgs(Object.values(d.messages).sort((a, b) => a.timestamp - b.timestamp));
            if (d.phase === 'debate') setMyVote(null);
            if (d.timerEnd && d.phase !== 'ended') setTimer(Math.max(0, Math.floor((d.timerEnd - Date.now()) / 1000)));
          }
        });
        return () => { rRef.off(); gRef.off(); };
      }, [db, roomId, view]);

      useEffect(() => {
        if (!db || !roomId || !roomData || roomData.status !== 'waiting') return;
        if (roomChkRef.current) clearInterval(roomChkRef.current);
        roomChkRef.current = setInterval(() => {
          const age = Date.now() - roomData.createdAt;
          const realCnt = Object.values(roomData.players || {}).filter(p => !p.isAI).length;
          if (age > CONFIG.ROOM_TIMEOUT_AI && realCnt === 1 && player.id === roomData.host) {
            const curIds = Object.keys(roomData.players || {});
            AI_PLAYERS.filter(ai => !curIds.includes(ai.id)).slice(0, CONFIG.ROOM_SIZE.min - 1).forEach((ai, i) => {
              setTimeout(() => db.ref(`rooms/${roomId}/players/${ai.id}`).set(ai), i * 1000);
            });
          }
        }, 5000);
        return () => { if (roomChkRef.current) clearInterval(roomChkRef.current); };
      }, [db, roomId, roomData, player.id]);

      useEffect(() => {
        if (!game?.timerEnd || game?.phase === 'ended') return;
        if (timerRef.current) clearInterval(timerRef.current);
        timerRef.current = setInterval(() => {
          const rem = Math.max(0, Math.floor((game.timerEnd - Date.now()) / 1000));
          setTimer(rem);
          if (rem <= 0 && player.id === roomData?.host) phaseEnd();
        }, 1000);
        return () => { if (timerRef.current) clearInterval(timerRef.current); };
      }, [game?.timerEnd, game?.phase, player.id, roomData?.host]);

      useEffect(() => { msgsEndRef.current?.scrollIntoView({ behavior: 'smooth' }); }, [msgs]);

      const connectWallet = async () => {
        if (!window.ethereum) { alert('Please install MetaMask'); return null; }
        setConnecting(true);
        try {
          const accs = await window.ethereum.request({ method: 'eth_requestAccounts' });
          const addr = accs[0]; 
          setWallet(addr);
          localStorage.setItem('cc_wallet', addr);
          if (db) {
            const snap = await db.ref(`players/${addr}`).once('value');
            const saved = snap.val();
            if (saved) { 
              setPlayer({ id: addr, name: saved.name || '', avatar: saved.avatar || 'üéÆ', exp: saved.exp || 0 }); 
              localStorage.setItem('cc_player', JSON.stringify({ id: addr, name: saved.name || '', avatar: saved.avatar || 'üéÆ', exp: saved.exp || 0 })); 
            } else { 
              setPlayer(p => ({ ...p, id: addr, exp: 0 })); 
              localStorage.setItem('cc_player', JSON.stringify({ ...player, id: addr, exp: 0 })); 
            }
          }
          return addr;
        } catch (e) { alert('Connection failed'); return null; }
        finally { setConnecting(false); }
      };

      const disconnect = () => { 
        setWallet(null); 
        setPlayer({ id: '', name: '', avatar: 'üéÆ', exp: 0 }); 
        setMyRoomId(null);
        localStorage.removeItem('cc_wallet'); 
        localStorage.removeItem('cc_player'); 
        localStorage.removeItem('cc_myroom');
      };

      const payFee = async (addr) => {
        if (!window.ethereum) return false;
        setLoading(true);
        try { 
          await window.ethereum.request({ method: 'eth_sendTransaction', params: [{ from: addr, to: CONFIG.GENLAYER_CONTRACT, value: '0x0', data: '0x' }] }); 
          return true; 
        } catch (e) { 
          alert(e.code === 4001 ? 'User cancelled' : 'Transaction failed'); 
          return false; 
        } finally { setLoading(false); }
      };

      const recordToGL = async () => {
        if (!wallet || !window.ethereum) return;
        try { await window.ethereum.request({ method: 'eth_sendTransaction', params: [{ from: wallet, to: CONFIG.GENLAYER_CONTRACT, value: '0x0', data: '0x01' }] }); } catch {}
      };

      const createRoom = async (theme) => {
        if (!db || !player.name) { alert('Please enter your name first'); return; }
        let addr = wallet;
        if (!addr) { addr = await connectWallet(); if (!addr) return; }
        if (!await payFee(addr)) return;
        const rid = `room_${Date.now()}`;
        await db.ref(`rooms/${rid}`).set({ theme, host: addr, status: 'waiting', createdAt: Date.now(), players: { [addr]: { id: addr, name: player.name, avatar: player.avatar, exp: player.exp, isAI: false } } });
        setRoomId(rid); 
        setMyRoomId(rid);
        localStorage.setItem('cc_myroom', rid);
        setView('room');
      };

      const joinRoom = async (rid) => {
        if (!db || !player.name) { alert('Please enter your name first'); return; }
        let addr = wallet;
        if (!addr) { addr = await connectWallet(); if (!addr) return; }
        
        // If rejoining own room, no payment needed
        if (rid === myRoomId) {
          const roomSnap = await db.ref(`rooms/${rid}`).once('value');
          const roomVal = roomSnap.val();
          if (roomVal && roomVal.status === 'waiting') {
            await db.ref(`rooms/${rid}/players/${addr}`).set({ id: addr, name: player.name, avatar: player.avatar, exp: player.exp, isAI: false });
            setRoomId(rid);
            setView('room');
            return;
          }
        }
        
        // Otherwise need payment
        if (!await payFee(addr)) return;
        await db.ref(`rooms/${rid}/players/${addr}`).set({ id: addr, name: player.name, avatar: player.avatar, exp: player.exp, isAI: false });
        setRoomId(rid);
        setView('room');
      };

      const addAI = async () => {
        if (!db || !roomId) return;
        const curIds = Object.keys(roomData?.players || {});
        AI_PLAYERS.filter(ai => !curIds.includes(ai.id)).slice(0, Math.min(3, CONFIG.ROOM_SIZE.max - curIds.length)).forEach(ai => db.ref(`rooms/${roomId}/players/${ai.id}`).set(ai));
      };

      const startGame = async () => {
        if (!db || !roomId || players.length < CONFIG.ROOM_SIZE.min) return;
        await db.ref(`rooms/${roomId}`).update({ status: 'playing' });
        const theme = roomData?.theme || 'fantasy';
        const arc = THEMES[theme];
        const scores = {}; players.forEach(p => { scores[p.id] = { influence: 0, debates: 0, wins: 0 }; });
        await db.ref(`games/${roomId}`).set({ round: 1, phase: 'debate', path: [], scores, votes: {}, story: [{ text: arc.opening, type: 'opening', round: 0 }], timerEnd: Date.now() + CONFIG.DEBATE_DURATION * 1000, messages: {} });
        addMsg('system', `üìñ ${arc.name} begins! Round 1/${CONFIG.TOTAL_ROUNDS} - Debate`);
        setTimeout(() => aiDebate(), 3000);
      };

      const aiDebate = () => {
        players.filter(p => p.isAI).forEach((ai, i) => {
          setTimeout(() => { const d = genAIDebate(ai.style); addMsg('chat', d.text, ai, d.choice); }, (i + 1) * 3000 + Math.random() * 5000);
        });
      };

      const phaseEnd = async () => {
        if (!db || !roomId || !game) return;
        if (game.phase === 'debate') {
          await db.ref(`games/${roomId}`).update({ phase: 'vote', timerEnd: Date.now() + CONFIG.VOTE_DURATION * 1000, votes: {} });
          addMsg('system', 'üó≥Ô∏è Voting begins! All players please vote!');
          players.filter(p => p.isAI).forEach((ai, i) => { setTimeout(() => db.ref(`games/${roomId}/votes/${ai.id}`).set(Math.random() > 0.5 ? 'A' : 'B'), (i + 1) * 2000); });
        } else if (game.phase === 'vote') { await calcResult(); }
      };

      const calcResult = async () => {
        if (!db || !roomId || !game) return;
        const votes = game.votes || {};
        const cnt = { A: 0, B: 0 }; Object.values(votes).forEach(v => { if (v) cnt[v]++; });
        const winner = cnt.A >= cnt.B ? 'A' : 'B';
        const round = game.round;
        const theme = roomData?.theme || 'fantasy';
        const arc = THEMES[theme];
        const rd = arc.rounds[round - 1];
        const winOpt = winner === 'A' ? rd?.a : rd?.b;
        const newScores = { ...game.scores };
        Object.entries(votes).forEach(([id, v]) => { if (v === winner && newScores[id]) { newScores[id].influence = (newScores[id].influence || 0) + 30; newScores[id].wins = (newScores[id].wins || 0) + 1; } });
        const newPath = [...(game.path || []), winner];
        const newStory = [...(game.story || []), { text: `[Vote Result] Option ${winner} (${cnt[winner]} votes)`, type: 'choice', round, winner }, { text: `Chose "${winOpt?.tag}": ${winOpt?.text}`, type: 'consequence', round }];
        addMsg('system', `üìú Option ${winner} wins! (${cnt[winner]} votes)`);

        if (round >= CONFIG.TOTAL_ROUNDS) {
          const ending = arc.endings.default;
          await db.ref(`games/${roomId}`).update({ phase: 'ended', scores: newScores, path: newPath, story: [...newStory, { text: ending, type: 'ending', round }], timerEnd: null });
          addMsg('system', 'üèÜ Chronicle Complete!');
          await recordToGL();
          
          // Count real players and AI
          const realCount = players.filter(p => !p.isAI).length;
          const aiCount = players.filter(p => p.isAI).length;
          
          // Save history for each real player
          players.filter(p => !p.isAI).forEach(p => {
            db.ref('gameHistory').push().set({ 
              id: Date.now(), 
              timestamp: Date.now(), 
              theme, 
              path: newPath.join(''), 
              ending: ending.slice(0, 80) + '...', 
              datetime: new Date().toISOString(),
              realPlayers: realCount,
              aiPlayers: aiCount,
              roomId,
              wallet: p.id
            });
          });
          
          // Update exp for real players
          Object.entries(newScores).forEach(([pid, sc]) => {
            const p = players.find(x => x.id === pid);
            if (p && !p.isAI) {
              const total = (sc.influence || 0) + (sc.debates || 0);
              if (total > 0) {
                db.ref(`players/${pid}`).once('value').then(snap => {
                  const cur = snap.val()?.exp || 0;
                  const newExp = cur + total;
                  db.ref(`players/${pid}`).update({ name: p.name, avatar: p.avatar, exp: newExp });
                  if (pid === player.id) { 
                    setPlayer(prev => ({ ...prev, exp: newExp })); 
                    localStorage.setItem('cc_player', JSON.stringify({ ...player, exp: newExp })); 
                  }
                });
              }
            }
          });
          
          // Clear my room after game ends
          setMyRoomId(null);
          localStorage.removeItem('cc_myroom');
        } else {
          const nextRd = round + 1;
          const nextCtx = arc.rounds[nextRd - 1]?.context || 'The story continues...';
          await db.ref(`games/${roomId}`).update({ round: nextRd, phase: 'debate', scores: newScores, path: newPath, story: [...newStory, { text: nextCtx, type: 'context', round: nextRd }], timerEnd: Date.now() + CONFIG.DEBATE_DURATION * 1000, votes: {} });
          addMsg('system', `üìñ Round ${nextRd}/${CONFIG.TOTAL_ROUNDS} - Debate`);
          setTimeout(() => aiDebate(), 3000);
        }
      };

      const addMsg = async (type, text, sender = null, choice = null) => { if (db && roomId) await db.ref(`games/${roomId}/messages`).push().set({ type, text, sender, choice, timestamp: Date.now() }); };
      
      const submitDebate = async () => {
        if (!input.trim() || game?.phase !== 'debate') return;
        const c = input.toUpperCase().includes('A') ? 'A' : input.toUpperCase().includes('B') ? 'B' : null;
        await addMsg('chat', input, { id: player.id, name: player.name, avatar: player.avatar }, c);
        setInput('');
        if (game?.scores?.[player.id] !== undefined) await db.ref(`games/${roomId}/scores/${player.id}/debates`).set((game.scores[player.id].debates || 0) + 10);
      };
      
      const vote = async (c) => { if (game?.phase !== 'vote' || myVote) return; setMyVote(c); await db.ref(`games/${roomId}/votes/${player.id}`).set(c); };
      
      const reset = () => { 
        if (timerRef.current) clearInterval(timerRef.current); 
        if (roomChkRef.current) clearInterval(roomChkRef.current); 
        setRoomId(null); 
        setRoomData(null); 
        setGame(null); 
        setPlayers([]); 
        setMsgs([]); 
        setMyVote(null); 
        setView('home'); 
      };
      
      const fmtTime = s => `${Math.floor(s / 60)}:${(s % 60).toString().padStart(2, '0')}`;
      const shortAddr = a => a ? `${a.slice(0, 6)}...${a.slice(-4)}` : '';
      const getOpts = () => { if (!game || !roomData) return { a: null, b: null }; const rd = THEMES[roomData.theme]?.rounds[(game.round || 1) - 1]; return { a: rd?.a, b: rd?.b }; };
      const opts = getOpts();
      const votes = game?.votes || {};
      const theme = roomData?.theme ? THEMES[roomData.theme] : THEMES.fantasy;

      // Rules Modal
      const RulesModal = () => showRules && (
        <div style={{ position: 'fixed', inset: 0, background: 'rgba(0,0,0,0.9)', display: 'flex', alignItems: 'center', justifyContent: 'center', zIndex: 1000, padding: '1rem' }}>
          <div style={{ background: C.bgCard, borderRadius: '16px', padding: '2rem', maxWidth: '600px', maxHeight: '80vh', overflowY: 'auto', border: `1px solid ${C.border}` }}>
            <h2 style={{ color: C.gold, marginBottom: '1.5rem', textAlign: 'center' }}>üìñ Game Rules</h2>
            <div style={{ color: C.text, lineHeight: 1.8 }}>
              <h3 style={{ color: C.goldLight, marginBottom: '0.5rem' }}>üéØ Objective</h3>
              <p style={{ marginBottom: '1rem', color: C.muted }}>Complete 5 rounds of story decisions with other players. Influence the story through debate and voting to earn the highest score!</p>
              
              <h3 style={{ color: C.goldLight, marginBottom: '0.5rem' }}>üîó Entry Rules</h3>
              <p style={{ marginBottom: '1rem', color: C.muted }}>‚Ä¢ Connect MetaMask wallet to create/join rooms<br/>‚Ä¢ Confirm GenLayer transaction (0 GEN fee)<br/>‚Ä¢ Transaction failure prevents room creation/joining</p>
              
              <h3 style={{ color: C.goldLight, marginBottom: '0.5rem' }}>‚è∞ Room Rules</h3>
              <p style={{ marginBottom: '1rem', color: C.muted }}>‚Ä¢ Minimum 2 players, maximum 8 players<br/>‚Ä¢ AI auto-fills after 1 minute if no one joins<br/>‚Ä¢ Room auto-closes after 2 minutes if not started</p>
              
              <h3 style={{ color: C.goldLight, marginBottom: '0.5rem' }}>üéÆ Game Flow</h3>
              <p style={{ marginBottom: '1rem', color: C.muted }}>‚Ä¢ <b>Debate Phase (60s)</b>: Read background, share opinions in chat<br/>‚Ä¢ <b>Vote Phase (20s)</b>: All players choose A or B<br/>‚Ä¢ <b>Result</b>: Majority vote determines story direction<br/>‚Ä¢ 5 rounds total, story branches based on choices</p>
              
              <h3 style={{ color: C.goldLight, marginBottom: '0.5rem' }}>‚≠ê Scoring</h3>
              <p style={{ marginBottom: '1rem', color: C.muted }}>‚Ä¢ Submit debate opinion: +10 points<br/>‚Ä¢ Vote for winning option: +30 points<br/>‚Ä¢ Points accumulate to player EXP</p>
              
              <h3 style={{ color: C.goldLight, marginBottom: '0.5rem' }}>üìä Data Storage</h3>
              <p style={{ color: C.muted }}>‚Ä¢ Real-time data: Firebase<br/>‚Ä¢ Final results: GenLayer blockchain</p>
            </div>
            <button onClick={() => setShowRules(false)} style={{ width: '100%', padding: '1rem', marginTop: '1.5rem', background: `linear-gradient(135deg, ${C.gold}, ${C.goldDark})`, border: 'none', borderRadius: '10px', color: '#000', fontSize: '1rem', fontWeight: 600, cursor: 'pointer' }}>Got it!</button>
          </div>
        </div>
      );

      // HOME VIEW
      if (view === 'home') return (
        <div style={{ minHeight: '100vh', background: C.bg, color: C.text }}>
          <RulesModal />
          <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', padding: '1rem 2rem', borderBottom: `1px solid ${C.border}`, background: C.bgLight }}>
            <div style={{ display: 'flex', alignItems: 'center', gap: '0.8rem' }}><span style={{ fontSize: '1.3rem' }}>üìú</span><span style={{ fontSize: '1.1rem', fontWeight: 700, color: C.gold }}>Consensus Chronicle</span></div>
            <div style={{ display: 'flex', alignItems: 'center', gap: '1rem' }}>
              {player.name && <span style={{ color: C.muted, fontSize: '0.9rem' }}>{player.avatar} {player.name} ‚Ä¢ ‚≠ê{player.exp}</span>}
              {wallet ? (
                <button onClick={disconnect} style={{ padding: '0.4rem 0.8rem', background: `${C.success}15`, border: `1px solid ${C.success}40`, borderRadius: '20px', fontSize: '0.8rem', color: C.success, cursor: 'pointer' }} title="Click to disconnect">üîó {shortAddr(wallet)}</button>
              ) : (
                <button onClick={connectWallet} disabled={connecting} style={{ padding: '0.5rem 1rem', background: `linear-gradient(135deg, ${C.gold}, ${C.goldDark})`, border: 'none', borderRadius: '20px', color: '#000', fontSize: '0.85rem', fontWeight: 600, cursor: 'pointer' }}>{connecting ? 'Connecting...' : 'ü¶ä Connect Wallet'}</button>
              )}
            </div>
          </div>
          
          <div style={{ display: 'flex', justifyContent: 'center', gap: '0.8rem', padding: '1rem', borderBottom: `1px solid ${C.border}20`, background: C.bgLight }}>
            {[{ k: 'game', l: 'üéÆ Game' }, { k: 'leaderboard', l: 'üèÜ Leaderboard' }, { k: 'history', l: 'üìö History' }].map(t => (
              <button key={t.k} onClick={() => setTab(t.k)} style={{ padding: '0.5rem 1.2rem', background: tab === t.k ? `${C.gold}20` : 'transparent', border: tab === t.k ? `1px solid ${C.gold}50` : '1px solid transparent', borderRadius: '8px', color: tab === t.k ? C.gold : C.muted, fontSize: '0.9rem', cursor: 'pointer' }}>{t.l}</button>
            ))}
            <button onClick={() => setShowRules(true)} style={{ padding: '0.5rem 1.2rem', background: `${C.accent}15`, border: `1px solid ${C.accent}30`, borderRadius: '8px', color: C.accent, fontSize: '0.9rem', cursor: 'pointer' }}>üìñ Rules</button>
          </div>
          
          <div style={{ maxWidth: '1000px', margin: '0 auto', padding: '2rem' }}>
            {tab === 'game' && (
              <>
                {!player.name ? (
                  <div style={{ maxWidth: '400px', margin: '3rem auto', textAlign: 'center' }}>
                    <h2 style={{ marginBottom: '1rem', color: C.gold }}>Enter Your Name</h2>
                    <input type="text" placeholder="Your name..." style={{ width: '100%', padding: '1rem', fontSize: '1rem', background: C.bgCard, border: `2px solid ${C.border}`, borderRadius: '12px', color: C.text, outline: 'none', textAlign: 'center' }} onKeyDown={e => { 
                      if (e.key === 'Enter' && e.target.value.trim()) { 
                        const n = e.target.value.trim(); 
                        setPlayer(p => ({ ...p, name: n })); 
                        if (wallet) { 
                          localStorage.setItem('cc_player', JSON.stringify({ ...player, name: n })); 
                          db?.ref(`players/${wallet}`).update({ name: n, avatar: player.avatar }); 
                        } 
                      } 
                    }} />
                    <p style={{ marginTop: '0.5rem', color: C.muted, fontSize: '0.85rem' }}>Press Enter to confirm</p>
                  </div>
                ) : (
                  <>
                    <div style={{ textAlign: 'center', marginBottom: '1.5rem', padding: '0.8rem', background: `${C.gold}10`, borderRadius: '10px', border: `1px solid ${C.border}` }}>
                      <p style={{ color: C.gold }}>‚ö° Creating/Joining requires GenLayer transaction (0 GEN)</p>
                    </div>
                    
                    {/* My Room - can rejoin without payment */}
                    {myRoomId && rooms.find(r => r.id === myRoomId) && (
                      <div style={{ marginBottom: '2rem', padding: '1rem', background: `${C.gold}15`, borderRadius: '10px', border: `1px solid ${C.gold}40` }}>
                        <h3 style={{ color: C.gold, marginBottom: '0.5rem' }}>üè† Your Room</h3>
                        <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
                          <div style={{ display: 'flex', alignItems: 'center', gap: '0.8rem' }}>
                            <span style={{ fontSize: '1.5rem' }}>{THEMES[rooms.find(r => r.id === myRoomId)?.theme]?.icon}</span>
                            <span>{THEMES[rooms.find(r => r.id === myRoomId)?.theme]?.name}</span>
                          </div>
                          <button onClick={() => joinRoom(myRoomId)} style={{ padding: '0.5rem 1.5rem', background: `linear-gradient(135deg, ${C.gold}, ${C.goldDark})`, border: 'none', borderRadius: '8px', color: '#000', fontWeight: 600, cursor: 'pointer' }}>Rejoin (Free)</button>
                        </div>
                      </div>
                    )}
                    
                    {/* Available Rooms */}
                    {rooms.filter(r => r.id !== myRoomId).length > 0 && (
                      <div style={{ marginBottom: '2rem' }}>
                        <h3 style={{ color: C.gold, marginBottom: '1rem' }}>üö™ Available Rooms</h3>
                        {rooms.filter(r => r.id !== myRoomId).map(r => (
                          <div key={r.id} style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', padding: '1rem', marginBottom: '0.5rem', background: C.bgCard, borderRadius: '10px', border: `1px solid ${C.border}` }}>
                            <div style={{ display: 'flex', alignItems: 'center', gap: '0.8rem' }}>
                              <span style={{ fontSize: '1.5rem' }}>{THEMES[r.theme]?.icon}</span>
                              <div>
                                <div style={{ fontWeight: 600 }}>{THEMES[r.theme]?.name}</div>
                                <div style={{ fontSize: '0.8rem', color: C.muted }}>{Object.keys(r.players || {}).length}/{CONFIG.ROOM_SIZE.max} players</div>
                              </div>
                            </div>
                            <button onClick={() => joinRoom(r.id)} disabled={loading} style={{ padding: '0.5rem 1.5rem', background: loading ? C.bgCard : `linear-gradient(135deg, ${C.gold}, ${C.goldDark})`, border: 'none', borderRadius: '8px', color: loading ? C.muted : '#000', fontWeight: 600, cursor: loading ? 'not-allowed' : 'pointer' }}>{loading ? 'Processing...' : 'Join'}</button>
                          </div>
                        ))}
                      </div>
                    )}
                    
                    <h3 style={{ color: C.gold, marginBottom: '1rem', textAlign: 'center' }}>Select Theme to Create Room</h3>
                    <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(180px, 1fr))', gap: '1rem' }}>
                      {Object.entries(THEMES).map(([k, t]) => (
                        <button key={k} onClick={() => createRoom(k)} disabled={loading} style={{ display: 'flex', flexDirection: 'column', alignItems: 'center', padding: '1.5rem', background: C.bgCard, border: `1px solid ${C.border}`, borderRadius: '14px', cursor: loading ? 'not-allowed' : 'pointer', opacity: loading ? 0.5 : 1 }}>
                          <span style={{ fontSize: '2.5rem', marginBottom: '0.5rem' }}>{t.icon}</span>
                          <span style={{ fontSize: '1rem', fontWeight: 600, color: C.gold }}>{t.name}</span>
                        </button>
                      ))}
                    </div>
                    {loading && <div style={{ textAlign: 'center', padding: '1.5rem', color: C.accent }}>‚è≥ Waiting for transaction...</div>}
                  </>
                )}
              </>
            )}
            
            {/* Leaderboard - by user ID, sorted by total EXP */}
            {tab === 'leaderboard' && (
              <div style={{ maxWidth: '600px', margin: '0 auto' }}>
                <h2 style={{ textAlign: 'center', marginBottom: '1.5rem', color: C.gold }}>üèÜ Leaderboard (by Total EXP)</h2>
                {lb.length === 0 ? (
                  <p style={{ textAlign: 'center', color: C.muted, padding: '3rem' }}>No records yet</p>
                ) : (
                  <div style={{ maxHeight: '500px', overflowY: 'auto' }}>
                    {lb.map((e, i) => (
                      <div key={e.id || i} style={{ display: 'flex', alignItems: 'center', gap: '1rem', padding: '1rem', background: i === 0 ? `${C.gold}15` : C.bgCard, borderRadius: '10px', marginBottom: '0.5rem', border: i === 0 ? `1px solid ${C.gold}40` : `1px solid ${C.border}` }}>
                        <span style={{ fontWeight: 700, color: i < 3 ? C.gold : C.muted, width: '2rem' }}>#{i + 1}</span>
                        <span style={{ fontSize: '1.5rem' }}>{e.avatar || 'üéÆ'}</span>
                        <div style={{ flex: 1 }}>
                          <div style={{ fontWeight: 600 }}>{e.name || 'Anonymous'}</div>
                          <div style={{ fontSize: '0.75rem', color: C.muted }}>{shortAddr(e.id)}</div>
                        </div>
                        <div style={{ textAlign: 'right' }}>
                          <div style={{ fontWeight: 700, color: C.gold, fontSize: '1.2rem' }}>‚≠ê {e.exp}</div>
                          <div style={{ fontSize: '0.7rem', color: C.muted }}>Total EXP</div>
                        </div>
                      </div>
                    ))}
                  </div>
                )}
              </div>
            )}
            
            {/* History - only current user, time to seconds */}
            {tab === 'history' && (
              <div style={{ maxWidth: '700px', margin: '0 auto' }}>
                <h2 style={{ textAlign: 'center', marginBottom: '1.5rem', color: C.gold }}>üìö Your Game History</h2>
                {!wallet ? (
                  <p style={{ textAlign: 'center', color: C.muted, padding: '3rem' }}>Please connect wallet to view history</p>
                ) : hist.length === 0 ? (
                  <p style={{ textAlign: 'center', color: C.muted, padding: '3rem' }}>No games yet</p>
                ) : (
                  <div style={{ maxHeight: '500px', overflowY: 'auto' }}>
                    {hist.map((g, i) => (
                      <div key={g.id || i} style={{ padding: '1rem', background: C.bgCard, borderRadius: '10px', marginBottom: '0.8rem', border: `1px solid ${C.border}` }}>
                        <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '0.5rem' }}>
                          <span style={{ fontWeight: 600 }}>{THEMES[g.theme]?.icon} {THEMES[g.theme]?.name}</span>
                          <span style={{ fontSize: '0.8rem', color: C.muted }}>{new Date(g.timestamp).toLocaleString()}</span>
                        </div>
                        <div style={{ fontSize: '0.8rem', color: C.muted, marginBottom: '0.5rem' }}>
                          Players: {g.realPlayers || 1} real + {g.aiPlayers || 0} AI | Path: {g.path?.split('').map((c, j) => (
                            <span key={j} style={{ padding: '0.1rem 0.4rem', margin: '0 0.2rem', background: c === 'A' ? `${C.optA}30` : `${C.optB}30`, borderRadius: '4px', color: c === 'A' ? C.optA : C.optB }}>{c}</span>
                          ))}
                        </div>
                        <div style={{ fontSize: '0.85rem', color: C.goldLight, fontStyle: 'italic' }}>{g.ending}</div>
                      </div>
                    ))}
                  </div>
                )}
              </div>
            )}
          </div>
        </div>
      );

      // ROOM VIEW
      if (view === 'room') {
        const age = roomData ? Math.floor((Date.now() - roomData.createdAt) / 1000) : 0;
        return (
          <div style={{ minHeight: '100vh', background: C.bg, color: C.text }}>
            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', padding: '1rem 2rem', borderBottom: `1px solid ${C.border}`, background: C.bgLight }}>
              <button onClick={reset} style={{ padding: '0.5rem 1rem', background: 'transparent', border: `1px solid ${C.border}`, borderRadius: '8px', color: C.muted, cursor: 'pointer' }}>‚Üê Back</button>
              <div><span style={{ fontSize: '1.5rem', marginRight: '0.5rem' }}>{theme?.icon}</span><span style={{ fontWeight: 600, color: C.gold }}>{theme?.name}</span></div>
              <span style={{ color: C.muted, fontSize: '0.9rem' }}>{player.avatar} {player.name} ‚Ä¢ ‚≠ê{player.exp}</span>
            </div>
            <div style={{ maxWidth: '600px', margin: '0 auto', padding: '2rem' }}>
              <div style={{ textAlign: 'center', marginBottom: '2rem' }}><span style={{ fontSize: '4rem' }}>{theme?.icon}</span><h2 style={{ color: C.gold, marginTop: '0.5rem' }}>{theme?.name}</h2><p style={{ color: C.muted }}>{age}s</p></div>
              {age > 60 && <div style={{ textAlign: 'center', marginBottom: '1rem', padding: '0.8rem', background: `${C.accent}15`, borderRadius: '8px', color: C.accent }}>‚è∞ Over 1 min, AI will auto-join</div>}
              <h3 style={{ color: C.muted, marginBottom: '1rem' }}>Players ({players.length}/{CONFIG.ROOM_SIZE.max})</h3>
              <div style={{ display: 'grid', gridTemplateColumns: 'repeat(4, 1fr)', gap: '1rem', marginBottom: '2rem' }}>
                {players.map(p => (
                  <div key={p.id} style={{ display: 'flex', flexDirection: 'column', alignItems: 'center', padding: '1rem', background: p.id === player.id ? `${C.gold}15` : C.bgCard, border: `1px solid ${p.id === player.id ? C.gold : C.border}`, borderRadius: '10px', position: 'relative' }}>
                    <span style={{ fontSize: '2rem', marginBottom: '0.3rem' }}>{p.avatar}</span>
                    <span style={{ fontSize: '0.85rem' }}>{p.name}</span>
                    {p.isAI && <span style={{ position: 'absolute', top: '0.3rem', left: '0.3rem', fontSize: '0.5rem', padding: '0.1rem 0.3rem', background: C.optB, borderRadius: '3px' }}>AI</span>}
                    {p.id === roomData?.host && <span style={{ position: 'absolute', top: '0.3rem', right: '0.3rem', fontSize: '0.5rem', padding: '0.1rem 0.3rem', background: C.gold, color: '#000', borderRadius: '3px' }}>Host</span>}
                  </div>
                ))}
              </div>
              {player.id === roomData?.host && (
                <>
                  <button onClick={startGame} disabled={players.length < CONFIG.ROOM_SIZE.min} style={{ width: '100%', padding: '1rem', fontSize: '1.1rem', fontWeight: 600, border: 'none', borderRadius: '10px', cursor: players.length >= CONFIG.ROOM_SIZE.min ? 'pointer' : 'not-allowed', background: players.length >= CONFIG.ROOM_SIZE.min ? `linear-gradient(135deg, ${C.gold}, ${C.goldDark})` : C.bgCard, color: players.length >= CONFIG.ROOM_SIZE.min ? '#000' : C.muted, marginBottom: '1rem' }}>
                    {players.length >= CONFIG.ROOM_SIZE.min ? 'üéÆ Start Game' : `Waiting (${players.length}/${CONFIG.ROOM_SIZE.min})`}
                  </button>
                  <button onClick={addAI} style={{ width: '100%', padding: '0.8rem', border: `1px solid ${C.optB}50`, borderRadius: '10px', background: 'transparent', color: C.optB, cursor: 'pointer' }}>ü§ñ Add AI Players</button>
                </>
              )}
            </div>
          </div>
        );
      }

      // GAME VIEW
      return (
        <div style={{ minHeight: '100vh', background: C.bg, display: 'flex', flexDirection: 'column', color: C.text }}>
          <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', padding: '0.8rem 2rem', background: C.bgLight, borderBottom: `1px solid ${C.border}` }}>
            <button onClick={reset} style={{ padding: '0.4rem 0.8rem', background: 'transparent', border: `1px solid ${C.border}`, borderRadius: '6px', color: C.muted, cursor: 'pointer', fontSize: '0.8rem' }}>‚Üê Exit</button>
            <div><div style={{ fontSize: '0.8rem', color: C.muted, textAlign: 'center' }}>Round {game?.round || 1}/{CONFIG.TOTAL_ROUNDS}</div><div style={{ fontWeight: 600, color: C.gold, textAlign: 'center' }}>{game?.phase === 'debate' && 'üí¨ Debate'}{game?.phase === 'vote' && 'üó≥Ô∏è Vote'}{game?.phase === 'ended' && 'üèÜ Ended'}</div></div>
            <div style={{ fontSize: '2rem', fontWeight: 700, fontFamily: 'monospace', color: timer <= 10 && game?.phase !== 'ended' ? C.error : C.gold }}>{game?.phase === 'ended' ? '--:--' : fmtTime(timer)}</div>
            <div style={{ textAlign: 'right' }}><div style={{ fontSize: '0.8rem', color: C.muted }}>Score</div><div style={{ fontSize: '1.3rem', fontWeight: 700, color: C.accent }}>{(game?.scores?.[player.id]?.influence || 0) + (game?.scores?.[player.id]?.debates || 0)}</div></div>
          </div>
          
          <div style={{ flex: 1, display: 'flex', gap: '1rem', padding: '1rem', overflow: 'hidden' }}>
            {/* Left: Story */}
            <div style={{ flex: 1, display: 'flex', flexDirection: 'column', gap: '1rem', minWidth: 0 }}>
              <div style={{ height: '300px', background: C.bgCard, borderRadius: '10px', padding: '1rem', overflowY: 'auto', border: `1px solid ${C.border}` }}>
                <h3 style={{ color: C.gold, marginBottom: '1rem', fontSize: '0.95rem' }}>üìú {theme?.name}</h3>
                {(game?.story || []).map((s, i) => (
                  <div key={i} style={{ padding: '0.5rem 0', borderBottom: i < (game?.story?.length || 0) - 1 ? `1px solid ${C.border}20` : 'none' }}>
                    {s.type === 'opening' && <p style={{ color: C.goldLight, fontStyle: 'italic', lineHeight: 1.6 }}>{s.text}</p>}
                    {s.type === 'context' && <p style={{ color: C.accent, lineHeight: 1.6 }}><span style={{ background: `${C.accent}20`, padding: '0.15rem 0.4rem', borderRadius: '4px', marginRight: '0.4rem', fontSize: '0.8rem' }}>Round {s.round}</span>{s.text}</p>}
                    {s.type === 'choice' && <p style={{ color: C.success, lineHeight: 1.6 }}>{s.winner === 'A' ? 'üÖ∞Ô∏è' : 'üÖ±Ô∏è'} {s.text}</p>}
                    {s.type === 'consequence' && <p style={{ color: C.muted, lineHeight: 1.6, paddingLeft: '1rem', borderLeft: `2px solid ${C.gold}30` }}>{s.text}</p>}
                    {s.type === 'ending' && <p style={{ color: C.gold, lineHeight: 1.6, padding: '0.5rem', background: `${C.gold}10`, borderRadius: '8px' }}>üé¨ {s.text}</p>}
                  </div>
                ))}
              </div>
              
              {/* Options */}
              {(game?.phase === 'debate' || game?.phase === 'vote') && opts.a && (
                <div style={{ background: C.bgCard, borderRadius: '10px', padding: '1rem', border: `1px solid ${C.border}` }}>
                  <h4 style={{ textAlign: 'center', marginBottom: '0.8rem', color: C.gold }}>‚öîÔ∏è Choose</h4>
                  <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '1rem' }}>
                    {[{ k: 'A', o: opts.a, c: C.optA }, { k: 'B', o: opts.b, c: C.optB }].map(({ k, o, c }) => (
                      <div key={k} onClick={() => game?.phase === 'vote' && vote(k)} style={{ padding: '1rem', borderRadius: '8px', border: `2px solid ${myVote === k ? c : `${c}40`}`, background: `${c}10`, cursor: game?.phase === 'vote' && !myVote ? 'pointer' : 'default', opacity: myVote && myVote !== k ? 0.5 : 1 }}>
                        <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '0.5rem' }}><span style={{ fontWeight: 700, color: c }}>Option {k}</span><span style={{ fontSize: '0.7rem', padding: '0.1rem 0.4rem', background: `${c}20`, borderRadius: '4px', color: c }}>{o?.tag}</span></div>
                        <p style={{ lineHeight: 1.4, fontSize: '0.85rem' }}>{o?.text}</p>
                        {game?.phase === 'vote' && <div style={{ marginTop: '0.6rem', textAlign: 'center', fontSize: '1.1rem', fontWeight: 600, color: C.gold }}>{Object.values(votes).filter(v => v === k).length} votes</div>}
                        {myVote === k && <div style={{ textAlign: 'center', marginTop: '0.3rem', color: c, fontSize: '0.8rem' }}>‚úì Voted</div>}
                      </div>
                    ))}
                  </div>
                </div>
              )}
              
              {/* Game End */}
              {game?.phase === 'ended' && (
                <div style={{ background: `linear-gradient(145deg, ${C.gold}15, ${C.bgCard})`, borderRadius: '10px', padding: '1.5rem', textAlign: 'center', border: `1px solid ${C.gold}40` }}>
                  <h2 style={{ fontSize: '1.5rem', marginBottom: '1rem', color: C.gold }}>üèÜ Chronicle Complete!</h2>
                  <div style={{ maxWidth: '350px', margin: '0 auto 1rem' }}>
                    {Object.entries(game?.scores || {}).map(([id, sc]) => ({ p: players.find(x => x.id === id), t: (sc.influence || 0) + (sc.debates || 0) })).sort((a, b) => b.t - a.t).map((r, i) => (
                      <div key={r.p?.id || i} style={{ display: 'flex', alignItems: 'center', gap: '0.6rem', padding: '0.6rem', marginBottom: '0.3rem', background: i === 0 ? `${C.gold}20` : C.bgCard, borderRadius: '6px', border: i === 0 ? `1px solid ${C.gold}40` : 'none' }}>
                        <span style={{ fontWeight: 700, color: i < 3 ? C.gold : C.muted }}>#{i + 1}</span>
                        <span>{r.p?.avatar}</span>
                        <span style={{ flex: 1 }}>{r.p?.name}</span>
                        <span style={{ fontWeight: 600, color: C.gold }}>{r.t} pts</span>
                      </div>
                    ))}
                  </div>
                  <button onClick={reset} style={{ padding: '0.6rem 1.5rem', background: `linear-gradient(135deg, ${C.gold}, ${C.goldDark})`, border: 'none', borderRadius: '8px', color: '#000', fontWeight: 600, cursor: 'pointer' }}>Back to Lobby</button>
                </div>
              )}
            </div>
            
            {/* Right: Chat */}
            <div style={{ width: '280px', display: 'flex', flexDirection: 'column', background: C.bgCard, borderRadius: '10px', overflow: 'hidden', border: `1px solid ${C.border}` }}>
              <div style={{ display: 'flex', flexWrap: 'wrap', gap: '0.3rem', padding: '0.6rem', borderBottom: `1px solid ${C.border}` }}>
                {players.map(p => (
                  <div key={p.id} style={{ display: 'flex', alignItems: 'center', gap: '0.2rem', padding: '0.2rem 0.5rem', background: votes[p.id] ? `${C.success}20` : C.bgLight, borderRadius: '12px', fontSize: '0.75rem', border: votes[p.id] ? `1px solid ${C.success}40` : 'none' }}>
                    <span>{p.avatar}</span>
                    <span style={{ maxWidth: '50px', overflow: 'hidden', textOverflow: 'ellipsis', whiteSpace: 'nowrap' }}>{p.name}</span>
                    {votes[p.id] && <span style={{ color: C.success, fontWeight: 700 }}>{votes[p.id]}</span>}
                  </div>
                ))}
              </div>
              
              <div style={{ flex: 1, height: '300px', overflowY: 'auto', padding: '0.6rem' }}>
                {msgs.map((m, i) => (
                  <div key={i} style={{ marginBottom: '0.5rem', fontSize: '0.8rem' }}>
                    {m.type === 'system' ? (
                      <div style={{ color: C.gold, fontStyle: 'italic' }}>{m.text}</div>
                    ) : (
                      <div style={{ background: C.bgLight, borderRadius: '6px', padding: '0.4rem 0.6rem' }}>
                        <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '0.2rem' }}>
                          <span style={{ color: C.accent, fontWeight: 600 }}>{m.sender?.avatar} {m.sender?.name}</span>
                          {m.choice && <span style={{ fontSize: '0.65rem', padding: '0.1rem 0.3rem', background: m.choice === 'A' ? `${C.optA}30` : `${C.optB}30`, borderRadius: '3px', color: m.choice === 'A' ? C.optA : C.optB }}>{m.choice}</span>}
                        </div>
                        <div>{m.text}</div>
                      </div>
                    )}
                  </div>
                ))}
                <div ref={msgsEndRef} />
              </div>
              
              {game?.phase === 'debate' && (
                <div style={{ padding: '0.6rem', borderTop: `1px solid ${C.border}` }}>
                  <div style={{ display: 'flex', gap: '0.4rem', marginBottom: '0.4rem' }}>
                    <input type="text" value={input} onChange={e => setInput(e.target.value)} onKeyDown={e => e.key === 'Enter' && submitDebate()} placeholder="Share your view..." style={{ flex: 1, padding: '0.5rem', background: C.bgLight, border: `1px solid ${C.border}`, borderRadius: '6px', color: C.text, fontSize: '0.8rem', outline: 'none' }} />
                    <button onClick={submitDebate} style={{ padding: '0.5rem 0.8rem', background: `linear-gradient(135deg, ${C.gold}, ${C.goldDark})`, border: 'none', borderRadius: '6px', color: '#000', fontWeight: 600, cursor: 'pointer' }}>Send</button>
                  </div>
                  <div style={{ display: 'flex', gap: '0.3rem' }}>
                    <button onClick={() => setInput('I support A because ')} style={{ padding: '0.2rem 0.5rem', background: `${C.optA}20`, border: `1px solid ${C.optA}30`, borderRadius: '10px', color: C.optA, fontSize: '0.7rem', cursor: 'pointer' }}>üÖ∞Ô∏è A</button>
                    <button onClick={() => setInput('I support B because ')} style={{ padding: '0.2rem 0.5rem', background: `${C.optB}20`, border: `1px solid ${C.optB}30`, borderRadius: '10px', color: C.optB, fontSize: '0.7rem', cursor: 'pointer' }}>üÖ±Ô∏è B</button>
                  </div>
                </div>
              )}
              
              {game?.phase === 'vote' && !myVote && (
                <div style={{ padding: '0.8rem', textAlign: 'center', background: `${C.gold}15` }}>
                  <p style={{ color: C.accent, fontWeight: 600, fontSize: '0.9rem' }}>‚è∞ Please vote on the left!</p>
                </div>
              )}
            </div>
          </div>
        </div>
      );
    }

    ReactDOM.createRoot(document.getElementById('root')).render(<App />);
  </script>
</body>
</html>
