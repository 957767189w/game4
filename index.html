<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Consensus Chronicle</title>
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-database-compat.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: 'Segoe UI', system-ui, sans-serif; background: #0a0a0f; }
    ::-webkit-scrollbar { width: 6px; }
    ::-webkit-scrollbar-track { background: rgba(255,255,255,0.05); }
    ::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.2); border-radius: 3px; }
  </style>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
    const { useState, useEffect, useRef } = React;

    const CONFIG = {
      ROOM_SIZE: { min: 2, max: 8 },
      DEBATE_DURATION: 90,
      VOTE_DURATION: 30,
      TOTAL_ROUNDS: 5,
      ROOM_TIMEOUT_AI: 60000,
      ROOM_TIMEOUT_CLOSE: 120000,
      GENLAYER_CONTRACT: '0x4F5F132ba540f1C685B0188D59990302903aE186',
      FIREBASE: {
        apiKey: "AIzaSyBX4tOb30jWKK6aBUsqERQaOAF4CxCfMmQ",
        authDomain: "consensus-chronicle.firebaseapp.com",
        databaseURL: "https://consensus-chronicle-default-rtdb.firebaseio.com",
        projectId: "consensus-chronicle"
      }
    };

    const THEMES = {
      fantasy: {
        name: 'Fantasy Quest',
        icon: 'üè∞',
        bg: 'linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%)',
        accent: '#a78bfa',
        opening: 'The ancient prophecy has come true‚Äîthe Black Dragon awakens after a thousand years. The kingdom is in peril, and the King summons heroes from across the land...',
        rounds: [
          { context: 'The dragon threatens the kingdom. A critical decision must be made.', a: { text: 'Assemble the army and strike the dragon\'s lair before it fully awakens.', tag: 'Aggressive', consequence: 'The army marches toward the lair but encounters fierce resistance...' }, b: { text: 'Send envoys to seek help from the Elven kingdom who sealed the dragon before.', tag: 'Diplomatic', consequence: 'The elves respond, but they demand a heavy price for their aid...' } },
          { contextA: 'The army suffers losses but reaches the lair. Scouts report: dragon eggs inside.', contextB: 'The elves demand the Holy Sword as proof of trust before helping.', a: { text: 'Destroy the eggs to end the dragon bloodline forever.', tag: 'Ruthless', consequenceFromA: 'The eggs are destroyed. The dragon\'s rage intensifies the battle...', consequenceFromB: 'Refusing the elves, humans face the dragon alone and destroy the eggs...' }, b: { text: 'Preserve the eggs for negotiation or to raise a friendly dragon.', tag: 'Merciful', consequenceFromA: 'The eggs are hidden, but word spreads causing internal conflict...', consequenceFromB: 'Trading the sword for elven aid while protecting the eggs...' } },
          { contextAA: 'The enraged dragon unleashes devastating power. The army faces annihilation.', contextAB: 'Internal division weakens morale. Some want to surrender.', contextBA: 'Without elven magic, the human army struggles in battle.', contextBB: 'Elven forces arrive but threaten to leave over the eggs\' existence.', a: { text: 'Use forbidden magic, sacrificing the caster to wound the dragon.', tag: 'Sacrifice', consequence: 'The forbidden spell works. The dragon falls wounded, but at great cost...' }, b: { text: 'Order retreat to preserve strength for another day.', tag: 'Strategic', consequence: 'The army retreats safely, but the dragon destroys several villages...' } },
          { contextA: 'The wounded dragon retreats to heal. Death lingers over the land.', contextB: 'After retreat, the kingdom reflects. Various factions emerge.', a: { text: 'Launch a final assault while the dragon heals.', tag: 'Decisive', consequence: 'The final battle begins‚Äîthe kingdom\'s fate hangs in the balance...' }, b: { text: 'Attempt to communicate with the wounded dragon for peace.', tag: 'Idealistic', consequence: 'An envoy approaches the dragon. Surprisingly, it agrees to talk...' } },
          { contextA: 'In the final battle, both sides suffer greatly. Victory is within reach.', contextB: 'The dragon reveals it awakened due to a greater threat‚Äîa demon from the abyss.', a: { text: 'Destroy the dragon at any cost, even if the kingdom burns.', tag: 'Absolute', ending: 'victory_total' }, b: { text: 'Accept fate and forge an alliance with the dragon against the true enemy.', tag: 'Unity', ending: 'alliance' } }
        ],
        endings: {
          victory_total: 'The Black Dragon falls, but the kingdom lies in ruins. Survivors begin the long road to rebuilding. History will remember this pyrrhic victory‚Äîa testament to human determination, and a warning about the cost of absolute choices.',
          alliance: 'Humans and the dragon forge an unprecedented alliance to guard the realm together. A new era of cooperation begins. The old prophecy was wrong‚Äîdragons and humans can coexist, and together they stand stronger than apart.',
          default: 'The kingdom endures through courage and sacrifice. Songs of these heroes will echo through the ages, reminding future generations that consensus shapes destiny.'
        }
      },
      scifi: {
        name: 'Stellar Exodus',
        icon: 'üöÄ',
        bg: 'linear-gradient(135deg, #0f0f1a 0%, #1a0a2e 50%, #0a1628 100%)',
        accent: '#06b6d4',
        opening: 'Year 2157. Mars Colony "New Hope" receives a mysterious signal from deep space. Scientists decode it: a warning‚ÄîEarth will be struck by an asteroid in 100 days. But resources can only save half the population...',
        rounds: [
          { context: 'Panic spreads through the colony. Leadership must decide immediately.', a: { text: 'Initiate "Ark Protocol"‚Äîuse lottery to select who boards escape ships.', tag: 'Fair', consequence: 'Lottery results spark protests. Security forces must intervene...' }, b: { text: 'Focus all resources on tracing the signal source. Perhaps salvation lies there.', tag: 'Hopeful', consequence: 'The signal leads to an alien civilization extending an invitation...' } },
          { contextA: 'Protests turn violent. Rioters seize the launch area.', contextB: 'The aliens invite humanity to a distant galaxy, but the journey takes 500 years.', a: { text: 'Authorize security to use force to ensure Ark Protocol proceeds.', tag: 'Order', consequenceFromA: 'The riot is suppressed with casualties. Survivors harbor resentment...', consequenceFromB: 'Abandoning alien contact, focusing on current escape plans...' }, b: { text: 'Negotiate with protesters to modify the plan for more survivors.', tag: 'Humane', consequenceFromA: 'Engineers propose overloading ships‚Äîrisky but saves more lives...', consequenceFromB: 'Sending pioneers to answer the invitation while others enter cryosleep...' } },
          { contextAA: 'Overloading drops success rate from 95% to 60%, but saves 30% more people.', contextAB: 'Pioneers lose contact. Remaining resources last only 60 days.', contextBA: 'Radicals reject negotiation results, plotting sabotage.', contextBB: 'Cryosleep technology is imperfect‚Äî30% failure rate.', a: { text: 'Accept overload plan‚Äî60% success for more hope.', tag: 'Gamble', consequence: 'The overload plan begins. Everyone prays for a miracle...' }, b: { text: 'Maintain original plan‚Äîensure at least half survive for certain.', tag: 'Pragmatic', consequence: 'Original plan continues, but social fractures deepen...' } },
          { contextA: 'Before launch, AI detects a possibility: the asteroid\'s trajectory can be altered.', contextB: 'During launch prep, pioneers suddenly report: aliens can destroy the asteroid if humans disarm.', a: { text: 'Attempt to alter the asteroid\'s path‚Äîworth trying even if it fails.', tag: 'Heroic', consequence: 'All colony energy focuses on this bold plan...' }, b: { text: 'Proceed with evacuation‚Äîdon\'t put all eggs in one basket.', tag: 'Cautious', consequence: 'Ships begin evacuation while those remaining don\'t give up hope...' } },
          { contextA: '80% of energy spent. Asteroid shifted but not enough‚Äîit will still graze Earth.', contextB: 'Alien tech works, but they demand humanity destroys all nuclear weapons first.', a: { text: 'Use remaining energy for one final push. All or nothing.', tag: 'Ultimate', ending: 'miracle' }, b: { text: 'Accept partial loss, begin post-disaster rebuilding. Humanity will rise again.', tag: 'Resilient', ending: 'rebuild' } }
        ],
        endings: {
          miracle: 'A miracle occurs! The asteroid veers away at the last moment. Humanity\'s courage and unity conquered fate. This day is forever remembered as "New Hope Day"‚Äîproof that when humanity stands together, even the stars bend to their will.',
          rebuild: 'The asteroid grazes Earth, causing severe but not extinction-level damage. Survivors begin difficult rebuilding, knowing that while humanity endures, hope endures. From the ashes, a stronger civilization emerges.',
          default: 'Against impossible odds, humanity finds a way to survive. The stars await their children, and the journey continues.'
        }
      },
      mystery: {
        name: 'Murder Manor',
        icon: 'üîç',
        bg: 'linear-gradient(135deg, #1a1a1a 0%, #2d1f1f 50%, #1a1a2e 100%)',
        accent: '#f59e0b',
        opening: 'A stormy night. Wealthy Mr. Chen is found poisoned in his study‚Äîdoor locked from inside, windows intact. Present: eldest son Ming, daughter Yue, butler Zhang, maid Fang, and mysterious businessman Mr. Li. Everyone has secrets...',
        rounds: [
          { context: 'Police seal the mansion. As the invited detective, you must begin.', a: { text: 'Search the victim\'s study first for physical evidence.', tag: 'Methodical', consequence: 'You find a half-burned letter mentioning "betrayal" and "inheritance"...' }, b: { text: 'Interview each person present, observing reactions.', tag: 'Intuitive', consequence: 'Butler Zhang seems nervous. Yue mentions her father received threats recently...' } },
          { contextA: 'The letter reveals Mr. Chen planned to change his will, disinheriting someone.', contextB: 'The threats came from a mysterious organization. Mr. Li seems connected to it.', a: { text: 'Investigate the inheritance angle‚Äîfollow the money.', tag: 'Financial', consequenceFromA: 'Ming has massive gambling debts. Yue secretly funds a charity...', consequenceFromB: 'Mr. Chen recently transferred large assets to an unknown destination...' }, b: { text: 'Investigate Mr. Li\'s background‚Äîhis timing is too convenient.', tag: 'Suspicious', consequenceFromA: 'Mr. Li is revealed to be Mr. Chen\'s long-lost illegitimate son...', consequenceFromB: 'Mr. Li admits he came for business but brought a shocking secret...' } },
          { contextAA: 'Ming has motive, but maid Fang provides his alibi.', contextAB: 'Asset destination is an encrypted offshore account.', contextBA: 'The illegitimate son means inheritance redistribution‚Äîeveryone now has motive.', contextBB: 'Mr. Li reveals Mr. Chen was investigating an old case‚Äîa covered-up murder.', a: { text: 'Verify Fang\'s testimony‚Äîshe could be key witness or accomplice.', tag: 'Thorough', consequence: 'Under pressure, Fang breaks down‚ÄîMing threatened her to lie...' }, b: { text: 'Investigate the old case‚Äîpast secrets may reveal present truth.', tag: 'Patient', consequence: 'The old case points to a fire 20 years ago where Mr. Chen\'s first wife died...' } },
          { contextA: 'False alibi exposed. Ming has no defense but accuses Yue instead.', contextB: 'The fire was arson, not accident. Mr. Chen may have known the culprit.', a: { text: 'Cross-examine Ming and Yue to find who\'s lying.', tag: 'Direct', consequence: 'A bombshell: Yue is not Mr. Chen\'s biological daughter...' }, b: { text: 'Re-examine the poison source‚Äîthe weapon often points to the killer.', tag: 'Scientific', consequence: 'The poison comes from a rare plant‚Äîgrowing in butler Zhang\'s room...' } },
          { contextA: 'Yue\'s true identity emerges: daughter of someone who "died" in that fire, secretly adopted.', contextB: 'All evidence points to Zhang, but he has a heart attack during questioning, whispering: "Truth... under the old oak..."', a: { text: 'Reveal all truth and let the law decide, whatever the outcome.', tag: 'Justice', ending: 'justice' }, b: { text: 'Give those involved a choice‚Äîsome truths perhaps shouldn\'t be public.', tag: 'Mercy', ending: 'mercy' } }
        ],
        endings: {
          justice: 'Truth revealed: Zhang was the lover of Mr. Chen\'s first wife. They planned the fire together. When Mr. Chen discovered this, Zhang silenced him permanently. Yue, learning her origins, chose forgiveness and used her inheritance to help children like herself. Justice prevails, though its path was dark.',
          mercy: 'A compromise: Zhang\'s crime is handled quietly. Ming overcomes his addiction, Yue continues her charity, Mr. Li leaves with his father\'s keepsakes. Some truths remain buried, but the living find new beginnings. Sometimes mercy serves justice better than punishment.',
          default: 'The mystery is solved, the guilty are found. The manor\'s secrets are finally laid to rest, and those who remain must learn to live with the truth.'
        }
      },
      political: {
        name: 'Throne of Shadows',
        icon: 'üëë',
        bg: 'linear-gradient(135deg, #1a1a0f 0%, #2e2e1a 50%, #1a1a2e 100%)',
        accent: '#eab308',
        opening: 'The Great Qi Dynasty, Year 30 of Eternal Peace. The old Emperor\'s death shocks the realm. His will is puzzling: the throne goes not to any of three adult princes, but to "whoever best represents the people\'s will." The court descends into intrigue...',
        rounds: [
          { context: 'As the trusted Grand Chancellor, you must maintain order. Three princes compete: Crown Prince‚Äîkind but weak, Second Prince‚Äîclever but cruel, Third Prince‚Äîyoung but reform-minded.', a: { text: 'Support the Crown Prince by tradition, maintaining succession stability.', tag: 'Traditional', consequence: 'Crown Prince gains confidence, but Second Prince\'s faction contacts the military...' }, b: { text: 'Propose all princes present governance plans for court deliberation.', tag: 'Progressive', consequence: 'The proposal causes uproar‚Äîreformists cheer, conservatives oppose...' } },
          { contextA: 'Second Prince conspires with border generals to "cleanse the court."', contextB: 'Before deliberation, someone accuses Third Prince of secret dealings with foreign envoys‚Äîtreason.', a: { text: 'Mobilize the Imperial Guard and send agents to break Second Prince\'s alliance.', tag: 'Strategic', consequenceFromA: 'Your tactics delay Second Prince, but he suspects internal betrayal...', consequenceFromB: 'You use this to suppress Third Prince, but the accusation may be forged...' }, b: { text: 'Meet Second Prince personally, understand his demands, seek peaceful resolution.', tag: 'Diplomatic', consequenceFromA: 'Second Prince offers terms: the throne for himself, but promises to spare his brothers...', consequenceFromB: 'The accusation puts Third Prince in crisis. You investigate the truth...' } },
          { contextAA: 'Alliance broken, but the defector demands to be made Prime Minister.', contextAB: 'Investigation shows the accusation came from the Empress Dowager\'s people‚Äîto install her nephew.', contextBA: 'Second Prince\'s terms are hard to accept, but he commands armies. Refusal means civil war.', contextBB: 'Empress Dowager publicly demands "regency" as the late Emperor\'s widow.', a: { text: 'Accept the terms‚Äîlesser of two evils to stabilize the situation.', tag: 'Pragmatic', consequence: 'Temporary stability, but you know this is just the beginning...' }, b: { text: 'Expose Empress Dowager\'s plot, unite all princes against external interference.', tag: 'Righteous', consequence: 'Your revelation shocks the court. The three princes stand together for the first time...' } },
          { contextA: 'Powers balance temporarily, but succession remains unresolved. Then urgent news: northern nomads mass at the border.', contextB: 'Empress Dowager confined, her faction crumbles. But in her chambers, another will from the late Emperor is found...', a: { text: 'Propose all princes lead armies north‚Äîwhoever defeats the enemy becomes Emperor.', tag: 'Meritocratic', consequence: 'Three princes march north. This war will decide the dynasty\'s future...' }, b: { text: 'Propose selecting the Emperor first, then facing the enemy. A nation needs its ruler.', tag: 'Orderly', consequence: 'Under your guidance, a decisive court session begins...' } },
          { contextA: 'War stalemated. Crown Prince wins hearts, Second Prince fights bravely, Third Prince manages logistics brilliantly. All have merit.', contextB: 'The true will is found: the throne goes to "whoever can make the three sons live in harmony." That person... is you.', a: { text: 'Propose joint rule by all three princes‚Äîestablish a new "Three Kings Council."', tag: 'Revolutionary', ending: 'council' }, b: { text: 'Rank by military merit‚Äîthe greatest contributor inherits the throne.', tag: 'Merit', ending: 'merit' } }
        ],
        endings: {
          council: 'The Great Qi enters an unprecedented "Era of Three Kings." Crown Prince handles domestic affairs, Second Prince commands military, Third Prince leads reforms. Though disputes continue, under your mediation, the system works. Twenty years later, you write: "The best system isn\'t perfect‚Äîit\'s one that can correct itself." Your wisdom becomes legend.',
          merit: 'Second Prince claims the throne by military merit, but doesn\'t disappoint. His reign defeats the nomads and reforms governance, bringing the dynasty\'s renaissance. When you retire at seventy, the Emperor personally escorts you ten miles, saying: "Without you, Grand Chancellor, there would be no Great Qi today." Your name echoes through history.',
          default: 'Through wisdom and patience, the kingdom finds its way to a new era of prosperity and peace. The throne is secured, and the people prosper.'
        }
      }
    };

    const AI_PLAYERS = [
      { id: 'ai_1', name: 'Sage Iris', avatar: 'üßô‚Äç‚ôÄÔ∏è', exp: 1200, isAI: true, style: 'analytical' },
      { id: 'ai_2', name: 'Knight Kane', avatar: '‚öîÔ∏è', exp: 1100, isAI: true, style: 'bold' },
      { id: 'ai_3', name: 'Scholar Noah', avatar: 'üìö', exp: 1300, isAI: true, style: 'cautious' },
      { id: 'ai_4', name: 'Merchant Marco', avatar: 'üí∞', exp: 1150, isAI: true, style: 'pragmatic' },
      { id: 'ai_5', name: 'Bard Luna', avatar: 'üé≠', exp: 1050, isAI: true, style: 'romantic' },
    ];

    const generateAIDebate = (style) => {
      const debates = {
        analytical: { A: ['Logically, Option A has higher success rate.', 'Data suggests decisive action works better.'], B: ['Analysis shows B has better long-term benefits.', 'Considering all factors, B is more prudent.'] },
        bold: { A: ['Fortune favors the bold! A is the hero\'s choice!', 'Strike now! I support A!'], B: ['True courage is choosing B against the tide!', 'A wise warrior picks B!'] },
        cautious: { A: ['Risky, but A might be necessary.', 'Lesser of two evils‚ÄîI support A.'], B: ['Caution advises B is safer.', 'Live to fight another day‚Äîchoose B.'] },
        pragmatic: { A: ['From profit perspective, A returns more.', 'My merchant instinct says A.'], B: ['B offers more controllable risk.', 'Long-term, B yields steadier gains.'] },
        romantic: { A: ['A has a tragic beauty to it.', 'Fate\'s epic needs A\'s turning point.'], B: ['B represents hope and possibility.', 'B is the most moving answer.'] },
      };
      const choice = Math.random() > 0.5 ? 'A' : 'B';
      const options = debates[style]?.[choice] || debates.analytical[choice];
      return { text: options[Math.floor(Math.random() * options.length)], choice };
    };

    function App() {
      const [db, setDb] = useState(null);
      const [walletAddress, setWalletAddress] = useState(null);
      const [walletConnecting, setWalletConnecting] = useState(false);
      const [activeTab, setActiveTab] = useState('game');
      const [view, setView] = useState('home');
      const [player, setPlayer] = useState({ id: '', name: '', avatar: 'üéÆ', exp: 1000 });
      const [roomId, setRoomId] = useState(null);
      const [roomData, setRoomData] = useState(null);
      const [players, setPlayers] = useState([]);
      const [gameState, setGameState] = useState(null);
      const [messages, setMessages] = useState([]);
      const [availableRooms, setAvailableRooms] = useState([]);
      const [debateInput, setDebateInput] = useState('');
      const [myVote, setMyVote] = useState(null);
      const [timer, setTimer] = useState(0);
      const [leaderboard, setLeaderboard] = useState([]);
      const [gameHistory, setGameHistory] = useState([]);
      const [loading, setLoading] = useState(false);
      const timerRef = useRef(null);
      const messagesEndRef = useRef(null);
      const roomCheckRef = useRef(null);

      useEffect(() => {
        try {
          if (!firebase.apps.length) firebase.initializeApp(CONFIG.FIREBASE);
          setDb(firebase.database());
        } catch (err) { console.error('Firebase init error:', err); }
        try {
          const savedLb = localStorage.getItem('cc_leaderboard');
          if (savedLb) setLeaderboard(JSON.parse(savedLb));
          const savedHist = localStorage.getItem('cc_history');
          if (savedHist) setGameHistory(JSON.parse(savedHist));
        } catch {}
        return () => {
          if (timerRef.current) clearInterval(timerRef.current);
          if (roomCheckRef.current) clearInterval(roomCheckRef.current);
        };
      }, []);

      useEffect(() => {
        if (!db) return;
        db.ref('rooms').on('value', (snapshot) => {
          const data = snapshot.val();
          const now = Date.now();
          if (data) {
            const rooms = [];
            Object.entries(data).forEach(([id, room]) => {
              const age = now - room.createdAt;
              if (room.status === 'waiting' && age > CONFIG.ROOM_TIMEOUT_CLOSE) {
                db.ref(`rooms/${id}`).update({ status: 'closed' });
                return;
              }
              if (room.status === 'waiting') rooms.push({ id, ...room, age });
            });
            setAvailableRooms(rooms);
          } else setAvailableRooms([]);
        });
      }, [db]);

      useEffect(() => {
        if (!db || !roomId) return;
        const roomRef = db.ref(`rooms/${roomId}`);
        const gameRef = db.ref(`games/${roomId}`);
        roomRef.on('value', (s) => {
          const d = s.val();
          if (d) { setRoomData(d); if (d.players) setPlayers(Object.values(d.players)); if (d.status === 'closed') { alert('Room closed'); resetGame(); } }
        });
        gameRef.on('value', (s) => {
          const d = s.val();
          if (d) { setGameState(d); if (d.messages) setMessages(Object.values(d.messages).sort((a, b) => a.timestamp - b.timestamp)); if (d.timerEnd && d.phase !== 'ended') setTimer(Math.max(0, Math.floor((d.timerEnd - Date.now()) / 1000))); }
        });
        return () => { roomRef.off(); gameRef.off(); };
      }, [db, roomId]);

      useEffect(() => {
        if (!db || !roomId || !roomData || roomData.status !== 'waiting') return;
        if (roomCheckRef.current) clearInterval(roomCheckRef.current);
        roomCheckRef.current = setInterval(() => {
          const age = Date.now() - roomData.createdAt;
          const playerCount = Object.keys(roomData.players || {}).filter(id => !id.startsWith('ai_')).length;
          if (age > CONFIG.ROOM_TIMEOUT_AI && playerCount === 1 && player.id === roomData.host) {
            const currentIds = Object.keys(roomData.players || {});
            AI_PLAYERS.filter(ai => !currentIds.includes(ai.id)).slice(0, CONFIG.ROOM_SIZE.min - 1).forEach((ai, i) => {
              setTimeout(() => { db.ref(`rooms/${roomId}/players/${ai.id}`).set(ai); addMessage('system', `${ai.avatar} ${ai.name} joined`); }, i * 1000);
            });
          }
        }, 5000);
        return () => { if (roomCheckRef.current) clearInterval(roomCheckRef.current); };
      }, [db, roomId, roomData, player.id]);

      useEffect(() => {
        if (!gameState?.timerEnd || gameState?.phase === 'ended') return;
        if (timerRef.current) clearInterval(timerRef.current);
        timerRef.current = setInterval(() => {
          const remaining = Math.max(0, Math.floor((gameState.timerEnd - Date.now()) / 1000));
          setTimer(remaining);
          if (remaining <= 0 && player.id === roomData?.host) handlePhaseEnd();
        }, 1000);
        return () => { if (timerRef.current) clearInterval(timerRef.current); };
      }, [gameState?.timerEnd, gameState?.phase]);

      useEffect(() => { messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' }); }, [messages]);

      const connectWallet = async () => {
        if (!window.ethereum) { alert('Please install MetaMask'); return null; }
        setWalletConnecting(true);
        try {
          const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
          setWalletAddress(accounts[0]);
          setPlayer(p => ({ ...p, id: accounts[0] }));
          return accounts[0];
        } catch (err) { alert('Wallet connection failed'); return null; }
        finally { setWalletConnecting(false); }
      };

      const payEntryFee = async (address) => {
        if (!window.ethereum) { alert('Please install MetaMask'); return false; }
        setLoading(true);
        try {
          const nonce = Date.now().toString(16) + Math.random().toString(16).slice(2, 10);
          await window.ethereum.request({
            method: 'eth_sendTransaction',
            params: [{ from: address, to: CONFIG.GENLAYER_CONTRACT, value: '0x0', data: '0x' + nonce.padStart(64, '0') }]
          });
          return true;
        } catch (err) { if (err.code !== 4001) alert('Transaction failed: ' + err.message); return false; }
        finally { setLoading(false); }
      };

      const recordGame = async () => {
        if (!walletAddress || !window.ethereum) return;
        try {
          const nonce = Date.now().toString(16) + Math.random().toString(16).slice(2, 10);
          await window.ethereum.request({ method: 'eth_sendTransaction', params: [{ from: walletAddress, to: CONFIG.GENLAYER_CONTRACT, value: '0x0', data: '0x' + nonce.padStart(64, '0') }] });
        } catch (err) { console.error('Record error:', err); }
      };

      const createRoom = async (theme) => {
        if (!db || !player.name) return;
        let address = walletAddress;
        if (!address) { address = await connectWallet(); if (!address) return; }
        const paid = await payEntryFee(address);
        if (!paid) return;
        const newRoomId = `room_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        await db.ref(`rooms/${newRoomId}`).set({ theme, host: address, status: 'waiting', createdAt: Date.now(), players: { [address]: { id: address, name: player.name, avatar: player.avatar, exp: player.exp, isAI: false } } });
        setRoomId(newRoomId);
        setView('room');
        addMessage('system', 'Room created. Waiting for players...');
      };

      const joinRoom = async (targetRoomId) => {
        if (!db || !player.name) return;
        let address = walletAddress;
        if (!address) { address = await connectWallet(); if (!address) return; }
        const paid = await payEntryFee(address);
        if (!paid) return;
        await db.ref(`rooms/${targetRoomId}/players/${address}`).set({ id: address, name: player.name, avatar: player.avatar, exp: player.exp, isAI: false });
        setRoomId(targetRoomId);
        setView('room');
      };

      const addAIPlayers = async () => {
        if (!db || !roomId) return;
        const currentIds = Object.keys(roomData?.players || {});
        const available = AI_PLAYERS.filter(ai => !currentIds.includes(ai.id)).sort(() => Math.random() - 0.5);
        for (let i = 0; i < Math.min(3, CONFIG.ROOM_SIZE.max - currentIds.length); i++) {
          await new Promise(r => setTimeout(r, 800));
          await db.ref(`rooms/${roomId}/players/${available[i].id}`).set(available[i]);
          addMessage('system', `${available[i].avatar} ${available[i].name} joined`);
        }
      };

      const startGame = async () => {
        if (!db || !roomId || players.length < CONFIG.ROOM_SIZE.min) return;
        await db.ref(`rooms/${roomId}`).update({ status: 'playing' });
        const theme = roomData?.theme || 'fantasy';
        const arc = THEMES[theme];
        const initScores = {};
        players.forEach(p => { initScores[p.id] = { influence: 0, debates: 0, wins: 0 }; });
        await db.ref(`games/${roomId}`).set({ round: 1, phase: 'debate', path: [], scores: initScores, votes: {}, story: [{ text: arc.opening, type: 'opening', round: 0 }], timerEnd: Date.now() + CONFIG.DEBATE_DURATION * 1000, messages: {} });
        setView('game');
        addMessage('system', `üìñ ${arc.name} begins! Round 1/${CONFIG.TOTAL_ROUNDS} - Debate`);
        setTimeout(() => simulateAIDebate(), 3000);
      };

      const simulateAIDebate = () => {
        players.filter(p => p.isAI).forEach((ai, i) => {
          setTimeout(() => { const d = generateAIDebate(ai.style); addMessage('chat', d.text, ai, d.choice); }, (i + 1) * 3000 + Math.random() * 5000);
        });
      };

      const handlePhaseEnd = async () => {
        if (!db || !roomId || !gameState) return;
        if (gameState.phase === 'debate') {
          await db.ref(`games/${roomId}`).update({ phase: 'vote', timerEnd: Date.now() + CONFIG.VOTE_DURATION * 1000, votes: {} });
          addMessage('system', 'üó≥Ô∏è Voting begins!');
          setMyVote(null);
          players.filter(p => p.isAI).forEach((ai, i) => { setTimeout(async () => { await db.ref(`games/${roomId}/votes/${ai.id}`).set(Math.random() > 0.5 ? 'A' : 'B'); }, (i + 1) * 2000); });
        } else if (gameState.phase === 'vote') await calculateResult();
      };

      const calculateResult = async () => {
        if (!db || !roomId || !gameState) return;
        const votes = gameState.votes || {};
        const voteCount = { A: 0, B: 0 };
        Object.values(votes).forEach(v => { if (v) voteCount[v]++; });
        const winner = voteCount.A >= voteCount.B ? 'A' : 'B';
        const newScores = { ...gameState.scores };
        Object.entries(votes).forEach(([id, v]) => { if (v === winner && newScores[id]) { newScores[id].influence = (newScores[id].influence || 0) + 30; newScores[id].wins = (newScores[id].wins || 0) + 1; } });
        const newPath = [...(gameState.path || []), winner];
        const round = gameState.round;
        const consequence = getConsequence(round, winner, gameState.path || []);
        const winOpt = getOption(round, winner);
        const newStory = [...(gameState.story || []), { text: `[Chosen] ${winOpt?.text}`, type: 'choice', round, winner }, { text: consequence, type: 'consequence', round }];
        addMessage('system', `üìú Option ${winner} wins! (${voteCount[winner]} vs ${voteCount[winner === 'A' ? 'B' : 'A']})`);
        
        if (round >= CONFIG.TOTAL_ROUNDS) {
          const theme = roomData?.theme || 'fantasy';
          const finalEnding = generateFinalStory(theme, newPath);
          await db.ref(`games/${roomId}`).update({ phase: 'ended', scores: newScores, path: newPath, story: [...newStory, { text: finalEnding, type: 'ending', round }], timerEnd: null });
          addMessage('system', 'üèÜ Chronicle Complete!');
          await recordGame();
          saveHistory(theme, newPath, newScores, finalEnding);
          const myScore = newScores[player.id] || { influence: 0, debates: 0 };
          const totalScore = (myScore.influence || 0) + (myScore.debates || 0);
          if (player.name && totalScore > 0) {
            const newLb = [...leaderboard, { id: Date.now(), name: player.name, avatar: player.avatar, score: totalScore, theme, date: new Date().toLocaleDateString() }].sort((a, b) => b.score - a.score).slice(0, 50);
            setLeaderboard(newLb);
            try { localStorage.setItem('cc_leaderboard', JSON.stringify(newLb)); } catch {}
          }
        } else {
          const nextRound = round + 1;
          const nextContext = getContext(nextRound, newPath);
          await db.ref(`games/${roomId}`).update({ round: nextRound, phase: 'debate', scores: newScores, path: newPath, story: [...newStory, { text: nextContext, type: 'context', round: nextRound }], timerEnd: Date.now() + CONFIG.DEBATE_DURATION * 1000, votes: {} });
          addMessage('system', `üìñ Round ${nextRound}/${CONFIG.TOTAL_ROUNDS} - Debate`);
          setTimeout(() => simulateAIDebate(), 3000);
        }
      };

      const generateFinalStory = (theme, path) => {
        const arc = THEMES[theme];
        const lastRound = arc.rounds[CONFIG.TOTAL_ROUNDS - 1];
        const lastChoice = path[path.length - 1];
        const endingKey = lastChoice === 'A' ? lastRound.a.ending : lastRound.b.ending;
        return arc.endings[endingKey] || arc.endings.default;
      };

      const saveHistory = (theme, path, scores, ending) => {
        const newHist = [...gameHistory, { id: Date.now(), theme, path: path.join(''), ending: ending.slice(0, 100) + '...', date: new Date().toLocaleDateString(), players: players.length }].slice(-20);
        setGameHistory(newHist);
        try { localStorage.setItem('cc_history', JSON.stringify(newHist)); } catch {}
      };

      const getContext = (roundNum, path) => {
        const roundData = THEMES[roomData?.theme || 'fantasy']?.rounds[roundNum - 1];
        if (!roundData) return '';
        if (roundNum > 1 && path.length > 0) {
          const pathKey = path.slice(-2).join('');
          if (roundData[`context${pathKey}`]) return roundData[`context${pathKey}`];
          if (roundData[`context${path[path.length - 1]}`]) return roundData[`context${path[path.length - 1]}`];
        }
        return roundData.context || '';
      };

      const getOption = (roundNum, choice) => { const roundData = THEMES[roomData?.theme || 'fantasy']?.rounds[roundNum - 1]; return choice === 'A' ? roundData?.a : roundData?.b; };

      const getConsequence = (roundNum, choice, path) => {
        const roundData = THEMES[roomData?.theme || 'fantasy']?.rounds[roundNum - 1];
        if (!roundData) return '';
        const option = choice === 'A' ? roundData.a : roundData.b;
        if (path.length > 0 && option[`consequenceFrom${path[path.length - 1]}`]) return option[`consequenceFrom${path[path.length - 1]}`];
        return option.consequence || '';
      };

      const getCurrentOptions = () => {
        if (!gameState || !roomData) return { a: null, b: null };
        const roundData = THEMES[roomData.theme || 'fantasy']?.rounds[(gameState.round || 1) - 1];
        return { a: roundData?.a, b: roundData?.b };
      };

      const addMessage = async (type, text, sender = null, choice = null) => { if (db && roomId) await db.ref(`games/${roomId}/messages`).push().set({ type, text, sender, choice, timestamp: Date.now() }); };

      const submitDebate = async () => {
        if (!debateInput.trim() || gameState?.phase !== 'debate') return;
        const choice = debateInput.toUpperCase().includes('OPTION A') || debateInput.toUpperCase().includes(' A ') ? 'A' : debateInput.toUpperCase().includes('OPTION B') || debateInput.toUpperCase().includes(' B ') ? 'B' : null;
        await addMessage('chat', debateInput, { id: player.id, name: player.name, avatar: player.avatar }, choice);
        setDebateInput('');
        if (gameState?.scores?.[player.id]) await db.ref(`games/${roomId}/scores/${player.id}/debates`).set((gameState.scores[player.id].debates || 0) + 10);
      };

      const submitVote = async (choice) => { if (gameState?.phase !== 'vote' || myVote) return; setMyVote(choice); await db.ref(`games/${roomId}/votes/${player.id}`).set(choice); };

      const resetGame = () => {
        if (timerRef.current) clearInterval(timerRef.current);
        if (roomCheckRef.current) clearInterval(roomCheckRef.current);
        setRoomId(null); setRoomData(null); setGameState(null); setPlayers([]); setMessages([]); setMyVote(null); setView('home');
      };

      const formatTime = (s) => `${Math.floor(s / 60)}:${(s % 60).toString().padStart(2, '0')}`;
      const shortAddr = (addr) => addr ? `${addr.slice(0, 6)}...${addr.slice(-4)}` : '';
      const theme = THEMES[roomData?.theme || 'fantasy'];

      // HOME
      if (view === 'home') {
        return (
          <div style={{ minHeight: '100vh', background: 'linear-gradient(180deg, #0a0a0f 0%, #12121a 100%)', color: '#e8e8e8' }}>
            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', padding: '1rem 2rem', borderBottom: '1px solid rgba(255,255,255,0.1)' }}>
              <div style={{ display: 'flex', alignItems: 'center', gap: '1rem' }}><span style={{ fontSize: '1.5rem' }}>üìú</span><span style={{ fontSize: '1.2rem', fontWeight: 700, background: 'linear-gradient(135deg, #a78bfa, #f472b6)', WebkitBackgroundClip: 'text', WebkitTextFillColor: 'transparent' }}>Consensus Chronicle</span></div>
              <div style={{ display: 'flex', alignItems: 'center', gap: '1rem' }}>
                {player.name && <span style={{ color: '#a5a5b8' }}>{player.avatar} {player.name} ‚Ä¢ ‚≠ê {player.exp}</span>}
                {walletAddress ? <span style={{ padding: '0.4rem 0.8rem', background: 'rgba(74,222,128,0.15)', borderRadius: '20px', fontSize: '0.85rem', color: '#4ade80' }}>üîó {shortAddr(walletAddress)}</span> : <button onClick={connectWallet} disabled={walletConnecting} style={{ padding: '0.5rem 1rem', background: 'linear-gradient(135deg, #a78bfa, #f472b6)', border: 'none', borderRadius: '20px', color: '#fff', fontSize: '0.85rem', fontWeight: 600, cursor: 'pointer' }}>{walletConnecting ? 'Connecting...' : 'ü¶ä Connect'}</button>}
              </div>
            </div>
            <div style={{ display: 'flex', justifyContent: 'center', gap: '2rem', padding: '1rem', borderBottom: '1px solid rgba(255,255,255,0.05)' }}>
              {[{ key: 'game', label: 'üéÆ Game' }, { key: 'leaderboard', label: 'üèÜ Leaderboard' }, { key: 'history', label: 'üìö History' }].map(tab => (
                <button key={tab.key} onClick={() => setActiveTab(tab.key)} style={{ padding: '0.6rem 1.5rem', background: activeTab === tab.key ? 'rgba(167,139,250,0.2)' : 'transparent', border: activeTab === tab.key ? '1px solid rgba(167,139,250,0.5)' : '1px solid transparent', borderRadius: '8px', color: activeTab === tab.key ? '#a78bfa' : '#8b8b9e', fontSize: '0.95rem', cursor: 'pointer' }}>{tab.label}</button>
              ))}
            </div>
            <div style={{ maxWidth: '1000px', margin: '0 auto', padding: '2rem' }}>
              {activeTab === 'game' && (<>
                {!player.name ? (
                  <div style={{ maxWidth: '400px', margin: '3rem auto', textAlign: 'center' }}><h2 style={{ marginBottom: '1.5rem', color: '#c4b5fd' }}>Enter Your Name</h2><input type="text" placeholder="Your name..." style={{ width: '100%', padding: '1rem', fontSize: '1.1rem', background: 'rgba(255,255,255,0.05)', border: '2px solid rgba(167,139,250,0.3)', borderRadius: '12px', color: '#fff', outline: 'none', textAlign: 'center' }} onKeyDown={(e) => e.key === 'Enter' && e.target.value.trim() && setPlayer(p => ({ ...p, name: e.target.value.trim() }))} /><p style={{ marginTop: '0.5rem', color: '#6b6b7e', fontSize: '0.9rem' }}>Press Enter</p></div>
                ) : (<>
                  <div style={{ textAlign: 'center', marginBottom: '1.5rem', padding: '0.8rem', background: 'rgba(167,139,250,0.1)', borderRadius: '10px', border: '1px solid rgba(167,139,250,0.3)' }}><p style={{ color: '#a78bfa' }}>‚ö° Creating/Joining requires GenLayer transaction (0 GEN)</p></div>
                  {availableRooms.length > 0 && (<div style={{ marginBottom: '2rem' }}><h3 style={{ color: '#c4b5fd', marginBottom: '1rem' }}>üö™ Available Rooms</h3><div style={{ maxHeight: '200px', overflowY: 'auto' }}>{availableRooms.map(room => (<div key={room.id} style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', padding: '1rem', marginBottom: '0.5rem', background: 'rgba(255,255,255,0.03)', borderRadius: '10px', border: '1px solid rgba(255,255,255,0.1)' }}><div style={{ display: 'flex', alignItems: 'center', gap: '0.8rem' }}><span style={{ fontSize: '1.5rem' }}>{THEMES[room.theme]?.icon}</span><div><div style={{ fontWeight: 600 }}>{THEMES[room.theme]?.name}</div><div style={{ fontSize: '0.8rem', color: '#8b8b9e' }}>{Object.keys(room.players || {}).length}/{CONFIG.ROOM_SIZE.max} players</div></div></div><button onClick={() => joinRoom(room.id)} disabled={loading} style={{ padding: '0.5rem 1.5rem', background: loading ? 'rgba(255,255,255,0.1)' : 'linear-gradient(135deg, #a78bfa, #f472b6)', border: 'none', borderRadius: '8px', color: '#fff', fontWeight: 600, cursor: loading ? 'not-allowed' : 'pointer' }}>{loading ? 'Processing...' : 'Join'}</button></div>))}</div></div>)}
                  <h3 style={{ color: '#c4b5fd', marginBottom: '1rem', textAlign: 'center' }}>Select Theme</h3>
                  <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(200px, 1fr))', gap: '1rem' }}>{Object.entries(THEMES).map(([key, t]) => (<button key={key} onClick={() => createRoom(key)} disabled={loading} style={{ display: 'flex', flexDirection: 'column', alignItems: 'center', padding: '1.5rem', background: t.bg, border: `1px solid ${t.accent}40`, borderRadius: '14px', cursor: loading ? 'not-allowed' : 'pointer', opacity: loading ? 0.5 : 1 }}><span style={{ fontSize: '3rem', marginBottom: '0.5rem' }}>{t.icon}</span><span style={{ fontSize: '1.1rem', fontWeight: 600, color: '#fff' }}>{t.name}</span></button>))}</div>
                  {loading && <div style={{ textAlign: 'center', padding: '1.5rem', color: '#fbbf24' }}>‚è≥ Waiting for transaction...</div>}
                </>)}
              </>)}
              {activeTab === 'leaderboard' && (<div style={{ maxWidth: '600px', margin: '0 auto' }}><h2 style={{ textAlign: 'center', marginBottom: '1.5rem', color: '#fbbf24' }}>üèÜ Leaderboard</h2>{leaderboard.length === 0 ? <p style={{ textAlign: 'center', color: '#6b6b7e', padding: '3rem' }}>No records yet</p> : <div style={{ maxHeight: '500px', overflowY: 'auto' }}>{leaderboard.map((e, i) => (<div key={e.id} style={{ display: 'flex', alignItems: 'center', gap: '1rem', padding: '1rem', background: i === 0 ? 'rgba(251,191,36,0.15)' : 'rgba(255,255,255,0.02)', borderRadius: '10px', marginBottom: '0.5rem' }}><span style={{ fontWeight: 700, color: i < 3 ? '#fbbf24' : '#6b6b7e', width: '2.5rem' }}>#{i + 1}</span><span style={{ fontSize: '1.5rem' }}>{e.avatar}</span><div style={{ flex: 1 }}><div style={{ fontWeight: 600 }}>{e.name}</div><div style={{ fontSize: '0.8rem', color: '#8b8b9e' }}>{THEMES[e.theme]?.name} ‚Ä¢ {e.date}</div></div><span style={{ fontWeight: 700, color: '#a78bfa', fontSize: '1.2rem' }}>{e.score}</span></div>))}</div>}</div>)}
              {activeTab === 'history' && (<div style={{ maxWidth: '700px', margin: '0 auto' }}><h2 style={{ textAlign: 'center', marginBottom: '1.5rem', color: '#06b6d4' }}>üìö Game History</h2>{gameHistory.length === 0 ? <p style={{ textAlign: 'center', color: '#6b6b7e', padding: '3rem' }}>No games yet</p> : <div style={{ maxHeight: '500px', overflowY: 'auto' }}>{gameHistory.slice().reverse().map(g => (<div key={g.id} style={{ padding: '1.2rem', background: 'rgba(255,255,255,0.03)', borderRadius: '10px', marginBottom: '0.8rem' }}><div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '0.5rem' }}><span style={{ fontWeight: 600 }}>{THEMES[g.theme]?.icon} {THEMES[g.theme]?.name}</span><span style={{ fontSize: '0.85rem', color: '#8b8b9e' }}>{g.date}</span></div><div style={{ fontSize: '0.85rem', color: '#a5a5b8', marginBottom: '0.5rem' }}>Path: {g.path.split('').map((c, i) => <span key={i} style={{ padding: '0.1rem 0.4rem', margin: '0 0.2rem', background: c === 'A' ? 'rgba(239,68,68,0.2)' : 'rgba(59,130,246,0.2)', borderRadius: '4px' }}>{c}</span>)}</div><div style={{ fontSize: '0.9rem', color: '#c4b5fd', fontStyle: 'italic' }}>{g.ending}</div></div>))}</div>}</div>)}
            </div>
          </div>
        );
      }

      // ROOM
      if (view === 'room') {
        const roomAge = roomData ? Math.floor((Date.now() - roomData.createdAt) / 1000) : 0;
        return (
          <div style={{ minHeight: '100vh', background: theme.bg, color: '#e8e8e8' }}>
            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', padding: '1rem 2rem', borderBottom: '1px solid rgba(255,255,255,0.1)' }}>
              <div style={{ display: 'flex', alignItems: 'center', gap: '1rem' }}><span style={{ color: '#a5a5b8' }}>{player.avatar} {player.name} ‚Ä¢ ‚≠ê {player.exp}</span><span style={{ padding: '0.3rem 0.6rem', background: 'rgba(74,222,128,0.15)', borderRadius: '15px', fontSize: '0.8rem', color: '#4ade80' }}>{shortAddr(walletAddress)}</span></div>
              <button onClick={resetGame} style={{ padding: '0.5rem 1rem', background: 'transparent', border: '1px solid rgba(255,255,255,0.2)', borderRadius: '8px', color: '#a5a5b8', cursor: 'pointer' }}>‚Üê Back</button>
            </div>
            <div style={{ maxWidth: '600px', margin: '0 auto', padding: '2rem' }}>
              <div style={{ textAlign: 'center', marginBottom: '2rem' }}><span style={{ fontSize: '3rem' }}>{theme.icon}</span><h2 style={{ color: theme.accent }}>{theme.name}</h2><p style={{ color: '#8b8b9e' }}>{roomAge}s</p></div>
              {roomAge > 60 && <div style={{ textAlign: 'center', marginBottom: '1rem', padding: '0.5rem', background: 'rgba(251,191,36,0.1)', borderRadius: '8px', color: '#fbbf24', fontSize: '0.9rem' }}>‚è∞ AI will auto-join after 1 min</div>}
              <h3 style={{ color: '#8b8b9e', marginBottom: '1rem' }}>Players ({players.length}/{CONFIG.ROOM_SIZE.max})</h3>
              <div style={{ display: 'grid', gridTemplateColumns: 'repeat(4, 1fr)', gap: '1rem', marginBottom: '2rem' }}>{players.map(p => (<div key={p.id} style={{ display: 'flex', flexDirection: 'column', alignItems: 'center', padding: '1rem', background: p.id === player.id ? `${theme.accent}20` : 'rgba(255,255,255,0.03)', border: `1px solid ${p.id === player.id ? theme.accent : 'rgba(255,255,255,0.1)'}`, borderRadius: '10px', position: 'relative' }}><span style={{ fontSize: '2rem', marginBottom: '0.3rem' }}>{p.avatar}</span><span style={{ fontSize: '0.8rem' }}>{p.name}</span>{p.isAI && <span style={{ position: 'absolute', top: '0.3rem', left: '0.3rem', fontSize: '0.5rem', padding: '0.1rem 0.3rem', background: '#3b82f6', borderRadius: '3px' }}>AI</span>}{p.id === roomData?.host && <span style={{ position: 'absolute', top: '0.3rem', right: '0.3rem', fontSize: '0.5rem', padding: '0.1rem 0.3rem', background: '#fbbf24', color: '#000', borderRadius: '3px' }}>Host</span>}</div>))}</div>
              {player.id === roomData?.host && (<><button onClick={startGame} disabled={players.length < CONFIG.ROOM_SIZE.min} style={{ width: '100%', padding: '1rem', fontSize: '1.1rem', fontWeight: 600, border: 'none', borderRadius: '10px', cursor: players.length >= CONFIG.ROOM_SIZE.min ? 'pointer' : 'not-allowed', background: players.length >= CONFIG.ROOM_SIZE.min ? `linear-gradient(135deg, ${theme.accent}, #f472b6)` : 'rgba(255,255,255,0.1)', color: players.length >= CONFIG.ROOM_SIZE.min ? '#fff' : '#6b6b7e', marginBottom: '1rem' }}>{players.length >= CONFIG.ROOM_SIZE.min ? 'üéÆ Start Game' : `Waiting (${players.length}/${CONFIG.ROOM_SIZE.min})`}</button><button onClick={addAIPlayers} style={{ width: '100%', padding: '0.8rem', border: '1px solid rgba(59,130,246,0.5)', borderRadius: '10px', background: 'transparent', color: '#3b82f6', cursor: 'pointer' }}>ü§ñ Add AI Players</button></>)}
            </div>
          </div>
        );
      }

      // GAME
      const currentOptions = getCurrentOptions();
      const votes = gameState?.votes || {};
      return (
        <div style={{ height: '100vh', background: theme?.bg || '#0a0a0f', display: 'flex', flexDirection: 'column', color: '#e8e8e8', overflow: 'hidden' }}>
          <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', padding: '0.8rem 1.5rem', background: 'rgba(0,0,0,0.4)', borderBottom: `1px solid ${theme?.accent}40` }}>
            <div style={{ display: 'flex', alignItems: 'center', gap: '1rem' }}><span style={{ color: '#a5a5b8', fontSize: '0.9rem' }}>{player.avatar} {player.name} ‚Ä¢ ‚≠ê {player.exp}</span><span style={{ padding: '0.2rem 0.5rem', background: 'rgba(74,222,128,0.15)', borderRadius: '12px', fontSize: '0.75rem', color: '#4ade80' }}>{shortAddr(walletAddress)}</span></div>
            <div style={{ display: 'flex', alignItems: 'center', gap: '1.5rem' }}><div style={{ textAlign: 'center' }}><div style={{ fontSize: '0.75rem', color: '#8b8b9e' }}>Round</div><div style={{ fontWeight: 600, color: theme?.accent }}>{gameState?.round || 1}/{CONFIG.TOTAL_ROUNDS}</div></div><div style={{ fontSize: '2rem', fontWeight: 700, fontFamily: 'monospace', color: timer <= 10 && gameState?.phase !== 'ended' ? '#f87171' : theme?.accent }}>{gameState?.phase === 'ended' ? '--:--' : formatTime(timer)}</div><div style={{ textAlign: 'center' }}><div style={{ fontSize: '0.75rem', color: '#8b8b9e' }}>Score</div><div style={{ fontWeight: 600, color: '#fbbf24' }}>{(gameState?.scores?.[player.id]?.influence || 0) + (gameState?.scores?.[player.id]?.debates || 0)}</div></div></div>
            <div style={{ fontWeight: 600, color: theme?.accent }}>{gameState?.phase === 'debate' && 'üí¨ Debate'}{gameState?.phase === 'vote' && 'üó≥Ô∏è Vote'}{gameState?.phase === 'ended' && 'üèÜ Complete'}</div>
          </div>
          <div style={{ flex: 1, display: 'flex', gap: '1rem', padding: '1rem', overflow: 'hidden' }}>
            <div style={{ flex: 1, display: 'flex', flexDirection: 'column', gap: '1rem', minWidth: 0 }}>
              <div style={{ flex: 1, background: 'rgba(0,0,0,0.3)', borderRadius: '12px', padding: '1rem', overflowY: 'auto', border: `1px solid ${theme?.accent}30` }}>
                <h3 style={{ color: theme?.accent, marginBottom: '1rem' }}>{theme?.icon} {theme?.name}</h3>
                {(gameState?.story || []).map((s, i) => (<div key={i} style={{ padding: '0.6rem 0', borderBottom: i < (gameState?.story?.length || 0) - 1 ? `1px solid ${theme?.accent}20` : 'none' }}>{s.type === 'opening' && <p style={{ color: theme?.accent, fontStyle: 'italic', lineHeight: 1.7 }}>{s.text}</p>}{s.type === 'context' && <p style={{ color: '#fbbf24', lineHeight: 1.7 }}><span style={{ background: 'rgba(251,191,36,0.2)', padding: '0.15rem 0.5rem', borderRadius: '4px', marginRight: '0.5rem', fontSize: '0.8rem' }}>R{s.round}</span>{s.text}</p>}{s.type === 'choice' && <p style={{ color: '#4ade80', lineHeight: 1.7 }}>{s.winner === 'A' ? 'üÖ∞Ô∏è' : 'üÖ±Ô∏è'} {s.text}</p>}{s.type === 'consequence' && <p style={{ color: '#a5a5b8', lineHeight: 1.7, paddingLeft: '1rem', borderLeft: `2px solid ${theme?.accent}50` }}>{s.text}</p>}{s.type === 'ending' && <p style={{ color: '#fbbf24', lineHeight: 1.8, padding: '1rem', background: 'rgba(251,191,36,0.1)', borderRadius: '8px', marginTop: '0.5rem', fontWeight: 500 }}>üìñ {s.text}</p>}</div>))}
              </div>
              {(gameState?.phase === 'debate' || gameState?.phase === 'vote') && currentOptions.a && (<div style={{ background: 'rgba(0,0,0,0.3)', borderRadius: '12px', padding: '1rem', border: `1px solid ${theme?.accent}30` }}><h4 style={{ textAlign: 'center', marginBottom: '0.8rem' }}>‚öîÔ∏è Choose</h4><div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '1rem' }}>{[{ key: 'A', opt: currentOptions.a, color: '#ef4444' }, { key: 'B', opt: currentOptions.b, color: '#3b82f6' }].map(({ key, opt, color }) => (<div key={key} onClick={() => gameState?.phase === 'vote' && submitVote(key)} style={{ padding: '1rem', borderRadius: '10px', border: `2px solid ${myVote === key ? color : `${color}40`}`, background: `${color}15`, cursor: gameState?.phase === 'vote' ? 'pointer' : 'default' }}><div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '0.5rem' }}><span style={{ fontWeight: 700, color }}>Option {key}</span><span style={{ fontSize: '0.7rem', padding: '0.15rem 0.5rem', background: 'rgba(255,255,255,0.1)', borderRadius: '4px', color: '#a5a5b8' }}>{opt?.tag}</span></div><p style={{ lineHeight: 1.5, fontSize: '0.9rem' }}>{opt?.text}</p>{gameState?.phase === 'vote' && <div style={{ marginTop: '0.8rem', textAlign: 'center', fontSize: '1.2rem', fontWeight: 700, color: '#fbbf24' }}>{Object.values(votes).filter(v => v === key).length} votes</div>}</div>))}</div></div>)}
              {gameState?.phase === 'ended' && (<div style={{ background: `linear-gradient(145deg, ${theme?.accent}20, rgba(251,191,36,0.1))`, borderRadius: '12px', padding: '1.5rem', textAlign: 'center' }}><h2 style={{ fontSize: '1.5rem', marginBottom: '1rem', color: '#fbbf24' }}>üèÜ Chronicle Complete!</h2><div style={{ maxHeight: '200px', overflowY: 'auto', marginBottom: '1rem' }}>{Object.entries(gameState?.scores || {}).map(([id, score]) => ({ player: players.find(p => p.id === id), total: (score.influence || 0) + (score.debates || 0) })).sort((a, b) => b.total - a.total).map((rank, i) => (<div key={rank.player?.id || i} style={{ display: 'flex', alignItems: 'center', gap: '0.6rem', padding: '0.6rem', marginBottom: '0.3rem', background: i === 0 ? 'rgba(251,191,36,0.2)' : 'rgba(255,255,255,0.03)', borderRadius: '6px' }}><span style={{ fontWeight: 700, color: i < 3 ? '#fbbf24' : '#6b6b7e' }}>#{i + 1}</span><span>{rank.player?.avatar}</span><span style={{ flex: 1 }}>{rank.player?.name}</span><span style={{ fontWeight: 600, color: theme?.accent }}>{rank.total}</span></div>))}</div><button onClick={resetGame} style={{ padding: '0.8rem 2rem', background: `linear-gradient(135deg, ${theme?.accent}, #f472b6)`, border: 'none', borderRadius: '10px', color: '#fff', fontWeight: 600, cursor: 'pointer' }}>Return to Lobby</button></div>)}
            </div>
            <div style={{ width: '300px', display: 'flex', flexDirection: 'column', background: 'rgba(0,0,0,0.3)', borderRadius: '12px', overflow: 'hidden', border: `1px solid ${theme?.accent}30` }}>
              <div style={{ display: 'flex', flexWrap: 'wrap', gap: '0.3rem', padding: '0.6rem', borderBottom: `1px solid ${theme?.accent}20` }}>{players.map(p => (<div key={p.id} style={{ display: 'flex', alignItems: 'center', gap: '0.2rem', padding: '0.2rem 0.5rem', background: votes[p.id] ? 'rgba(74,222,128,0.2)' : 'rgba(255,255,255,0.05)', borderRadius: '12px', fontSize: '0.75rem' }}><span>{p.avatar}</span><span style={{ maxWidth: '50px', overflow: 'hidden', textOverflow: 'ellipsis', whiteSpace: 'nowrap' }}>{p.name}</span>{votes[p.id] && <span style={{ color: '#4ade80', fontWeight: 700 }}>{votes[p.id]}</span>}</div>))}</div>
              <div style={{ flex: 1, overflowY: 'auto', padding: '0.6rem' }}>{messages.map((msg, i) => (<div key={i} style={{ marginBottom: '0.5rem', fontSize: '0.8rem' }}>{msg.type === 'system' ? <div style={{ color: theme?.accent, fontStyle: 'italic' }}>{msg.text}</div> : <div style={{ background: 'rgba(255,255,255,0.03)', borderRadius: '6px', padding: '0.4rem 0.6rem' }}><div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '0.2rem' }}><span style={{ color: '#fbbf24', fontWeight: 600 }}>{msg.sender?.avatar} {msg.sender?.name}</span>{msg.choice && <span style={{ fontSize: '0.65rem', padding: '0.1rem 0.3rem', background: msg.choice === 'A' ? 'rgba(239,68,68,0.3)' : 'rgba(59,130,246,0.3)', borderRadius: '3px' }}>{msg.choice}</span>}</div><div>{msg.text}</div></div>}</div>))}<div ref={messagesEndRef} /></div>
              {gameState?.phase === 'debate' && (<div style={{ padding: '0.6rem', borderTop: `1px solid ${theme?.accent}20` }}><div style={{ display: 'flex', gap: '0.4rem', marginBottom: '0.4rem' }}><input type="text" value={debateInput} onChange={(e) => setDebateInput(e.target.value)} onKeyDown={(e) => e.key === 'Enter' && submitDebate()} placeholder="Share your view..." style={{ flex: 1, padding: '0.5rem', background: 'rgba(255,255,255,0.05)', border: '1px solid rgba(255,255,255,0.1)', borderRadius: '6px', color: '#fff', fontSize: '0.8rem', outline: 'none' }} /><button onClick={submitDebate} style={{ padding: '0.5rem 0.8rem', background: `linear-gradient(135deg, ${theme?.accent}, #f472b6)`, border: 'none', borderRadius: '6px', color: '#fff', fontWeight: 600, cursor: 'pointer' }}>Send</button></div><div style={{ display: 'flex', gap: '0.3rem' }}><button onClick={() => setDebateInput('I support Option A because ')} style={{ padding: '0.2rem 0.5rem', background: 'rgba(239,68,68,0.2)', border: '1px solid rgba(239,68,68,0.3)', borderRadius: '10px', color: '#ef4444', fontSize: '0.7rem', cursor: 'pointer' }}>üÖ∞Ô∏è A</button><button onClick={() => setDebateInput('I support Option B because ')} style={{ padding: '0.2rem 0.5rem', background: 'rgba(59,130,246,0.2)', border: '1px solid rgba(59,130,246,0.3)', borderRadius: '10px', color: '#3b82f6', fontSize: '0.7rem', cursor: 'pointer' }}>üÖ±Ô∏è B</button></div></div>)}
              {gameState?.phase === 'vote' && !myVote && (<div style={{ padding: '0.8rem', textAlign: 'center', background: `${theme?.accent}20` }}><p style={{ color: '#fbbf24', fontWeight: 600 }}>‚è∞ Cast your vote!</p></div>)}
            </div>
          </div>
        </div>
      );
    }

    ReactDOM.createRoot(document.getElementById('root')).render(<App />);
  </script>
</body>
</html>
