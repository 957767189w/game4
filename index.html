<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>å…±è¯†ç¼–å¹´å² | Consensus Chronicle</title>
  <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-database-compat.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: system-ui, -apple-system, sans-serif; background: #0f0f1a; }
    #root { min-height: 100vh; }
  </style>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
    const { useState, useEffect, useRef } = React;

    const CONFIG = {
      ROOM_SIZE: { min: 2, max: 8 },
      DEBATE_DURATION: 90,
      VOTE_DURATION: 30,
      TOTAL_ROUNDS: 5,
      ENTRY_FEE: '0.01',
      GENLAYER_CONTRACT: '0x4F5F132ba540f1C685B0188D59990302903aE186',
      FIREBASE: {
        apiKey: "AIzaSyBX4tOb30jWKK6aBUsqERQaOAF4CxCfMmQ",
        authDomain: "consensus-chronicle.firebaseapp.com",
        databaseURL: "https://consensus-chronicle-default-rtdb.firebaseio.com",
        projectId: "consensus-chronicle",
        storageBucket: "consensus-chronicle.firebasestorage.app",
        messagingSenderId: "175835565956",
        appId: "1:175835565956:web:80e59789fade3d439757d1"
      }
    };

    const STORY_ARCS = {
      fantasy: {
        name: 'å¥‡å¹»å†’é™©', icon: 'ğŸ°',
        opening: 'å¤è€çš„é¢„è¨€ç»ˆäºåº”éªŒâ€”â€”æ²‰ç¡åƒå¹´çš„é»‘é¾™è‹é†’äº†ã€‚ç‹å›½å±åœ¨æ—¦å¤•ï¼Œå›½ç‹ç´§æ€¥å¬é›†äº†å„åœ°è‹±é›„å•†è®®å¯¹ç­–...',
        rounds: [
          { context: 'é»‘é¾™çš„å¨èƒè¿«åœ¨çœ‰ç«ï¼Œç‹å›½å¿…é¡»åšå‡ºç¬¬ä¸€ä¸ªå…³é”®å†³å®šã€‚', a: { text: 'ç«‹å³é›†ç»“å†›é˜Ÿï¼Œä¸»åŠ¨å‡ºå‡»é¾™å·¢ï¼Œåœ¨å®ƒå®Œå…¨è‹é†’å‰å°†å…¶æ¶ˆç­ã€‚', tag: 'å…ˆå‘åˆ¶äººÂ·æ¿€è¿›', consequence: 'ç‹å›½å†›é˜Ÿå‘é¾™å·¢è¿›å‘ï¼Œä½†é€”ä¸­é­é‡äº†é¾™çš„çˆªç‰™ï¼ŒæŸå¤±æƒ¨é‡...' }, b: { text: 'æ´¾é£ä½¿è€…å¯»æ±‚ç²¾çµæ—çš„å¸®åŠ©ï¼Œä»–ä»¬æ›¾åœ¨åƒå¹´å‰å°å°è¿‡é»‘é¾™ã€‚', tag: 'å¯»æ±‚è”ç›ŸÂ·ç¨³å¦¥', consequence: 'ä½¿è€…æˆåŠŸè”ç³»åˆ°äº†ç²¾çµæ—ï¼Œä½†ä»–ä»¬æå‡ºäº†è‹›åˆ»çš„æ¡ä»¶...' } },
          { contextA: 'å†›é˜ŸæŸå¤±æƒ¨é‡ï¼Œä½†å·²é€¼è¿‘é¾™å·¢ã€‚æ­¤æ—¶æ¢å­æ¥æŠ¥ï¼šé¾™å·¢å†…å‘ç°äº†é¾™è›‹ã€‚', contextB: 'ç²¾çµæ—è¦æ±‚äººç±»äº¤å‡ºåœ£å‰‘ä½œä¸ºä¿¡ä»»çš„è¯æ˜ï¼Œå¦åˆ™ä¸äºˆæ´åŠ©ã€‚', a: { text: 'æ‘§æ¯é¾™è›‹ï¼Œå½»åº•æ–­ç»é»‘é¾™ä¸€æ—çš„è¡€è„‰ï¼Œæ°¸é™¤åæ‚£ã€‚', tag: 'æ–©è‰é™¤æ ¹Â·æ®‹é…·', consequenceFromA: 'é¾™è›‹è¢«æ¯ï¼Œé»‘é¾™ç‹‚æ€’ï¼Œæˆ˜æ–—æ›´åŠ æƒ¨çƒˆ...', consequenceFromB: 'æ‹’ç»äº¤å‡ºåœ£å‰‘åï¼Œäººç±»å†³å®šç‹¬è‡ªé¢å¯¹é»‘é¾™ï¼Œæ‘§æ¯äº†é¾™è›‹...' }, b: { text: 'ä¿ç•™é¾™è›‹ï¼Œæˆ–è®¸å¯ä»¥ç”¨å®ƒä¸é»‘é¾™è°ˆåˆ¤ï¼Œæˆ–åŸ¹å…»ä¸€æ¡å‹å–„çš„é¾™ã€‚', tag: 'ç•™æœ‰ä½™åœ°Â·å†’é™©', consequenceFromA: 'é¾™è›‹è¢«ç§˜å¯†ä¿æŠ¤èµ·æ¥ï¼Œä½†æ¶ˆæ¯æ³„éœ²å¼•å‘äº†å†…éƒ¨åˆ†è£‚...', consequenceFromB: 'äº¤å‡ºåœ£å‰‘æ¢å–ç²¾çµæ´åŠ©ï¼ŒåŒæ—¶ä¿æŠ¤äº†é¾™è›‹...' } },
          { contextAA: 'é»‘é¾™åœ¨ç‹‚æ€’ä¸­å±•ç°å‡ºæ¯å¤©ç­åœ°çš„åŠ›é‡ï¼Œå†›é˜Ÿå³å°†å…¨å†›è¦†æ²¡ã€‚', contextAB: 'å†…éƒ¨åˆ†è£‚å¯¼è‡´å†›å¿ƒæ¶£æ•£ï¼Œæœ‰äººä¸»å¼ æŠ•é™ï¼Œæœ‰äººåšæŒæˆ˜æ–—ã€‚', contextBA: 'ç‹¬è‡ªä½œæˆ˜çš„äººç±»å†›é˜Ÿåœ¨æ²¡æœ‰ç²¾çµé­”æ³•çš„æ”¯æŒä¸‹é™·å…¥è‹¦æˆ˜ã€‚', contextBB: 'ç²¾çµå†›é˜ŸæŠµè¾¾ï¼Œä½†ä»–ä»¬å¯¹é¾™è›‹çš„å­˜åœ¨æ„Ÿåˆ°ä¸æ»¡ï¼Œå¨èƒæ’¤å†›ã€‚', a: { text: 'ä½¿ç”¨ç¦å¿Œé­”æ³•ï¼Œç‰ºç‰²æ–½æ³•è€…çš„ç”Ÿå‘½æ¥é‡åˆ›é»‘é¾™ã€‚', tag: 'ç‰ºç‰²å°æˆ‘Â·æ‚²å£®', consequence: 'ç¦å¿Œé­”æ³•ç”Ÿæ•ˆï¼Œé»‘é¾™é‡ä¼¤å è½ï¼Œä½†ä»£ä»·æ˜¯æƒ¨é‡çš„...' }, b: { text: 'ä¸‹ä»¤æ’¤é€€ï¼Œä¿å­˜å®åŠ›ï¼Œç­‰å¾…æ›´å¥½çš„æ—¶æœºå†æˆ˜ã€‚', tag: 'ä»¥é€€ä¸ºè¿›Â·å¿è€', consequence: 'å†›é˜Ÿæ’¤é€€åˆ°å®‰å…¨åœ°å¸¦ï¼Œä½†é»‘é¾™è¶æœºæ‘§æ¯äº†æ•°ä¸ªæ‘åº„...' } },
          { contextA: 'é»‘é¾™é‡ä¼¤åé€€å›å·¢ç©´ç–—ä¼¤ï¼Œä½†å®ƒçš„æ„¤æ€’ä½¿å¾—æ•´ä¸ªåŒºåŸŸéƒ½ç¬¼ç½©åœ¨æ­»äº¡æ°”æ¯ä¸­ã€‚', contextB: 'æ’¤é€€åï¼Œç‹å›½å¼€å§‹åæ€ç­–ç•¥ï¼Œæ°‘é—´å‡ºç°äº†å„ç§å£°éŸ³å’ŒåŠ¿åŠ›ã€‚', a: { text: 'è¶é»‘é¾™ç–—ä¼¤æœŸé—´å‘èµ·æ€»æ”»ï¼Œä¸€ä¸¾å°†å…¶æ¶ˆç­ã€‚', tag: 'ä¹˜èƒœè¿½å‡»Â·å†³ç»', consequence: 'æ€»æ”»å¼€å§‹ï¼Œè¿™å°†æ˜¯å†³å®šç‹å›½å‘½è¿çš„æœ€åä¸€æˆ˜...' }, b: { text: 'å°è¯•ä¸å—ä¼¤çš„é»‘é¾™æ²Ÿé€šï¼Œå¯»æ‰¾å’Œå¹³å…±å­˜çš„å¯èƒ½ã€‚', tag: 'åŒ–æ•Œä¸ºå‹Â·ç†æƒ³', consequence: 'ä½¿è€…å†’æ­»æ¥è¿‘é»‘é¾™ï¼Œå‡ºä¹æ„æ–™åœ°ï¼Œé»‘é¾™æ„¿æ„å¯¹è¯...' } },
          { contextA: 'æœ€ç»ˆå†³æˆ˜ä¸­ï¼ŒåŒæ–¹éƒ½ä»˜å‡ºäº†æƒ¨é‡ä»£ä»·ï¼Œèƒœè´Ÿå³å°†æ­æ™“ã€‚', contextB: 'é»‘é¾™é€éœ²å®ƒè‹é†’æ˜¯å› ä¸ºæ„Ÿå—åˆ°äº†æ›´å¤§çš„å¨èƒâ€”â€”æ¥è‡ªæ·±æ¸Šçš„é‚ªç¥å³å°†é™ä¸´ã€‚', a: { text: 'ä¸æƒœä¸€åˆ‡ä»£ä»·æ¶ˆç­é»‘é¾™ï¼Œå“ªæ€•ç‹å›½åŒ–ä¸ºç„¦åœŸä¹Ÿåœ¨æ‰€ä¸æƒœã€‚', tag: 'ç‰çŸ³ä¿±ç„šÂ·æç«¯', ending: 'é»‘é¾™è¢«æ¶ˆç­ï¼Œä½†ç‹å›½ä¹Ÿå‡ ä¹åŒ–ä¸ºåºŸå¢Ÿã€‚å¹¸å­˜è€…å¼€å§‹äº†æ¼«é•¿çš„é‡å»ºä¹‹è·¯ï¼Œå†å²å°†é“­è®°è¿™åœºæƒ¨èƒœã€‚' }, b: { text: 'æ¥å—å‘½è¿çš„å®‰æ’ï¼Œä¸é»‘é¾™è¾¾æˆåè®®ï¼Œå…±åŒé¢å¯¹æœªæ¥çš„æŒ‘æˆ˜ã€‚', tag: 'æ¡æ‰‹è¨€å’ŒÂ·æ™ºæ…§', ending: 'äººç±»ä¸é»‘é¾™è¾¾æˆäº†å‰æ‰€æœªæœ‰çš„ç›Ÿçº¦ï¼Œå…±åŒå®ˆæŠ¤è¿™ç‰‡å¤§é™†ã€‚ä¸€ä¸ªæ–°çš„æ—¶ä»£å°±æ­¤å¼€å¯ã€‚' } }
        ]
      },
      scifi: {
        name: 'ç§‘å¹»æœªæ¥', icon: 'ğŸš€',
        opening: '2157å¹´ï¼Œç«æ˜Ÿæ®–æ°‘åœ°"æ–°å¸Œæœ›"æ”¶åˆ°äº†ä¸€æ®µæ¥è‡ªæ·±ç©ºçš„ç¥ç§˜ä¿¡å·ã€‚ç§‘å­¦å®¶ä»¬ç ´è¯‘åå‘ç°ï¼šè¿™æ˜¯ä¸€ä¸ªè­¦å‘Šâ€”â€”åœ°çƒå°†åœ¨100å¤©åè¢«å°è¡Œæ˜Ÿæ’å‡»ã€‚ç„¶è€Œï¼Œæ®–æ°‘åœ°çš„èµ„æºåªå¤Ÿæ•‘ä¸€åŠäºº...',
        rounds: [
          { context: 'æ¶ˆæ¯å…¬å¸ƒåï¼Œæ®–æ°‘åœ°é™·å…¥ææ…Œã€‚é¢†å¯¼å±‚å¿…é¡»ç«‹å³åšå‡ºå†³å®šã€‚', a: { text: 'ç«‹å³å¯åŠ¨"æ–¹èˆŸè®¡åˆ’"ï¼Œé€šè¿‡æŠ½ç­¾å†³å®šè°èƒ½ç™»ä¸Šé€ƒç”Ÿé£èˆ¹ã€‚', tag: 'å…¬å¹³æŠ½ç­¾Â·å†·é…·', consequence: 'æŠ½ç­¾ç»“æœå…¬å¸ƒï¼Œè½é€‰è€…å¼€å§‹ç»æœ›åœ°æŠ—è®®ï¼Œå®‰ä¿éƒ¨é˜Ÿè¢«è¿«ä»‹å…¥...' }, b: { text: 'é›†ä¸­æ‰€æœ‰èµ„æºç ”ç©¶ä¿¡å·æ¥æºï¼Œä¹Ÿè®¸é‚£é‡Œæœ‰æ‹¯æ•‘æ‰€æœ‰äººçš„ç­”æ¡ˆã€‚', tag: 'è¿½å¯»å¸Œæœ›Â·å†’é™©', consequence: 'ç ”ç©¶å›¢é˜Ÿå‘ç°ä¿¡å·æ¥è‡ªä¸€ä¸ªæœªçŸ¥æ–‡æ˜ï¼Œä»–ä»¬ä¼¼ä¹åœ¨é‚€è¯·äººç±»...' } },
          { contextA: 'æŠ—è®®æ¼”å˜ä¸ºæš´åŠ¨ï¼Œéƒ¨åˆ†è½é€‰è€…å é¢†äº†é£èˆ¹å‘å°„åŒºã€‚', contextB: 'æ·±å…¥åˆ†æä¿¡å·åï¼Œå‘ç°é‚£ä¸ªæ–‡æ˜åœ¨é‚€è¯·äººç±»å»ä¸€ä¸ªé¥è¿œçš„æ˜Ÿç³»ï¼Œä½†æ—…ç¨‹éœ€è¦500å¹´ã€‚', a: { text: 'æˆæƒå®‰ä¿éƒ¨é˜Ÿä½¿ç”¨æ­¦åŠ›ï¼Œç¡®ä¿æ–¹èˆŸè®¡åˆ’æŒ‰æ—¶æ‰§è¡Œã€‚', tag: 'é“è…•é•‡å‹Â·æ•ˆç‡', consequenceFromA: 'æš´åŠ¨è¢«é•‡å‹ï¼Œä½†è®¸å¤šäººåœ¨å†²çªä¸­ä¸§ç”Ÿï¼Œå¹¸å­˜è€…å¿ƒå­˜æ€¨æ¨...', consequenceFromB: 'æ”¾å¼ƒä¸å¤–æ˜Ÿæ–‡æ˜è”ç³»ï¼Œä¸“æ³¨äºç°æœ‰çš„é€ƒç”Ÿè®¡åˆ’...' }, b: { text: 'ä¸æŠ—è®®è€…è°ˆåˆ¤ï¼Œå°è¯•ä¿®æ”¹è®¡åˆ’è®©æ›´å¤šäººè·å¾—ç”Ÿå­˜æœºä¼šã€‚', tag: 'å¯»æ±‚å…±è¯†Â·äººé“', consequenceFromA: 'è°ˆåˆ¤å–å¾—è¿›å±•ï¼Œå·¥ç¨‹å¸ˆæå‡ºå¯ä»¥è¶…è½½é£èˆ¹ï¼Œä½†é£é™©æå¤§...', consequenceFromB: 'å†³å®šæ´¾é£å…ˆé”‹é˜Ÿå“åº”é‚€è¯·ï¼Œå…¶ä½™äººè¿›å…¥å†·å†»ç¡çœ ç­‰å¾…...' } },
          { contextAA: 'é£èˆ¹è¶…è½½ä¼šå¯¼è‡´æˆåŠŸç‡ä»95%é™åˆ°60%ï¼Œä½†èƒ½å¤šæ•‘30%çš„äººã€‚', contextAB: 'å…ˆé”‹é˜Ÿå‡ºå‘åå¤±å»è”ç³»ï¼Œå‰©ä½™èµ„æºåªå¤Ÿç»´æŒ60å¤©ã€‚', contextBA: 'éƒ¨åˆ†æ¿€è¿›åˆ†å­ä¸æ¥å—è°ˆåˆ¤ç»“æœï¼Œå¯†è°‹ç ´åé£èˆ¹ã€‚', contextBB: 'å†·å†»ç¡çœ æŠ€æœ¯å°šæœªå®Œå–„ï¼Œæœ‰30%çš„å¤±è´¥ç‡ã€‚', a: { text: 'æ¥å—è¶…è½½æ–¹æ¡ˆï¼Œç”¨60%çš„æˆåŠŸç‡æ¢å–æ›´å¤šäººçš„å¸Œæœ›ã€‚', tag: 'å†’é™©æ±‚å…¨Â·èµŒåš', consequence: 'è¶…è½½æ–¹æ¡ˆå¯åŠ¨ï¼Œæ‰€æœ‰äººéƒ½åœ¨ç¥ˆç¥·å¥‡è¿¹å‘ç”Ÿ...' }, b: { text: 'ç»´æŒåŸè®¡åˆ’ï¼Œç¡®ä¿è‡³å°‘ä¸€åŠäººèƒ½å¤Ÿç¡®å®šå­˜æ´»ã€‚', tag: 'ç¨³å¦¥æ±‚å­˜Â·ç°å®', consequence: 'åŸè®¡åˆ’ç»§ç»­æ‰§è¡Œï¼Œä½†ç¤¾ä¼šçš„è£‚ç—•å·²æ— æ³•å¼¥åˆ...' } },
          { contextA: 'é£èˆ¹èµ·é£å‰ï¼ŒAIç³»ç»Ÿæ£€æµ‹åˆ°ä¸€ä¸ªæƒŠäººçš„å¯èƒ½æ€§ï¼šå°è¡Œæ˜Ÿçš„è½¨é“å¯ä»¥è¢«äººä¸ºæ”¹å˜ã€‚', contextB: 'å‘å°„å‡†å¤‡å®Œæˆæ—¶ï¼Œå…ˆé”‹é˜Ÿçªç„¶ä¼ æ¥æ¶ˆæ¯ï¼šå¤–æ˜Ÿæ–‡æ˜å¯ä»¥æä¾›æŠ€æœ¯æ‘§æ¯å°è¡Œæ˜Ÿï¼Œä½†éœ€è¦äººç±»æ”¾å¼ƒæ­¦å™¨ã€‚', a: { text: 'å°è¯•æ”¹å˜å°è¡Œæ˜Ÿè½¨é“ï¼Œå³ä½¿å¤±è´¥ä¹Ÿå€¼å¾—ä¸€è¯•ã€‚', tag: 'é€†å¤©æ”¹å‘½Â·è‹±é›„', consequence: 'å…¨æ®–æ°‘åœ°çš„èƒ½æºè¢«é›†ä¸­ç”¨äºè¿™ä¸ªå¤§èƒ†çš„è®¡åˆ’...' }, b: { text: 'æŒ‰åŸè®¡åˆ’æ’¤ç¦»ï¼Œä¸è¦æŠŠæ‰€æœ‰é¸¡è›‹æ”¾åœ¨ä¸€ä¸ªç¯®å­é‡Œã€‚', tag: 'åˆ†æ•£é£é™©Â·è°¨æ…', consequence: 'é£èˆ¹å¼€å§‹æ’¤ç¦»ï¼Œä½†ç•™ä¸‹çš„äººæ²¡æœ‰æ”¾å¼ƒå¸Œæœ›...' } },
          { contextA: 'æ”¹å˜è½¨é“çš„å°è¯•æ¶ˆè€—äº†80%çš„èƒ½æºï¼Œå°è¡Œæ˜Ÿåç§»äº†ï¼Œä½†ä¸å¤Ÿâ€”â€”å®ƒä»ä¼šæ“¦è¿‡åœ°çƒå¤§æ°”å±‚ï¼Œé€ æˆå·¨å¤§ç¾éš¾ã€‚', contextB: 'å¤–æ˜Ÿæ–‡æ˜çš„æŠ€æœ¯ç¡®å®æœ‰æ•ˆï¼Œä½†ä»–ä»¬è¦æ±‚äººç±»å¿…é¡»å…ˆé”€æ¯æ‰€æœ‰æ ¸æ­¦å™¨ä½œä¸º"å…¥ä¼šè´¹"ã€‚', a: { text: 'æ”¾æ‰‹ä¸€æï¼Œç”¨å‰©ä½™èƒ½æºå†æ¨ä¸€æ¬¡ï¼Œè¦ä¹ˆå…¨èµ¢ï¼Œè¦ä¹ˆå…¨è¾“ã€‚', tag: 'èƒŒæ°´ä¸€æˆ˜Â·æé™', ending: 'å¥‡è¿¹å‘ç”Ÿäº†ï¼å°è¡Œæ˜Ÿåœ¨æœ€åä¸€åˆ»åç¦»äº†æ’å‡»è½¨é“ã€‚äººç±»ç”¨å‹‡æ°”å’Œå›¢ç»“æˆ˜èƒœäº†å‘½è¿ï¼Œè¿™ä¸€å¤©è¢«æ°¸è¿œé“­è®°ä¸º"æ–°å¸Œæœ›æ—¥"ã€‚' }, b: { text: 'æ¥å—éƒ¨åˆ†æŸå¤±ï¼Œå¼€å§‹ç¾åé‡å»ºè®¡åˆ’ï¼Œäººç±»å°†æµ´ç«é‡ç”Ÿã€‚', tag: 'åŠ¡å®é¢å¯¹Â·é‡ç”Ÿ', ending: 'å°è¡Œæ˜Ÿæ“¦è¿‡åœ°çƒï¼Œé€ æˆäº†ä¸¥é‡ä½†éæ¯ç­æ€§çš„ç¾éš¾ã€‚å¹¸å­˜çš„äººç±»å¼€å§‹äº†è‰°éš¾çš„é‡å»ºï¼Œä½†ä»–ä»¬çŸ¥é“ï¼Œåªè¦äººç±»è¿˜åœ¨ï¼Œå¸Œæœ›å°±åœ¨ã€‚' } }
        ]
      },
      mystery: {
        name: 'æ‚¬ç–‘æ¨ç†', icon: 'ğŸ”',
        opening: 'æš´é£é›¨ä¹‹å¤œï¼Œå¯Œè±ªé™ˆå®¶çš„å®¶ä¸»é™ˆè€çˆ·åœ¨ä¹¦æˆ¿è¢«äººæ¯’æ€ã€‚å¤§é—¨ä»å†…åé”ï¼Œçª—æˆ·å®Œå¥½æ— æŸã€‚åœ¨åœºçš„æœ‰ï¼šå¤§å„¿å­é™ˆæ˜ã€äºŒå¥³å„¿é™ˆæœˆã€ç®¡å®¶è€å¼ ã€å¥³ä»†å°èŠ³ï¼Œä»¥åŠåˆšåˆ°è®¿çš„ç¥ç§˜å•†äººæå…ˆç”Ÿã€‚',
        rounds: [
          { context: 'è­¦æ–¹å°é”äº†å®…é‚¸ï¼Œæ‰€æœ‰äººéƒ½ä¸èƒ½ç¦»å¼€ã€‚ä½œä¸ºè¢«é‚€è¯·æ¥çš„ä¾¦æ¢ï¼Œä½ å¿…é¡»å¼€å§‹è°ƒæŸ¥ã€‚', a: { text: 'é¦–å…ˆæœæŸ¥æ­»è€…çš„ä¹¦æˆ¿ï¼Œå¯»æ‰¾ç‰©è¯å’Œçº¿ç´¢ã€‚', tag: 'ç‰©è¯ä¼˜å…ˆÂ·ç³»ç»Ÿ', consequence: 'åœ¨ä¹¦æˆ¿å‘ç°äº†ä¸€å°è¢«çƒ§æ¯ä¸€åŠçš„ä¿¡ä»¶ï¼Œéšçº¦å¯è§"èƒŒå›"å’Œ"é—äº§"å­—æ ·...' }, b: { text: 'åˆ†åˆ«è¯¢é—®åœ¨åœºæ¯ä¸ªäººï¼Œè§‚å¯Ÿä»–ä»¬çš„ååº”å’Œæ¼æ´ã€‚', tag: 'å¯Ÿè¨€è§‚è‰²Â·ç›´è§‰', consequence: 'è¯¢é—®ä¸­å‘ç°ç®¡å®¶è€å¼ ç¥è‰²æ…Œå¼ ï¼Œè€Œé™ˆæœˆæåˆ°çˆ¶äº²æœ€è¿‘æ”¶åˆ°è¿‡å¨èƒä¿¡...' } },
          { contextA: 'ä¿¡ä»¶æ˜¾ç¤ºé™ˆè€çˆ·æ›¾æ‰“ç®—æ›´æ”¹é—å˜±ï¼Œå‰¥å¤ºæŸäººçš„ç»§æ‰¿æƒã€‚', contextB: 'è¿›ä¸€æ­¥è°ƒæŸ¥å‘ç°ï¼Œå¨èƒä¿¡æ¥è‡ªä¸€ä¸ªç¥ç§˜ç»„ç»‡ï¼Œè€Œæå…ˆç”Ÿä¼¼ä¹ä¸è¿™ä¸ªç»„ç»‡æœ‰å…³è”ã€‚', a: { text: 'æ·±å…¥è°ƒæŸ¥é—äº§é—®é¢˜ï¼Œè¿½æŸ¥è°æ˜¯è¢«å‰¥å¤ºç»§æ‰¿æƒçš„äººã€‚', tag: 'è¿½è¸ªé‡‘é’±Â·ç°å®', consequenceFromA: 'å‘ç°é™ˆæ˜æ¬ ä¸‹å·¨é¢èµŒå€ºï¼Œè€Œé™ˆæœˆä¸€ç›´åœ¨ç§˜å¯†èµ„åŠ©ä¸€ä¸ªæ…ˆå–„æœºæ„...', consequenceFromB: 'è°ƒæŸ¥æ˜¾ç¤ºé™ˆè€çˆ·æœ€è¿‘è½¬ç§»äº†å¤§ç¬”èµ„äº§ï¼Œä½†å»å‘ä¸æ˜...' }, b: { text: 'è°ƒæŸ¥æå…ˆç”Ÿçš„èº«ä»½å’Œæ¥å†ï¼Œä»–çš„å‡ºç°å¤ªè¿‡å·§åˆã€‚', tag: 'è¿½æŸ¥å¤–äººÂ·æ€€ç–‘', consequenceFromA: 'æå…ˆç”Ÿçš„èº«ä»½è¢«æ­éœ²ï¼šä»–æ˜¯é™ˆè€çˆ·å¤±æ•£å¤šå¹´çš„ç§ç”Ÿå­...', consequenceFromB: 'æå…ˆç”Ÿæ‰¿è®¤è‡ªå·±æ˜¯æ¥è°ˆç”Ÿæ„çš„ï¼Œä½†ä»–å¸¦æ¥äº†ä¸€ä¸ªæƒŠäººçš„ç§˜å¯†...' } },
          { contextAA: 'é™ˆæ˜æœ‰åŠ¨æœºï¼Œä½†ä»–æœ‰ä¸åœ¨åœºè¯æ˜â€”â€”å¥³ä»†å°èŠ³å¯ä»¥ä½œè¯ã€‚', contextAB: 'èµ„äº§è½¬ç§»çš„ç›®çš„åœ°æ˜¯ä¸€ä¸ªæµ·å¤–è´¦æˆ·ï¼Œæˆ·ä¸»åå­—è¢«åŠ å¯†ã€‚', contextBA: 'ç§ç”Ÿå­çš„å‡ºç°æ„å‘³ç€é—äº§å°†è¢«é‡æ–°åˆ†é…ï¼Œæ‰€æœ‰åˆæ³•ç»§æ‰¿äººéƒ½æœ‰äº†åŠ¨æœºã€‚', contextBB: 'æå…ˆç”Ÿé€éœ²é™ˆè€çˆ·ç”Ÿå‰ä¸€ç›´åœ¨è°ƒæŸ¥ä¸€æ¡©é™ˆå¹´æ—§æ¡ˆâ€”â€”ä¸€èµ·è¢«æ©ç›–çš„è°‹æ€ã€‚', a: { text: 'éªŒè¯å°èŠ³çš„è¯è¯ï¼Œå¥¹å¯èƒ½æ˜¯å…³é”®è¯äººï¼Œä¹Ÿå¯èƒ½æ˜¯åŒè°‹ã€‚', tag: 'è´¨ç–‘è¯è¯Â·ç»†è‡´', consequence: 'å‹åŠ›ä¹‹ä¸‹ï¼Œå°èŠ³å´©æºƒäº†ï¼Œæ‰¿è®¤é™ˆæ˜æ›¾å¨èƒå¥¹ä½œä¼ªè¯...' }, b: { text: 'è°ƒæŸ¥é™ˆå¹´æ—§æ¡ˆï¼Œä¹Ÿè®¸è¿‡å»çš„ç§˜å¯†èƒ½æ­ç¤ºç°åœ¨çš„çœŸç›¸ã€‚', tag: 'è¿½æº¯è¿‡å»Â·è€å¿ƒ', consequence: 'æ—§æ¡ˆçš„çº¿ç´¢æŒ‡å‘20å¹´å‰çš„ä¸€åœºç«ç¾ï¼Œé™ˆè€çˆ·çš„åŸé…å¦»å­åœ¨é‚£åœºç«ç¾ä¸­èº«äº¡...' } },
          { contextA: 'ä¼ªè¯è¢«æ­ç©¿åï¼Œé™ˆæ˜çš„ä¸åœ¨åœºè¯æ˜å¤±æ•ˆã€‚ä½†ä»–åšç§°è‡ªå·±æ˜¯æ— è¾œçš„ï¼Œå¹¶æŒ‡æ§é™ˆæœˆæ‰æ˜¯å‡¶æ‰‹ã€‚', contextB: 'è°ƒæŸ¥å‘ç°ï¼Œé‚£åœºç«ç¾å¹¶éæ„å¤–ï¼Œè€Œæ˜¯äººä¸ºçºµç«ã€‚æ›´æƒŠäººçš„æ˜¯ï¼Œé™ˆè€çˆ·å¯èƒ½çŸ¥é“çœŸå‡¶æ˜¯è°ã€‚', a: { text: 'å¯¹é™ˆæ˜å’Œé™ˆæœˆè¿›è¡Œäº¤å‰å®¡é—®ï¼Œæ‰¾å‡ºè°åœ¨è¯´è°ã€‚', tag: 'æ­£é¢å¯¹è´¨Â·æ¿€çƒˆ', consequence: 'å®¡é—®ä¸­ï¼Œä¸€ä¸ªæƒŠå¤©ç§˜å¯†è¢«æ­å¼€ï¼šé™ˆæœˆä¸æ˜¯é™ˆè€çˆ·çš„äº²ç”Ÿå¥³å„¿...' }, b: { text: 'é‡æ–°æ£€éªŒæ¯’è¯æ¥æºï¼Œå‡¶å™¨å¾€å¾€èƒ½æŒ‡å‘çœŸå‡¶ã€‚', tag: 'ç§‘å­¦åˆ†æÂ·ä¸¥è°¨', consequence: 'æ¯’è¯æˆåˆ†åˆ†ææ˜¾ç¤ºï¼Œè¿™ç§æ¯’è¯åªèƒ½ä»ä¸€ç§ç¨€æœ‰æ¤ç‰©ä¸­æå–ï¼Œè€Œç®¡å®¶è€å¼ çš„æˆ¿é—´é‡Œç§ç€è¿™ç§æ¤ç‰©...' } },
          { contextA: 'é™ˆæœˆçš„èº«ä¸–ç§˜å¯†æ­å¼€åï¼ŒçœŸç›¸é€æ¸æµ®å‡ºæ°´é¢ï¼šå¥¹æ˜¯20å¹´å‰ç«ç¾ä¸­"æ­»å»"çš„é‚£ä¸ªäººçš„å¥³å„¿ï¼Œè¢«é™ˆè€çˆ·ç§˜å¯†æ”¶å…»ã€‚', contextB: 'æ‰€æœ‰è¯æ®éƒ½æŒ‡å‘ç®¡å®¶è€å¼ ï¼Œä½†ä»–åœ¨è¢«å®¡é—®æ—¶çªç„¶å¿ƒè„ç—…å‘ä½œï¼Œç•™ä¸‹ä¸€å¥è¯ï¼š"çœŸç›¸...åœ¨èŠ±å›­çš„è€æ§æ ‘ä¸‹..."', a: { text: 'å…¬å¼€æ‰€æœ‰çœŸç›¸ï¼Œè®©æ³•å¾‹æ¥è£å†³ï¼Œæ— è®ºç»“æœå¦‚ä½•ã€‚', tag: 'å…¬æ­£å®¡åˆ¤Â·æ³•æ²»', ending: 'çœŸç›¸å¤§ç™½ï¼šç®¡å®¶è€å¼ æ˜¯20å¹´å‰é™ˆè€çˆ·åŸé…çš„æƒ…äººï¼Œç«ç¾æ˜¯ä»–ä»¬ä¸€èµ·ç­–åˆ’çš„ã€‚é™ˆè€çˆ·å‘ç°çœŸç›¸åæ‰“ç®—æ­å‘ä»–ï¼Œäºæ˜¯è€å¼ ç—›ä¸‹æ€æ‰‹ã€‚é™ˆæœˆå¾—çŸ¥è‡ªå·±çš„èº«ä¸–åé€‰æ‹©åŸè°…ï¼Œå¹¶ç”¨ç»§æ‰¿çš„é—äº§æˆç«‹äº†åŸºé‡‘ä¼šï¼Œå¸®åŠ©é‚£äº›åƒå¥¹ä¸€æ ·å¤±å»å®¶åº­çš„å­©å­ã€‚' }, b: { text: 'ç»™äºˆç›¸å…³äººä¸€ä¸ªé€‰æ‹©çš„æœºä¼šï¼Œæœ‰äº›çœŸç›¸ä¹Ÿè®¸ä¸è¯¥è¢«å…¬å¼€ã€‚', tag: 'äººæƒ…è€ƒé‡Â·ç°è‰²', ending: 'ä½ é€‰æ‹©äº†ä¸€ä¸ªæŠ˜ä¸­çš„æ–¹æ¡ˆï¼šè€å¼ çš„ç½ªè¡Œè¢«ä½è°ƒå¤„ç†ï¼Œå¯¹å¤–å®£å¸ƒé™ˆè€çˆ·æ­»äºæ„å¤–ã€‚é™ˆæ˜æˆ’æ‰äº†èµŒåšï¼Œé™ˆæœˆç»§ç»­å¥¹çš„æ…ˆå–„äº‹ä¸šï¼Œæå…ˆç”Ÿå¸¦ç€çˆ¶äº²çš„é—ç‰©ç¦»å¼€ã€‚æœ‰äº›çœŸç›¸è¢«æ°¸è¿œåŸ‹è‘¬ï¼Œä½†æ´»ç€çš„äººéƒ½æœ‰äº†æ–°çš„å¼€å§‹ã€‚' } }
        ]
      },
      political: {
        name: 'å®«å»·æƒè°‹', icon: 'ğŸ‘‘',
        opening: 'å¤§é½ç‹æœï¼Œæ°¸å®‰ä¸‰åå¹´ã€‚è€çš‡å¸é©¾å´©çš„æ¶ˆæ¯éœ‡æƒŠæœé‡ã€‚é—è¯ä¸­å´å‡ºç°äº†ä»¤äººè´¹è§£çš„å†…å®¹ï¼šçš‡ä½ä¸ä¼ ç»™ä¸‰ä½æˆå¹´çš‡å­ä¸­çš„ä»»ä½•ä¸€ä¸ªï¼Œè€Œæ˜¯ç”±"æœ€èƒ½ä»£è¡¨æ°‘å¿ƒè€…"ç»§æ‰¿ã€‚ä¸€æ—¶é—´ï¼Œæœå ‚æš—æµæ¶ŒåŠ¨...',
        rounds: [
          { context: 'ä½œä¸ºå…ˆå¸ä¿¡ä»»çš„å†…é˜é¦–è¾…ï¼Œä½ å¿…é¡»åœ¨æ··ä¹±ä¸­ç»´æŒå±€é¢ã€‚ä¸‰ä½çš‡å­å„æœ‰æ”¯æŒè€…ï¼šå¤ªå­ä»åšä½†æ‡¦å¼±ï¼ŒäºŒçš‡å­ç²¾æ˜ä½†æ®‹å¿ï¼Œä¸‰çš‡å­å¹´è½»ä½†é”æ„æ”¹é©ã€‚', a: { text: 'æ”¯æŒå¤ªå­æŒ‰ä¼ ç»Ÿç»§ä½ï¼Œç»´æŠ¤å«¡é•¿å­ç»§æ‰¿åˆ¶åº¦çš„ç¨³å®šã€‚', tag: 'ä¼ ç»Ÿæ­£ç»ŸÂ·ä¿å®ˆ', consequence: 'å¤ªå­è·å¾—ä½ çš„æ”¯æŒåä¿¡å¿ƒå¤§å¢ï¼Œä½†äºŒçš‡å­çš„æ”¯æŒè€…å¼€å§‹æš—ä¸­è”ç»œå†›æ–¹...' }, b: { text: 'æè®®ä¸‰ä½çš‡å­å„é™ˆæ–½æ”¿çº²é¢†ï¼Œç”±ç™¾å®˜å…¬è®®å†³å®šäººé€‰ã€‚', tag: 'å…¬è®®å†³é€‰Â·é©æ–°', consequence: 'è¿™ä¸ªæè®®å¼•å‘è½©ç„¶å¤§æ³¢ï¼Œæ”¹é©æ´¾æ¬¢å‘¼ï¼Œä¿å®ˆæ´¾å¼ºçƒˆåå¯¹...' } },
          { contextA: 'äºŒçš‡å­å‹¾ç»“è¾¹ç–†å°†å†›ï¼Œå¯†è°‹èµ·å…µ"æ¸…å›ä¾§"ï¼Œå±€åŠ¿éª¤ç„¶ç´§å¼ ã€‚', contextB: 'å…¬è®®ä¹‹å‰ï¼Œæœ‰äººæ­å‘ä¸‰çš‡å­ä¸å¤–é‚¦ä½¿èŠ‚æœ‰ç§˜å¯†å¾€æ¥ï¼Œæ¶‰å«Œå›å›½ã€‚', a: { text: 'ç´§æ€¥è°ƒåŠ¨å¾¡æ—å†›å¸ƒé˜²ï¼ŒåŒæ—¶æ´¾å¯†ä½¿åˆ†åŒ–äºŒçš‡å­çš„åŒç›Ÿã€‚', tag: 'åˆ†åŒ–ç“¦è§£Â·æƒè°‹', consequenceFromA: 'ä½ çš„è®¡ç­–æˆåŠŸæ‹–å»¶äº†äºŒçš‡å­çš„è¡ŒåŠ¨ï¼Œä½†ä»–å¼€å§‹æ€€ç–‘å†…éƒ¨æœ‰äººèƒŒå›...', consequenceFromB: 'ä½ åˆ©ç”¨è¿™ä¸ªæœºä¼šæ‰“å‹ä¸‰çš‡å­ï¼Œä½†è°ƒæŸ¥æ˜¾ç¤ºæ­å‘ä¿¡å¯èƒ½æ˜¯ä¼ªé€ çš„...' }, b: { text: 'ä¸»åŠ¨æ‰¾äºŒçš‡å­è°ˆåˆ¤ï¼Œäº†è§£ä»–çš„è¯‰æ±‚ï¼Œå¯»æ‰¾å’Œå¹³è§£å†³çš„å¯èƒ½ã€‚', tag: 'å’Œè°ˆæ­¢å…µÂ·å†’é™©', consequenceFromA: 'äºŒçš‡å­æå‡ºæ¡ä»¶ï¼šä»–è¦å¤ªå­çš„ä½ç½®ï¼Œä½†æ‰¿è¯ºå–„å¾…å…„å¼Ÿ...', consequenceFromB: 'æ­å‘äº‹ä»¶ä½¿ä¸‰çš‡å­é™·å…¥å›°å¢ƒï¼Œä½ å†³å®šäº²è‡ªè°ƒæŸ¥çœŸç›¸...' } },
          { contextAA: 'äºŒçš‡å­çš„ç›Ÿå‹è¢«æˆåŠŸç­–åï¼Œä½†å¯¹æ–¹è¦æ±‚äº‹æˆä¹‹åå°ä¾¯æ‹œç›¸ã€‚', contextAB: 'è°ƒæŸ¥æ˜¾ç¤ºæ­å‘ä¿¡å‡ºè‡ªå¤ªåçš„äº²ä¿¡ï¼Œç›®çš„æ˜¯æ‰¶æŒå¥¹çš„å¤–ç”¥ä¸Šä½ã€‚', contextBA: 'äºŒçš‡å­çš„æ¡ä»¶ä»¤äººéš¾ä»¥æ¥å—ï¼Œä½†ä»–æ‰‹æ¡é‡å…µï¼Œæ‹’ç»å¯èƒ½å¯¼è‡´å†…æˆ˜ã€‚', contextBB: 'å¤ªåå¼€å§‹å…¬å¼€å¹²æ”¿ï¼Œä»¥å…ˆå¸é—å­€çš„èº«ä»½è¦æ±‚"å‚å¸˜å¬æ”¿"ã€‚', a: { text: 'ç­”åº”å°ä¾¯çš„æ¡ä»¶ï¼Œä¸¤å®³ç›¸æƒå–å…¶è½»ï¼Œå…ˆç¨³ä½å±€é¢ã€‚', tag: 'æƒå®œä¹‹è®¡Â·å¦¥å', consequence: 'å±€åŠ¿æš‚æ—¶ç¨³å®šï¼Œä½†ä½ çŸ¥é“è¿™åªæ˜¯å¼€å§‹ï¼Œæ›´å¤§çš„é£æš´è¿˜åœ¨åé¢...' }, b: { text: 'æ­éœ²å¤ªåçš„é˜´è°‹ï¼Œè”åˆä¸‰ä½çš‡å­å…±åŒå¯¹æŠ—å¤–æˆšä¸“æƒã€‚', tag: 'å›¢ç»“æŠ—æ•ŒÂ·æ­£ä¹‰', consequence: 'ä½ çš„æ­éœ²è®©æœå ‚éœ‡åŠ¨ï¼Œä¸‰ä½çš‡å­ç ´å¤©è’åœ°ç«™åœ¨äº†ä¸€èµ·...' } },
          { contextA: 'å„æ–¹åŠ¿åŠ›æš‚æ—¶å¹³è¡¡ï¼Œä½†å‚¨ä½ä¹‹äº‰ä»æ‚¬è€Œæœªå†³ã€‚è¿™æ—¶è¾¹ç–†ä¼ æ¥æ€¥æŠ¥ï¼šåŒ—æ–¹æ¸¸ç‰§æ°‘æ—å¤§å†›å‹å¢ƒã€‚', contextB: 'å¤ªåè¢«è½¯ç¦ï¼Œå¤–æˆšåŠ¿åŠ›ç“¦è§£ã€‚ä½†åœ¨æ•´ç†å¤ªåå¯å®«æ—¶ï¼Œå‘ç°äº†å…ˆå¸çš„å¦ä¸€ä»½é—è¯...', a: { text: 'å»ºè®®ä¸‰ä½çš‡å­äº²å¾åŒ—ç–†ï¼Œè°èƒ½å‡»é€€æ•Œå†›è°å°±æ˜¯æ–°å¸ã€‚', tag: 'ä»¥æˆ˜å®šå¸Â·é­„åŠ›', consequence: 'ä¸‰ä½çš‡å­ç‡å†›åŒ—ä¸Šï¼Œè¿™åœºæˆ˜äº‰å°†å†³å®šå¤§é½çš„æœªæ¥...' }, b: { text: 'æè®®å…ˆé€‰å‡ºæ–°å¸å†åº”å¯¹å¤–æ•Œï¼Œå›½ä¸å¯ä¸€æ—¥æ— å›ã€‚', tag: 'å…ˆå†…åå¤–Â·ç¨³é‡', consequence: 'åœ¨ä½ çš„ä¸»æŒä¸‹ï¼Œä¸€åœºå†³å®šæ€§çš„æœè®®å³å°†å¼€å§‹...' } },
          { contextA: 'åŒ—ç–†æˆ˜äº‹èƒ¶ç€ï¼Œå¤ªå­ä»å¾·æŠšæ°‘ï¼ŒäºŒçš‡å­å‹‡çŒ›ä½œæˆ˜ï¼Œä¸‰çš‡å­åå‹¤è°ƒåº¦æœ‰æ–¹ã€‚ä¸‰äººå„æœ‰åŠŸåŠ³ï¼Œéš¾åˆ†é«˜ä¸‹ã€‚', contextB: 'å…ˆå¸çš„çœŸæ­£é—è¯è¢«æ‰¾åˆ°ï¼Œä¸Šé¢å†™ç€ï¼šçš‡ä½ä¼ ç»™"èƒ½è®©ä¸‰ä¸ªå„¿å­å’Œç¦å…±å¤„è€…"ã€‚è¿™ä¸ªäºº...ç«Ÿç„¶æ˜¯ä½ ã€‚', a: { text: 'å»ºè®®ä¸‰ä½çš‡å­å…±åŒæ‰§æ”¿ï¼Œå»ºç«‹"ä¸‰ç‹è®®æ”¿"çš„æ–°åˆ¶åº¦ã€‚', tag: 'æƒåŠ›å…±äº«Â·å¼€åˆ›', ending: 'å¤§é½ç‹æœè¿›å…¥äº†å‰æ‰€æœªæœ‰çš„"ä¸‰ç‹æ—¶ä»£"ã€‚å¤ªå­ä¸»å†…æ”¿ï¼ŒäºŒçš‡å­æŒå†›äº‹ï¼Œä¸‰çš‡å­è´Ÿè´£æ”¹é©ã€‚è™½ç„¶äº‰åµä¸æ–­ï¼Œä½†åœ¨ä½ çš„è°ƒå’Œä¸‹ï¼Œè¿™ä¸ªåˆ¶åº¦ç«Ÿç„¶è¿è½¬äº†èµ·æ¥ã€‚' }, b: { text: 'æŒ‰å†›åŠŸå¤§å°æ’åºï¼Œç”±åŠŸåŠ³æœ€å¤§è€…ç»§æ‰¿çš‡ä½ã€‚', tag: 'åŠŸå‹‹å®šä½Â·å…¬å¹³', ending: 'äºŒçš‡å­å‡­å€Ÿæˆ˜åŠŸç™»åŸºï¼Œä½†ä»–æ²¡æœ‰è¾œè´Ÿä¿¡ä»»ã€‚åœ¨ä½æœŸé—´åŒ—å‡»æ¸¸ç‰§ã€å†…ä¿®æ”¿æ²»ï¼Œå¤§é½è¿æ¥äº†ä¸­å…´ã€‚' } }
        ]
      }
    };

    const AI_PLAYERS = [
      { id: 'ai_1', name: 'æ™ºè€…Â·è‰¾ä¸', avatar: 'ğŸ§™â€â™€ï¸', exp: 1200, isAI: true, style: 'analytical' },
      { id: 'ai_2', name: 'å‹‡è€…Â·å‡¯æ©', avatar: 'âš”ï¸', exp: 1100, isAI: true, style: 'bold' },
      { id: 'ai_3', name: 'å­¦è€…Â·è¯ºäºš', avatar: 'ğŸ“š', exp: 1300, isAI: true, style: 'cautious' },
    ];

    const generateAIDebate = (style) => {
      const debates = {
        analytical: { A: ['ä»é€»è¾‘ä¸Šåˆ†æï¼Œé€‰é¡¹Açš„æˆåŠŸç‡æ›´é«˜', 'ç†æ€§æ€è€ƒï¼ŒAæ˜¯æœ€ä¼˜è§£'], B: ['ä»”ç»†åˆ†æåï¼ŒBçš„é•¿æœŸæ”¶ç›Šæ›´å¤§', 'ç»¼åˆè€ƒé‡ï¼ŒBæ˜¯æ›´ç¨³å¦¥çš„æ–¹æ¡ˆ'] },
        bold: { A: ['å‹‡è€…ä¸æƒ§ï¼Aæ‰æ˜¯çœŸæ­£çš„è‹±é›„ä¹‹é€‰', 'æœæ–­å‡ºå‡»ï¼æ”¯æŒAï¼'], B: ['Bæ‰æ˜¯çœŸæ­£çš„å‹‡æ°”ï¼', 'æ™ºå‹‡åŒå…¨æ‰æ˜¯çœŸè‹±é›„ï¼Œé€‰Bï¼'] },
        cautious: { A: ['è™½ç„¶å†’é™©ï¼Œä½†Aæˆ–è®¸æ˜¯å¿…è¦çš„', 'ä¸¤å®³ç›¸æƒå–å…¶è½»ï¼Œæ”¯æŒA'], B: ['è°¨æ…èµ·è§ï¼ŒBæ›´å®‰å…¨', 'ç•™å¾—é’å±±åœ¨ï¼Œé€‰Bæ›´æ˜æ™º'] },
      };
      const choice = Math.random() > 0.5 ? 'A' : 'B';
      const options = debates[style]?.[choice] || debates.analytical[choice];
      return { text: options[Math.floor(Math.random() * options.length)], choice };
    };

    const msgpack = {
      encode: (obj) => {
        const encodeValue = (val) => {
          if (val === null) return [0xc0];
          if (typeof val === 'string') {
            const bytes = new TextEncoder().encode(val);
            if (bytes.length <= 31) return [0xa0 | bytes.length, ...bytes];
            return [0xd9, bytes.length, ...bytes];
          }
          if (Array.isArray(val)) {
            let result = [0x90 | val.length];
            val.forEach(item => result.push(...encodeValue(item)));
            return result;
          }
          return [0xc0];
        };
        return new Uint8Array(encodeValue(obj));
      }
    };

    function App() {
      const [db, setDb] = useState(null);
      const [walletAddress, setWalletAddress] = useState(null);
      const [walletConnecting, setWalletConnecting] = useState(false);
      const [view, setView] = useState('home');
      const [player, setPlayer] = useState({ id: '', name: '', avatar: 'ğŸ®', exp: 1000 });
      const [roomId, setRoomId] = useState(null);
      const [roomData, setRoomData] = useState(null);
      const [players, setPlayers] = useState([]);
      const [gameState, setGameState] = useState(null);
      const [messages, setMessages] = useState([]);
      const [availableRooms, setAvailableRooms] = useState([]);
      const [debateInput, setDebateInput] = useState('');
      const [myVote, setMyVote] = useState(null);
      const [timer, setTimer] = useState(0);
      const [leaderboard, setLeaderboard] = useState([]);
      const timerRef = useRef(null);
      const messagesEndRef = useRef(null);

      useEffect(() => {
        try {
          if (!firebase.apps.length) firebase.initializeApp(CONFIG.FIREBASE);
          setDb(firebase.database());
        } catch (err) { console.error('Firebase init error:', err); }
        try {
          const saved = localStorage.getItem('consensus_leaderboard');
          if (saved) setLeaderboard(JSON.parse(saved));
        } catch {}
        return () => { if (timerRef.current) clearInterval(timerRef.current); };
      }, []);

      useEffect(() => {
        if (!db) return;
        const roomsRef = db.ref('rooms');
        roomsRef.on('value', (snapshot) => {
          const data = snapshot.val();
          if (data) {
            setAvailableRooms(Object.entries(data).filter(([_, r]) => r.status === 'waiting').map(([id, r]) => ({ id, ...r })));
          } else { setAvailableRooms([]); }
        });
      }, [db]);

      useEffect(() => {
        if (!db || !roomId) return;
        db.ref(`rooms/${roomId}`).on('value', (s) => {
          const d = s.val();
          if (d) { setRoomData(d); if (d.players) setPlayers(Object.values(d.players)); }
        });
        db.ref(`games/${roomId}`).on('value', (s) => {
          const d = s.val();
          if (d) {
            setGameState(d);
            if (d.messages) setMessages(Object.values(d.messages).sort((a, b) => a.timestamp - b.timestamp));
            if (d.timerEnd && d.phase !== 'ended') setTimer(Math.max(0, Math.floor((d.timerEnd - Date.now()) / 1000)));
          }
        });
      }, [db, roomId]);

      useEffect(() => {
        if (!gameState?.timerEnd || gameState?.phase === 'ended') return;
        if (timerRef.current) clearInterval(timerRef.current);
        timerRef.current = setInterval(() => {
          const remaining = Math.max(0, Math.floor((gameState.timerEnd - Date.now()) / 1000));
          setTimer(remaining);
          if (remaining <= 0 && player.id === roomData?.host) handlePhaseEnd();
        }, 1000);
        return () => { if (timerRef.current) clearInterval(timerRef.current); };
      }, [gameState?.timerEnd, gameState?.phase]);

      useEffect(() => { messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' }); }, [messages]);

      const connectWallet = async () => {
        if (!window.ethereum) { alert('è¯·å®‰è£…MetaMaské’±åŒ…'); return null; }
        setWalletConnecting(true);
        try {
          const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
          setWalletAddress(accounts[0]);
          setPlayer(p => ({ ...p, id: accounts[0] }));
          return accounts[0];
        } catch (err) { alert('é’±åŒ…è¿æ¥å¤±è´¥: ' + err.message); return null; }
        finally { setWalletConnecting(false); }
      };

      const payEntryFee = async () => {
        if (!window.ethereum || !walletAddress) { alert('è¯·å…ˆè¿æ¥é’±åŒ…'); return false; }
        try {
          const calldata = msgpack.encode(['pay_entry_fee', []]);
          const calldataHex = '0x' + Array.from(calldata).map(b => b.toString(16).padStart(2, '0')).join('');
          await window.ethereum.request({
            method: 'eth_sendTransaction',
            params: [{ from: walletAddress, to: CONFIG.GENLAYER_CONTRACT, data: calldataHex, value: '0x' + (BigInt(Math.floor(parseFloat(CONFIG.ENTRY_FEE) * 1e18))).toString(16) }]
          });
          return true;
        } catch (err) { alert('æ”¯ä»˜å¤±è´¥: ' + err.message); return false; }
      };

      const recordGameEnd = async (gameData) => {
        if (!walletAddress) return;
        try {
          const calldata = msgpack.encode(['record_game', [roomId, gameData.theme, gameData.winner || walletAddress, gameData.path?.join('') || '', Math.floor(Date.now() / 1000), players.length]]);
          const calldataHex = '0x' + Array.from(calldata).map(b => b.toString(16).padStart(2, '0')).join('');
          await window.ethereum.request({ method: 'eth_sendTransaction', params: [{ from: walletAddress, to: CONFIG.GENLAYER_CONTRACT, data: calldataHex }] });
        } catch (err) { console.error('Record game error:', err); }
      };

      const createRoom = async (theme) => {
        if (!db || !player.name) return;
        let address = walletAddress || await connectWallet();
        if (!address) return;
        if (!await payEntryFee()) return;
        const newRoomId = `room_${Date.now()}`;
        await db.ref(`rooms/${newRoomId}`).set({ theme, host: address, status: 'waiting', createdAt: Date.now(), players: { [address]: { id: address, name: player.name, avatar: player.avatar, exp: player.exp, isAI: false } } });
        setRoomId(newRoomId);
        setView('room');
        setTimeout(() => addAIPlayers(newRoomId), 1500);
      };

      const joinRoom = async (targetRoomId) => {
        if (!db || !player.name) return;
        let address = walletAddress || await connectWallet();
        if (!address) return;
        if (!await payEntryFee()) return;
        await db.ref(`rooms/${targetRoomId}/players/${address}`).set({ id: address, name: player.name, avatar: player.avatar, exp: player.exp, isAI: false });
        setRoomId(targetRoomId);
        setView('room');
      };

      const addAIPlayers = async (targetRoomId) => {
        if (!db) return;
        for (let ai of AI_PLAYERS) {
          await new Promise(r => setTimeout(r, 1000 + Math.random() * 1500));
          await db.ref(`rooms/${targetRoomId}/players/${ai.id}`).set(ai);
          addMessage('system', `${ai.avatar} ${ai.name} åŠ å…¥äº†æˆ¿é—´`);
        }
      };

      const startGame = async () => {
        if (!db || !roomId || players.length < CONFIG.ROOM_SIZE.min) return;
        await db.ref(`rooms/${roomId}`).update({ status: 'playing' });
        const theme = roomData?.theme || 'fantasy';
        const arc = STORY_ARCS[theme];
        const initScores = {};
        players.forEach(p => { initScores[p.id] = { influence: 0, debates: 0, wins: 0 }; });
        await db.ref(`games/${roomId}`).set({ round: 1, phase: 'debate', path: [], scores: initScores, votes: {}, story: [{ text: arc.opening, type: 'opening', round: 0 }], timerEnd: Date.now() + CONFIG.DEBATE_DURATION * 1000, messages: {} });
        setView('game');
        addMessage('system', `ğŸ“– ${arc.name}å¼€å§‹äº†ï¼ç¬¬ 1/${CONFIG.TOTAL_ROUNDS} è½® - è¾©è®ºé˜¶æ®µ`);
        setTimeout(() => simulateAIDebate(), 3000);
      };

      const simulateAIDebate = () => {
        players.filter(p => p.isAI).forEach((ai, i) => {
          setTimeout(() => {
            const debate = generateAIDebate(ai.style);
            addMessage('chat', debate.text, ai, debate.choice);
          }, (i + 1) * 3000 + Math.random() * 5000);
        });
      };

      const handlePhaseEnd = async () => {
        if (!db || !roomId || !gameState) return;
        if (gameState.phase === 'debate') {
          await db.ref(`games/${roomId}`).update({ phase: 'vote', timerEnd: Date.now() + CONFIG.VOTE_DURATION * 1000, votes: {} });
          addMessage('system', 'ğŸ—³ï¸ æŠ•ç¥¨é˜¶æ®µå¼€å§‹ï¼');
          setMyVote(null);
          players.filter(p => p.isAI).forEach((ai, i) => {
            setTimeout(async () => { await db.ref(`games/${roomId}/votes/${ai.id}`).set(Math.random() > 0.5 ? 'A' : 'B'); }, (i + 1) * 2000);
          });
        } else if (gameState.phase === 'vote') {
          await calculateResult();
        }
      };

      const calculateResult = async () => {
        if (!db || !roomId || !gameState) return;
        const votes = gameState.votes || {};
        const voteCount = { A: 0, B: 0 };
        Object.values(votes).forEach(v => { if (v) voteCount[v]++; });
        const winner = voteCount.A >= voteCount.B ? 'A' : 'B';
        const newScores = { ...gameState.scores };
        Object.entries(votes).forEach(([id, v]) => { if (v === winner && newScores[id]) { newScores[id].influence = (newScores[id].influence || 0) + 30; newScores[id].wins = (newScores[id].wins || 0) + 1; } });
        const newPath = [...(gameState.path || []), winner];
        const round = gameState.round;
        const consequence = getConsequence(round, winner, gameState.path || []);
        const winOpt = getOption(round, winner);
        const newStory = [...(gameState.story || []), { text: `ã€ä¼—äººé€‰æ‹©ã€‘${winOpt?.text}`, type: 'choice', round, winner }, { text: consequence, type: 'consequence', round }];
        addMessage('system', `ğŸ“œ é€‰é¡¹ ${winner} è·èƒœï¼(${voteCount[winner]}ç¥¨ vs ${voteCount[winner === 'A' ? 'B' : 'A']}ç¥¨)`);
        if (round >= CONFIG.TOTAL_ROUNDS) {
          await db.ref(`games/${roomId}`).update({ phase: 'ended', scores: newScores, path: newPath, story: newStory, timerEnd: null });
          addMessage('system', 'ğŸ† ç¼–å¹´å²å®Œæˆï¼');
          const topPlayer = Object.entries(newScores).sort((a, b) => (b[1].influence + b[1].debates) - (a[1].influence + a[1].debates))[0];
          await recordGameEnd({ theme: roomData?.theme, winner: topPlayer?.[0], path: newPath });
          const myScore = newScores[player.id] || { influence: 0, debates: 0 };
          const totalScore = (myScore.influence || 0) + (myScore.debates || 0);
          if (player.name && totalScore > 0) {
            const newLeaderboard = [...leaderboard, { id: Date.now(), name: player.name, avatar: player.avatar, score: totalScore, theme: roomData?.theme, date: new Date().toLocaleDateString() }].sort((a, b) => b.score - a.score).slice(0, 50);
            setLeaderboard(newLeaderboard);
            try { localStorage.setItem('consensus_leaderboard', JSON.stringify(newLeaderboard)); } catch {}
          }
        } else {
          const nextRound = round + 1;
          const nextContext = getContext(nextRound, newPath);
          await db.ref(`games/${roomId}`).update({ round: nextRound, phase: 'debate', scores: newScores, path: newPath, story: [...newStory, { text: nextContext, type: 'context', round: nextRound }], timerEnd: Date.now() + CONFIG.DEBATE_DURATION * 1000, votes: {} });
          addMessage('system', `ğŸ“– ç¬¬ ${nextRound}/${CONFIG.TOTAL_ROUNDS} è½® - è¾©è®ºé˜¶æ®µ`);
          setTimeout(() => simulateAIDebate(), 3000);
        }
      };

      const getContext = (roundNum, path) => {
        const theme = roomData?.theme || 'fantasy';
        const roundData = STORY_ARCS[theme]?.rounds[roundNum - 1];
        if (!roundData) return '';
        if (roundNum > 1 && path.length > 0) {
          const pathKey = path.slice(-2).join('');
          if (roundData[`context${pathKey}`]) return roundData[`context${pathKey}`];
          if (roundData[`context${path[path.length - 1]}`]) return roundData[`context${path[path.length - 1]}`];
        }
        return roundData.context || '';
      };

      const getOption = (roundNum, choice) => {
        const roundData = STORY_ARCS[roomData?.theme || 'fantasy']?.rounds[roundNum - 1];
        return choice === 'A' ? roundData?.a : roundData?.b;
      };

      const getConsequence = (roundNum, choice, path) => {
        const roundData = STORY_ARCS[roomData?.theme || 'fantasy']?.rounds[roundNum - 1];
        if (!roundData) return '';
        const option = choice === 'A' ? roundData.a : roundData.b;
        if (path.length > 0 && option[`consequenceFrom${path[path.length - 1]}`]) return option[`consequenceFrom${path[path.length - 1]}`];
        if (roundNum === CONFIG.TOTAL_ROUNDS && option.ending) return option.ending;
        return option.consequence || '';
      };

      const getCurrentOptions = () => {
        if (!gameState || !roomData) return { a: null, b: null };
        const roundData = STORY_ARCS[roomData.theme || 'fantasy']?.rounds[(gameState.round || 1) - 1];
        return { a: roundData?.a, b: roundData?.b };
      };

      const addMessage = async (type, text, sender = null, choice = null) => {
        if (!db || !roomId) return;
        await db.ref(`games/${roomId}/messages`).push().set({ type, text, sender, choice, timestamp: Date.now() });
      };

      const submitDebate = async () => {
        if (!debateInput.trim() || gameState?.phase !== 'debate') return;
        const choice = debateInput.includes('A') ? 'A' : debateInput.includes('B') ? 'B' : null;
        await addMessage('chat', debateInput, { id: player.id, name: player.name, avatar: player.avatar }, choice);
        setDebateInput('');
        if (gameState?.scores?.[player.id]) await db.ref(`games/${roomId}/scores/${player.id}/debates`).set((gameState.scores[player.id].debates || 0) + 10);
      };

      const submitVote = async (choice) => {
        if (gameState?.phase !== 'vote' || myVote) return;
        setMyVote(choice);
        await db.ref(`games/${roomId}/votes/${player.id}`).set(choice);
      };

      const resetGame = () => {
        if (timerRef.current) clearInterval(timerRef.current);
        setRoomId(null); setRoomData(null); setGameState(null); setPlayers([]); setMessages([]); setMyVote(null); setView('home');
      };

      const formatTime = (s) => `${Math.floor(s / 60)}:${(s % 60).toString().padStart(2, '0')}`;
      const shortAddress = (addr) => addr ? `${addr.slice(0, 6)}...${addr.slice(-4)}` : '';

      // HOME
      if (view === 'home') {
        return (
          <div style={{ minHeight: '100vh', background: 'linear-gradient(135deg, #0f0f1a 0%, #1a1a2e 50%, #16213e 100%)', padding: '2rem', color: '#e8e8e8' }}>
            <div style={{ maxWidth: '900px', margin: '0 auto' }}>
              <div style={{ textAlign: 'center', marginBottom: '2rem' }}>
                <div style={{ fontSize: '4rem', marginBottom: '0.5rem' }}>ğŸ“œ</div>
                <h1 style={{ fontSize: '2.5rem', fontWeight: 800, background: 'linear-gradient(135deg, #a78bfa, #f472b6)', WebkitBackgroundClip: 'text', WebkitTextFillColor: 'transparent' }}>å…±è¯†ç¼–å¹´å²</h1>
                <p style={{ color: '#8b8b9e', letterSpacing: '0.2em' }}>CONSENSUS CHRONICLE</p>
              </div>
              
              <div style={{ textAlign: 'center', marginBottom: '1.5rem' }}>
                {walletAddress ? (
                  <span style={{ padding: '0.5rem 1rem', background: 'rgba(74,222,128,0.2)', borderRadius: '20px', border: '1px solid rgba(74,222,128,0.4)', color: '#4ade80' }}>ğŸ”— {shortAddress(walletAddress)}</span>
                ) : (
                  <button onClick={connectWallet} disabled={walletConnecting} style={{ padding: '0.8rem 2rem', background: 'linear-gradient(135deg, #f472b6, #a78bfa)', border: 'none', borderRadius: '25px', color: '#fff', fontSize: '1rem', fontWeight: 600, cursor: 'pointer' }}>{walletConnecting ? 'è¿æ¥ä¸­...' : 'ğŸ¦Š è¿æ¥MetaMask'}</button>
                )}
              </div>
              
              {!player.name ? (
                <div style={{ maxWidth: '350px', margin: '0 auto' }}>
                  <input type="text" placeholder="è¾“å…¥ä½ çš„åå­—..." style={{ width: '100%', padding: '1rem', fontSize: '1.1rem', background: 'rgba(255,255,255,0.05)', border: '2px solid rgba(167,139,250,0.3)', borderRadius: '12px', color: '#fff', outline: 'none' }} onKeyDown={(e) => e.key === 'Enter' && e.target.value.trim() && setPlayer(p => ({ ...p, name: e.target.value.trim() }))} />
                  <p style={{ marginTop: '0.5rem', color: '#6b6b7e', fontSize: '0.9rem', textAlign: 'center' }}>æŒ‰ Enter ç¡®è®¤</p>
                </div>
              ) : (
                <>
                  <div style={{ textAlign: 'center', marginBottom: '1.5rem' }}>
                    <span style={{ padding: '0.8rem 1.5rem', background: 'rgba(167,139,250,0.1)', borderRadius: '30px', border: '1px solid rgba(167,139,250,0.3)' }}>
                      <span style={{ fontSize: '1.5rem', marginRight: '0.5rem' }}>{player.avatar}</span>
                      <span style={{ fontWeight: 600 }}>{player.name}</span>
                      <span style={{ color: '#fbbf24', marginLeft: '1rem' }}>â­ {player.exp}</span>
                    </span>
                  </div>
                  
                  <div style={{ textAlign: 'center', marginBottom: '1.5rem', padding: '0.8rem', background: 'rgba(251,191,36,0.1)', borderRadius: '10px', border: '1px solid rgba(251,191,36,0.3)' }}>
                    <p style={{ color: '#fbbf24' }}>âš¡ åˆ›å»º/åŠ å…¥æˆ¿é—´éœ€æ”¯ä»˜ {CONFIG.ENTRY_FEE} GEN</p>
                  </div>
                  
                  {availableRooms.length > 0 && (
                    <div style={{ marginBottom: '2rem' }}>
                      <h3 style={{ color: '#c4b5fd', marginBottom: '1rem' }}>ğŸšª å¯åŠ å…¥çš„æˆ¿é—´</h3>
                      {availableRooms.map(room => (
                        <div key={room.id} style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', padding: '1rem', marginBottom: '0.5rem', background: 'rgba(255,255,255,0.03)', borderRadius: '10px', border: '1px solid rgba(255,255,255,0.1)' }}>
                          <div><span style={{ fontSize: '1.3rem', marginRight: '0.5rem' }}>{STORY_ARCS[room.theme]?.icon}</span><span>{STORY_ARCS[room.theme]?.name}</span><span style={{ color: '#8b8b9e', marginLeft: '0.5rem' }}>({Object.keys(room.players || {}).length}/{CONFIG.ROOM_SIZE.max})</span></div>
                          <button onClick={() => joinRoom(room.id)} style={{ padding: '0.5rem 1.5rem', background: 'linear-gradient(135deg, #a78bfa, #f472b6)', border: 'none', borderRadius: '8px', color: '#fff', fontWeight: 600, cursor: 'pointer' }}>åŠ å…¥</button>
                        </div>
                      ))}
                    </div>
                  )}
                  
                  <h3 style={{ color: '#c4b5fd', marginBottom: '1rem', textAlign: 'center' }}>é€‰æ‹©ä¸»é¢˜åˆ›å»ºæˆ¿é—´</h3>
                  <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(180px, 1fr))', gap: '1rem', marginBottom: '2rem' }}>
                    {Object.entries(STORY_ARCS).map(([key, arc]) => (
                      <button key={key} onClick={() => createRoom(key)} style={{ display: 'flex', flexDirection: 'column', alignItems: 'center', padding: '1.5rem', background: 'rgba(255,255,255,0.03)', border: '1px solid rgba(255,255,255,0.1)', borderRadius: '14px', cursor: 'pointer' }}>
                        <span style={{ fontSize: '2.5rem', marginBottom: '0.5rem' }}>{arc.icon}</span>
                        <span style={{ fontSize: '1.1rem', fontWeight: 600, color: '#fff' }}>{arc.name}</span>
                      </button>
                    ))}
                  </div>
                  
                  <div style={{ background: 'rgba(255,255,255,0.03)', borderRadius: '14px', padding: '1.5rem' }}>
                    <h3 style={{ color: '#fbbf24', marginBottom: '1rem' }}>ğŸ† æ’è¡Œæ¦œ</h3>
                    {leaderboard.length === 0 ? <p style={{ color: '#6b6b7e', textAlign: 'center' }}>æš‚æ— è®°å½•</p> : leaderboard.slice(0, 5).map((e, i) => (
                      <div key={e.id} style={{ display: 'flex', alignItems: 'center', gap: '0.8rem', padding: '0.6rem', background: i === 0 ? 'rgba(251,191,36,0.1)' : 'transparent', borderRadius: '8px', marginBottom: '0.3rem' }}>
                        <span style={{ fontWeight: 700, color: i < 3 ? '#fbbf24' : '#6b6b7e', width: '1.5rem' }}>#{i + 1}</span>
                        <span>{e.avatar}</span>
                        <span style={{ flex: 1, color: '#fff' }}>{e.name}</span>
                        <span style={{ color: '#a78bfa', fontWeight: 600 }}>{e.score}</span>
                      </div>
                    ))}
                  </div>
                </>
              )}
            </div>
          </div>
        );
      }

      // ROOM
      if (view === 'room') {
        return (
          <div style={{ minHeight: '100vh', background: 'linear-gradient(135deg, #0f0f1a 0%, #1a1a2e 50%, #16213e 100%)', padding: '2rem', color: '#e8e8e8' }}>
            <div style={{ maxWidth: '600px', margin: '0 auto' }}>
              <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '2rem' }}>
                <button onClick={resetGame} style={{ padding: '0.5rem 1rem', background: 'transparent', border: '1px solid rgba(255,255,255,0.2)', borderRadius: '8px', color: '#a5a5b8', cursor: 'pointer' }}>â† è¿”å›</button>
                <div><span style={{ fontSize: '1.3rem', marginRight: '0.5rem' }}>{STORY_ARCS[roomData?.theme]?.icon}</span><span style={{ fontWeight: 600 }}>{STORY_ARCS[roomData?.theme]?.name}</span></div>
                <span style={{ fontSize: '0.8rem', color: '#6b6b7e' }}>{roomId?.slice(-8)}</span>
              </div>
              
              <h3 style={{ color: '#8b8b9e', marginBottom: '1rem' }}>ç©å®¶ ({players.length}/{CONFIG.ROOM_SIZE.max})</h3>
              <div style={{ display: 'grid', gridTemplateColumns: 'repeat(4, 1fr)', gap: '1rem', marginBottom: '2rem' }}>
                {players.map(p => (
                  <div key={p.id} style={{ display: 'flex', flexDirection: 'column', alignItems: 'center', padding: '1rem', background: p.id === player.id ? 'rgba(167,139,250,0.1)' : 'rgba(255,255,255,0.03)', border: `1px solid ${p.id === player.id ? 'rgba(167,139,250,0.5)' : 'rgba(255,255,255,0.1)'}`, borderRadius: '10px', position: 'relative' }}>
                    <span style={{ fontSize: '2rem', marginBottom: '0.3rem' }}>{p.avatar}</span>
                    <span style={{ fontSize: '0.85rem' }}>{p.name}</span>
                    {p.isAI && <span style={{ position: 'absolute', top: '0.3rem', left: '0.3rem', fontSize: '0.5rem', padding: '0.1rem 0.3rem', background: '#3b82f6', borderRadius: '3px' }}>AI</span>}
                    {p.id === roomData?.host && <span style={{ position: 'absolute', top: '0.3rem', right: '0.3rem', fontSize: '0.5rem', padding: '0.1rem 0.3rem', background: '#fbbf24', color: '#000', borderRadius: '3px' }}>æˆ¿ä¸»</span>}
                  </div>
                ))}
              </div>
              
              {player.id === roomData?.host && (
                <button onClick={startGame} disabled={players.length < CONFIG.ROOM_SIZE.min} style={{ width: '100%', padding: '1rem', fontSize: '1.1rem', fontWeight: 600, border: 'none', borderRadius: '10px', cursor: players.length >= CONFIG.ROOM_SIZE.min ? 'pointer' : 'not-allowed', background: players.length >= CONFIG.ROOM_SIZE.min ? 'linear-gradient(135deg, #a78bfa, #f472b6)' : 'rgba(255,255,255,0.1)', color: players.length >= CONFIG.ROOM_SIZE.min ? '#fff' : '#6b6b7e' }}>
                  {players.length >= CONFIG.ROOM_SIZE.min ? 'ğŸ® å¼€å§‹æ¸¸æˆ' : `ç­‰å¾…ç©å®¶ (${players.length}/${CONFIG.ROOM_SIZE.min})`}
                </button>
              )}
            </div>
          </div>
        );
      }

      // GAME
      const currentOptions = getCurrentOptions();
      const votes = gameState?.votes || {};
      
      return (
        <div style={{ minHeight: '100vh', background: 'linear-gradient(135deg, #0f0f1a 0%, #1a1a2e 50%, #16213e 100%)', display: 'flex', flexDirection: 'column', color: '#e8e8e8' }}>
          <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', padding: '1rem 2rem', background: 'rgba(0,0,0,0.3)', borderBottom: '1px solid rgba(255,255,255,0.1)' }}>
            <div>
              <div style={{ fontSize: '0.85rem', color: '#8b8b9e' }}>ç¬¬ {gameState?.round || 1}/{CONFIG.TOTAL_ROUNDS} è½®</div>
              <div style={{ fontWeight: 600 }}>{gameState?.phase === 'debate' && 'ğŸ’¬ è¾©è®ºä¸­'}{gameState?.phase === 'vote' && 'ğŸ—³ï¸ æŠ•ç¥¨ä¸­'}{gameState?.phase === 'ended' && 'ğŸ† å·²ç»“æŸ'}</div>
            </div>
            <div style={{ fontSize: '2rem', fontWeight: 700, fontFamily: 'monospace', color: timer <= 10 && gameState?.phase !== 'ended' ? '#f87171' : '#a78bfa' }}>{gameState?.phase === 'ended' ? '--:--' : formatTime(timer)}</div>
            <div style={{ textAlign: 'right' }}><div style={{ fontSize: '0.8rem', color: '#8b8b9e' }}>ç§¯åˆ†</div><div style={{ fontSize: '1.3rem', fontWeight: 700, color: '#fbbf24' }}>{(gameState?.scores?.[player.id]?.influence || 0) + (gameState?.scores?.[player.id]?.debates || 0)}</div></div>
          </div>

          <div style={{ flex: 1, display: 'flex', gap: '1rem', padding: '1rem', overflow: 'hidden' }}>
            <div style={{ flex: 1, display: 'flex', flexDirection: 'column', gap: '1rem', minWidth: 0 }}>
              <div style={{ flex: 1, background: 'rgba(255,255,255,0.03)', borderRadius: '10px', padding: '1rem', overflowY: 'auto' }}>
                <h3 style={{ color: '#c4b5fd', marginBottom: '1rem', fontSize: '0.95rem' }}>ğŸ“œ {STORY_ARCS[roomData?.theme]?.name}</h3>
                {(gameState?.story || []).map((s, i) => (
                  <div key={i} style={{ padding: '0.5rem 0', borderBottom: i < (gameState?.story?.length || 0) - 1 ? '1px solid rgba(255,255,255,0.05)' : 'none' }}>
                    {s.type === 'opening' && <p style={{ color: '#c4b5fd', fontStyle: 'italic', lineHeight: 1.6 }}>{s.text}</p>}
                    {s.type === 'context' && <p style={{ color: '#fbbf24', lineHeight: 1.6 }}><span style={{ background: 'rgba(251,191,36,0.2)', padding: '0.15rem 0.4rem', borderRadius: '4px', marginRight: '0.4rem', fontSize: '0.8rem' }}>ç¬¬{s.round}è½®</span>{s.text}</p>}
                    {s.type === 'choice' && <p style={{ color: '#4ade80', lineHeight: 1.6 }}>{s.winner === 'A' ? 'ğŸ…°ï¸' : 'ğŸ…±ï¸'} {s.text}</p>}
                    {s.type === 'consequence' && <p style={{ color: '#a5a5b8', lineHeight: 1.6, paddingLeft: '1rem', borderLeft: '2px solid rgba(167,139,250,0.3)' }}>{s.text}</p>}
                  </div>
                ))}
              </div>

              {(gameState?.phase === 'debate' || gameState?.phase === 'vote') && currentOptions.a && (
                <div style={{ background: 'rgba(255,255,255,0.02)', borderRadius: '10px', padding: '1rem' }}>
                  <h4 style={{ textAlign: 'center', marginBottom: '0.8rem' }}>âš”ï¸ æœ¬è½®æŠ‰æ‹©</h4>
                  <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '1rem' }}>
                    {[{ key: 'A', opt: currentOptions.a, color: '#ef4444' }, { key: 'B', opt: currentOptions.b, color: '#3b82f6' }].map(({ key, opt, color }) => (
                      <div key={key} onClick={() => gameState?.phase === 'vote' && submitVote(key)} style={{ padding: '1rem', borderRadius: '8px', border: `2px solid ${myVote === key ? color : `${color}40`}`, background: `${color}15`, cursor: gameState?.phase === 'vote' ? 'pointer' : 'default' }}>
                        <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '0.5rem' }}>
                          <span style={{ fontWeight: 700, color }}>é€‰é¡¹ {key}</span>
                          <span style={{ fontSize: '0.7rem', padding: '0.1rem 0.4rem', background: 'rgba(255,255,255,0.1)', borderRadius: '4px', color: '#a5a5b8' }}>{opt?.tag}</span>
                        </div>
                        <p style={{ lineHeight: 1.4, fontSize: '0.85rem' }}>{opt?.text}</p>
                        {gameState?.phase === 'vote' && <div style={{ marginTop: '0.6rem', textAlign: 'center', fontSize: '1.1rem', fontWeight: 600, color: '#fbbf24' }}>{Object.values(votes).filter(v => v === key).length} ç¥¨</div>}
                      </div>
                    ))}
                  </div>
                </div>
              )}

              {gameState?.phase === 'ended' && (
                <div style={{ background: 'linear-gradient(145deg, rgba(251,191,36,0.1), rgba(167,139,250,0.1))', borderRadius: '10px', padding: '1.5rem', textAlign: 'center' }}>
                  <h2 style={{ fontSize: '1.5rem', marginBottom: '1rem', color: '#fbbf24' }}>ğŸ† ç¼–å¹´å²å®Œæˆï¼</h2>
                  <div style={{ maxWidth: '350px', margin: '0 auto 1rem' }}>
                    {Object.entries(gameState?.scores || {}).map(([id, score]) => ({ player: players.find(p => p.id === id), total: (score.influence || 0) + (score.debates || 0) })).sort((a, b) => b.total - a.total).map((rank, i) => (
                      <div key={rank.player?.id || i} style={{ display: 'flex', alignItems: 'center', gap: '0.6rem', padding: '0.6rem', marginBottom: '0.3rem', background: i === 0 ? 'rgba(251,191,36,0.2)' : 'rgba(255,255,255,0.03)', borderRadius: '6px' }}>
                        <span style={{ fontWeight: 700, color: i < 3 ? '#fbbf24' : '#6b6b7e' }}>#{i + 1}</span>
                        <span>{rank.player?.avatar}</span>
                        <span style={{ flex: 1 }}>{rank.player?.name}</span>
                        <span style={{ fontWeight: 600, color: '#a78bfa' }}>{rank.total}</span>
                      </div>
                    ))}
                  </div>
                  <button onClick={resetGame} style={{ padding: '0.6rem 1.5rem', background: 'linear-gradient(135deg, #a78bfa, #f472b6)', border: 'none', borderRadius: '8px', color: '#fff', fontWeight: 600, cursor: 'pointer' }}>è¿”å›å¤§å…</button>
                </div>
              )}
            </div>

            <div style={{ width: '280px', display: 'flex', flexDirection: 'column', background: 'rgba(0,0,0,0.2)', borderRadius: '10px', overflow: 'hidden' }}>
              <div style={{ display: 'flex', flexWrap: 'wrap', gap: '0.3rem', padding: '0.6rem', borderBottom: '1px solid rgba(255,255,255,0.05)' }}>
                {players.map(p => (
                  <div key={p.id} style={{ display: 'flex', alignItems: 'center', gap: '0.2rem', padding: '0.2rem 0.5rem', background: votes[p.id] ? 'rgba(74,222,128,0.2)' : 'rgba(255,255,255,0.05)', borderRadius: '12px', fontSize: '0.75rem' }}>
                    <span>{p.avatar}</span>
                    <span style={{ maxWidth: '50px', overflow: 'hidden', textOverflow: 'ellipsis', whiteSpace: 'nowrap' }}>{p.name}</span>
                    {votes[p.id] && <span style={{ color: '#4ade80', fontWeight: 700 }}>{votes[p.id]}</span>}
                  </div>
                ))}
              </div>
              
              <div style={{ flex: 1, overflowY: 'auto', padding: '0.6rem' }}>
                {messages.map((msg, i) => (
                  <div key={i} style={{ marginBottom: '0.5rem', fontSize: '0.8rem' }}>
                    {msg.type === 'system' ? (
                      <div style={{ color: '#a78bfa', fontStyle: 'italic' }}>{msg.text}</div>
                    ) : (
                      <div style={{ background: 'rgba(255,255,255,0.03)', borderRadius: '6px', padding: '0.4rem 0.6rem' }}>
                        <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '0.2rem' }}>
                          <span style={{ color: '#fbbf24', fontWeight: 600 }}>{msg.sender?.avatar} {msg.sender?.name}</span>
                          {msg.choice && <span style={{ fontSize: '0.65rem', padding: '0.1rem 0.3rem', background: msg.choice === 'A' ? 'rgba(239,68,68,0.3)' : 'rgba(59,130,246,0.3)', borderRadius: '3px' }}>{msg.choice}</span>}
                        </div>
                        <div>{msg.text}</div>
                      </div>
                    )}
                  </div>
                ))}
                <div ref={messagesEndRef} />
              </div>
              
              {gameState?.phase === 'debate' && (
                <div style={{ padding: '0.6rem', borderTop: '1px solid rgba(255,255,255,0.05)' }}>
                  <div style={{ display: 'flex', gap: '0.4rem', marginBottom: '0.4rem' }}>
                    <input type="text" value={debateInput} onChange={(e) => setDebateInput(e.target.value)} onKeyDown={(e) => e.key === 'Enter' && submitDebate()} placeholder="è¾“å…¥è§‚ç‚¹..." style={{ flex: 1, padding: '0.5rem', background: 'rgba(255,255,255,0.05)', border: '1px solid rgba(255,255,255,0.1)', borderRadius: '6px', color: '#fff', fontSize: '0.8rem', outline: 'none' }} />
                    <button onClick={submitDebate} style={{ padding: '0.5rem 0.8rem', background: 'linear-gradient(135deg, #a78bfa, #f472b6)', border: 'none', borderRadius: '6px', color: '#fff', fontWeight: 600, cursor: 'pointer' }}>å‘é€</button>
                  </div>
                  <div style={{ display: 'flex', gap: '0.3rem' }}>
                    <button onClick={() => setDebateInput('æˆ‘æ”¯æŒé€‰é¡¹Aï¼Œå› ä¸º')} style={{ padding: '0.2rem 0.5rem', background: 'rgba(239,68,68,0.2)', border: '1px solid rgba(239,68,68,0.3)', borderRadius: '10px', color: '#ef4444', fontSize: '0.7rem', cursor: 'pointer' }}>ğŸ…°ï¸</button>
                    <button onClick={() => setDebateInput('æˆ‘æ”¯æŒé€‰é¡¹Bï¼Œå› ä¸º')} style={{ padding: '0.2rem 0.5rem', background: 'rgba(59,130,246,0.2)', border: '1px solid rgba(59,130,246,0.3)', borderRadius: '10px', color: '#3b82f6', fontSize: '0.7rem', cursor: 'pointer' }}>ğŸ…±ï¸</button>
                  </div>
                </div>
              )}
              
              {gameState?.phase === 'vote' && !myVote && (
                <div style={{ padding: '0.8rem', textAlign: 'center', background: 'rgba(167,139,250,0.1)' }}>
                  <p style={{ color: '#fbbf24', fontWeight: 600, fontSize: '0.9rem' }}>â° è¯·åœ¨å·¦ä¾§æŠ•ç¥¨ï¼</p>
                </div>
              )}
            </div>
          </div>
        </div>
      );
    }

    ReactDOM.createRoot(document.getElementById('root')).render(<App />);
  </script>
</body>
</html>
