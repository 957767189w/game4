<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>å…±è¯†ç¼–å¹´å² | Consensus Chronicle</title>
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-database-compat.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: system-ui, sans-serif; background: #0f0f1a; }
  </style>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
    const { useState, useEffect, useRef } = React;
    // ========== é…ç½® ==========
    const CONFIG = {
      ROOM_SIZE: { min: 2, max: 8 },
      DEBATE_DURATION: 90,
      VOTE_DURATION: 30,
      TOTAL_ROUNDS: 5,
      ENTRY_FEE: 10000000000000000, // 0.01 GEN in wei
      ROOM_TIMEOUT_AI: 60000, // 1åˆ†é’Ÿæ— äººåŠ å…¥åˆ™AIå¡«å……
      ROOM_TIMEOUT_CLOSE: 120000, // 2åˆ†é’Ÿæœªå¼€å§‹åˆ™å…³é—­
      GENLAYER_API: 'https://studio.genlayer.com:8443/api',
      GENLAYER_CONTRACT: '0x4F5F132ba540f1C685B0188D59990302903aE186',
      FIREBASE: {
        apiKey: "AIzaSyBX4tOb30jWKK6aBUsqERQaOAF4CxCfMmQ",
        authDomain: "consensus-chronicle.firebaseapp.com",
        databaseURL: "https://consensus-chronicle-default-rtdb.firebaseio.com",
        projectId: "consensus-chronicle"
      }
    };
    // ========== æ•…äº‹ç³»ç»Ÿ ==========
    const STORY_ARCS = {
      fantasy: {
        name: 'å¥‡å¹»å†’é™©', icon: 'ğŸ°',
        opening: 'å¤è€çš„é¢„è¨€ç»ˆäºåº”éªŒâ€”â€”æ²‰ç¡åƒå¹´çš„é»‘é¾™è‹é†’äº†ã€‚ç‹å›½å±åœ¨æ—¦å¤•ï¼Œå›½ç‹ç´§æ€¥å¬é›†äº†å„åœ°è‹±é›„å•†è®®å¯¹ç­–...',
        rounds: [
          { context: 'é»‘é¾™çš„å¨èƒè¿«åœ¨çœ‰ç«ï¼Œç‹å›½å¿…é¡»åšå‡ºç¬¬ä¸€ä¸ªå…³é”®å†³å®šã€‚', a: { text: 'ç«‹å³é›†ç»“å†›é˜Ÿï¼Œä¸»åŠ¨å‡ºå‡»é¾™å·¢ï¼Œåœ¨å®ƒå®Œå…¨è‹é†’å‰å°†å…¶æ¶ˆç­ã€‚', tag: 'å…ˆå‘åˆ¶äººÂ·æ¿€è¿›', consequence: 'ç‹å›½å†›é˜Ÿå‘é¾™å·¢è¿›å‘ï¼Œä½†é€”ä¸­é­é‡äº†é¾™çš„çˆªç‰™ï¼ŒæŸå¤±æƒ¨é‡...' }, b: { text: 'æ´¾é£ä½¿è€…å¯»æ±‚ç²¾çµæ—çš„å¸®åŠ©ï¼Œä»–ä»¬æ›¾åœ¨åƒå¹´å‰å°å°è¿‡é»‘é¾™ã€‚', tag: 'å¯»æ±‚è”ç›ŸÂ·ç¨³å¦¥', consequence: 'ä½¿è€…æˆåŠŸè”ç³»åˆ°äº†ç²¾çµæ—ï¼Œä½†ä»–ä»¬æå‡ºäº†è‹›åˆ»çš„æ¡ä»¶...' } },
          { contextA: 'å†›é˜ŸæŸå¤±æƒ¨é‡ï¼Œä½†å·²é€¼è¿‘é¾™å·¢ã€‚æ­¤æ—¶æ¢å­æ¥æŠ¥ï¼šé¾™å·¢å†…å‘ç°äº†é¾™è›‹ã€‚', contextB: 'ç²¾çµæ—è¦æ±‚äººç±»äº¤å‡ºåœ£å‰‘ä½œä¸ºä¿¡ä»»çš„è¯æ˜ï¼Œå¦åˆ™ä¸äºˆæ´åŠ©ã€‚', a: { text: 'æ‘§æ¯é¾™è›‹ï¼Œå½»åº•æ–­ç»é»‘é¾™ä¸€æ—çš„è¡€è„‰ï¼Œæ°¸é™¤åæ‚£ã€‚', tag: 'æ–©è‰é™¤æ ¹Â·æ®‹é…·', consequenceFromA: 'é¾™è›‹è¢«æ¯ï¼Œé»‘é¾™ç‹‚æ€’ï¼Œæˆ˜æ–—æ›´åŠ æƒ¨çƒˆ...', consequenceFromB: 'æ‹’ç»äº¤å‡ºåœ£å‰‘åï¼Œäººç±»å†³å®šç‹¬è‡ªé¢å¯¹é»‘é¾™ï¼Œæ‘§æ¯äº†é¾™è›‹...' }, b: { text: 'ä¿ç•™é¾™è›‹ï¼Œæˆ–è®¸å¯ä»¥ç”¨å®ƒä¸é»‘é¾™è°ˆåˆ¤ï¼Œæˆ–åŸ¹å…»ä¸€æ¡å‹å–„çš„é¾™ã€‚', tag: 'ç•™æœ‰ä½™åœ°Â·å†’é™©', consequenceFromA: 'é¾™è›‹è¢«ç§˜å¯†ä¿æŠ¤èµ·æ¥ï¼Œä½†æ¶ˆæ¯æ³„éœ²å¼•å‘äº†å†…éƒ¨åˆ†è£‚...', consequenceFromB: 'äº¤å‡ºåœ£å‰‘æ¢å–ç²¾çµæ´åŠ©ï¼ŒåŒæ—¶ä¿æŠ¤äº†é¾™è›‹...' } },
          { contextAA: 'é»‘é¾™åœ¨ç‹‚æ€’ä¸­å±•ç°å‡ºæ¯å¤©ç­åœ°çš„åŠ›é‡ï¼Œå†›é˜Ÿå³å°†å…¨å†›è¦†æ²¡ã€‚', contextAB: 'å†…éƒ¨åˆ†è£‚å¯¼è‡´å†›å¿ƒæ¶£æ•£ï¼Œæœ‰äººä¸»å¼ æŠ•é™ï¼Œæœ‰äººåšæŒæˆ˜æ–—ã€‚', contextBA: 'ç‹¬è‡ªä½œæˆ˜çš„äººç±»å†›é˜Ÿåœ¨æ²¡æœ‰ç²¾çµé­”æ³•çš„æ”¯æŒä¸‹é™·å…¥è‹¦æˆ˜ã€‚', contextBB: 'ç²¾çµå†›é˜ŸæŠµè¾¾ï¼Œä½†ä»–ä»¬å¯¹é¾™è›‹çš„å­˜åœ¨æ„Ÿåˆ°ä¸æ»¡ï¼Œå¨èƒæ’¤å†›ã€‚', a: { text: 'ä½¿ç”¨ç¦å¿Œé­”æ³•ï¼Œç‰ºç‰²æ–½æ³•è€…çš„ç”Ÿå‘½æ¥é‡åˆ›é»‘é¾™ã€‚', tag: 'ç‰ºç‰²å°æˆ‘Â·æ‚²å£®', consequence: 'ç¦å¿Œé­”æ³•ç”Ÿæ•ˆï¼Œé»‘é¾™é‡ä¼¤å è½ï¼Œä½†ä»£ä»·æ˜¯æƒ¨é‡çš„...' }, b: { text: 'ä¸‹ä»¤æ’¤é€€ï¼Œä¿å­˜å®åŠ›ï¼Œç­‰å¾…æ›´å¥½çš„æ—¶æœºå†æˆ˜ã€‚', tag: 'ä»¥é€€ä¸ºè¿›Â·å¿è€', consequence: 'å†›é˜Ÿæ’¤é€€åˆ°å®‰å…¨åœ°å¸¦ï¼Œä½†é»‘é¾™è¶æœºæ‘§æ¯äº†æ•°ä¸ªæ‘åº„...' } },
          { contextA: 'é»‘é¾™é‡ä¼¤åé€€å›å·¢ç©´ç–—ä¼¤ï¼Œä½†å®ƒçš„æ„¤æ€’ä½¿å¾—æ•´ä¸ªåŒºåŸŸéƒ½ç¬¼ç½©åœ¨æ­»äº¡æ°”æ¯ä¸­ã€‚', contextB: 'æ’¤é€€åï¼Œç‹å›½å¼€å§‹åæ€ç­–ç•¥ï¼Œæ°‘é—´å‡ºç°äº†å„ç§å£°éŸ³å’ŒåŠ¿åŠ›ã€‚', a: { text: 'è¶é»‘é¾™ç–—ä¼¤æœŸé—´å‘èµ·æ€»æ”»ï¼Œä¸€ä¸¾å°†å…¶æ¶ˆç­ã€‚', tag: 'ä¹˜èƒœè¿½å‡»Â·å†³ç»', consequence: 'æ€»æ”»å¼€å§‹ï¼Œè¿™å°†æ˜¯å†³å®šç‹å›½å‘½è¿çš„æœ€åä¸€æˆ˜...' }, b: { text: 'å°è¯•ä¸å—ä¼¤çš„é»‘é¾™æ²Ÿé€šï¼Œå¯»æ‰¾å’Œå¹³å…±å­˜çš„å¯èƒ½ã€‚', tag: 'åŒ–æ•Œä¸ºå‹Â·ç†æƒ³', consequence: 'ä½¿è€…å†’æ­»æ¥è¿‘é»‘é¾™ï¼Œå‡ºä¹æ„æ–™åœ°ï¼Œé»‘é¾™æ„¿æ„å¯¹è¯...' } },
          { contextA: 'æœ€ç»ˆå†³æˆ˜ä¸­ï¼ŒåŒæ–¹éƒ½ä»˜å‡ºäº†æƒ¨é‡ä»£ä»·ï¼Œèƒœè´Ÿå³å°†æ­æ™“ã€‚', contextB: 'é»‘é¾™é€éœ²å®ƒè‹é†’æ˜¯å› ä¸ºæ„Ÿå—åˆ°äº†æ›´å¤§çš„å¨èƒâ€”â€”æ¥è‡ªæ·±æ¸Šçš„é‚ªç¥å³å°†é™ä¸´ã€‚', a: { text: 'ä¸æƒœä¸€åˆ‡ä»£ä»·æ¶ˆç­é»‘é¾™ï¼Œå“ªæ€•ç‹å›½åŒ–ä¸ºç„¦åœŸä¹Ÿåœ¨æ‰€ä¸æƒœã€‚', tag: 'ç‰çŸ³ä¿±ç„šÂ·æç«¯', ending: 'é»‘é¾™è¢«æ¶ˆç­ï¼Œä½†ç‹å›½ä¹Ÿå‡ ä¹åŒ–ä¸ºåºŸå¢Ÿã€‚å¹¸å­˜è€…å¼€å§‹äº†æ¼«é•¿çš„é‡å»ºä¹‹è·¯ï¼Œå†å²å°†é“­è®°è¿™åœºæƒ¨èƒœã€‚' }, b: { text: 'æ¥å—å‘½è¿çš„å®‰æ’ï¼Œä¸é»‘é¾™è¾¾æˆåè®®ï¼Œå…±åŒé¢å¯¹æœªæ¥çš„æŒ‘æˆ˜ã€‚', tag: 'æ¡æ‰‹è¨€å’ŒÂ·æ™ºæ…§', ending: 'äººç±»ä¸é»‘é¾™è¾¾æˆäº†å‰æ‰€æœªæœ‰çš„ç›Ÿçº¦ï¼Œå…±åŒå®ˆæŠ¤è¿™ç‰‡å¤§é™†ã€‚ä¸€ä¸ªæ–°çš„æ—¶ä»£å°±æ­¤å¼€å¯ã€‚' } }
        ]
      },
      scifi: {
        name: 'ç§‘å¹»æœªæ¥', icon: 'ğŸš€',
        opening: '2157å¹´ï¼Œç«æ˜Ÿæ®–æ°‘åœ°"æ–°å¸Œæœ›"æ”¶åˆ°äº†ä¸€æ®µæ¥è‡ªæ·±ç©ºçš„ç¥ç§˜ä¿¡å·ã€‚ç§‘å­¦å®¶ä»¬ç ´è¯‘åå‘ç°ï¼šè¿™æ˜¯ä¸€ä¸ªè­¦å‘Šâ€”â€”åœ°çƒå°†åœ¨100å¤©åè¢«å°è¡Œæ˜Ÿæ’å‡»ã€‚ç„¶è€Œï¼Œæ®–æ°‘åœ°çš„èµ„æºåªå¤Ÿæ•‘ä¸€åŠäºº...',
        rounds: [
          { context: 'æ¶ˆæ¯å…¬å¸ƒåï¼Œæ®–æ°‘åœ°é™·å…¥ææ…Œã€‚é¢†å¯¼å±‚å¿…é¡»ç«‹å³åšå‡ºå†³å®šã€‚', a: { text: 'ç«‹å³å¯åŠ¨"æ–¹èˆŸè®¡åˆ’"ï¼Œé€šè¿‡æŠ½ç­¾å†³å®šè°èƒ½ç™»ä¸Šé€ƒç”Ÿé£èˆ¹ã€‚', tag: 'å…¬å¹³æŠ½ç­¾Â·å†·é…·', consequence: 'æŠ½ç­¾ç»“æœå…¬å¸ƒï¼Œè½é€‰è€…å¼€å§‹ç»æœ›åœ°æŠ—è®®ï¼Œå®‰ä¿éƒ¨é˜Ÿè¢«è¿«ä»‹å…¥...' }, b: { text: 'é›†ä¸­æ‰€æœ‰èµ„æºç ”ç©¶ä¿¡å·æ¥æºï¼Œä¹Ÿè®¸é‚£é‡Œæœ‰æ‹¯æ•‘æ‰€æœ‰äººçš„ç­”æ¡ˆã€‚', tag: 'è¿½å¯»å¸Œæœ›Â·å†’é™©', consequence: 'ç ”ç©¶å›¢é˜Ÿå‘ç°ä¿¡å·æ¥è‡ªä¸€ä¸ªæœªçŸ¥æ–‡æ˜ï¼Œä»–ä»¬ä¼¼ä¹åœ¨é‚€è¯·äººç±»...' } },
          { contextA: 'æŠ—è®®æ¼”å˜ä¸ºæš´åŠ¨ï¼Œéƒ¨åˆ†è½é€‰è€…å é¢†äº†é£èˆ¹å‘å°„åŒºã€‚', contextB: 'æ·±å…¥åˆ†æä¿¡å·åï¼Œå‘ç°é‚£ä¸ªæ–‡æ˜åœ¨é‚€è¯·äººç±»å»ä¸€ä¸ªé¥è¿œçš„æ˜Ÿç³»ï¼Œä½†æ—…ç¨‹éœ€è¦500å¹´ã€‚', a: { text: 'æˆæƒå®‰ä¿éƒ¨é˜Ÿä½¿ç”¨æ­¦åŠ›ï¼Œç¡®ä¿æ–¹èˆŸè®¡åˆ’æŒ‰æ—¶æ‰§è¡Œã€‚', tag: 'é“è…•é•‡å‹Â·æ•ˆç‡', consequenceFromA: 'æš´åŠ¨è¢«é•‡å‹ï¼Œä½†è®¸å¤šäººåœ¨å†²çªä¸­ä¸§ç”Ÿï¼Œå¹¸å­˜è€…å¿ƒå­˜æ€¨æ¨...', consequenceFromB: 'æ”¾å¼ƒä¸å¤–æ˜Ÿæ–‡æ˜è”ç³»ï¼Œä¸“æ³¨äºç°æœ‰çš„é€ƒç”Ÿè®¡åˆ’...' }, b: { text: 'ä¸æŠ—è®®è€…è°ˆåˆ¤ï¼Œå°è¯•ä¿®æ”¹è®¡åˆ’è®©æ›´å¤šäººè·å¾—ç”Ÿå­˜æœºä¼šã€‚', tag: 'å¯»æ±‚å…±è¯†Â·äººé“', consequenceFromA: 'è°ˆåˆ¤å–å¾—è¿›å±•ï¼Œå·¥ç¨‹å¸ˆæå‡ºå¯ä»¥è¶…è½½é£èˆ¹ï¼Œä½†é£é™©æå¤§...', consequenceFromB: 'å†³å®šæ´¾é£å…ˆé”‹é˜Ÿå“åº”é‚€è¯·ï¼Œå…¶ä½™äººè¿›å…¥å†·å†»ç¡çœ ç­‰å¾…...' } },
          { contextAA: 'é£èˆ¹è¶…è½½ä¼šå¯¼è‡´æˆåŠŸç‡ä»95%é™åˆ°60%ï¼Œä½†èƒ½å¤šæ•‘30%çš„äººã€‚', contextAB: 'å…ˆé”‹é˜Ÿå‡ºå‘åå¤±å»æ¯›æ³½ä¸œè”ç³»ï¼Œå‰©ä½™èµ„æºåªå¤Ÿç»´æŒ60å¤©ã€‚', contextBA: 'éƒ¨åˆ†æ¿€è¿›åˆ†å­ä¸æ¥å—è°ˆåˆ¤ç»“æœï¼Œå¯†è°‹ç ´åé£èˆ¹ã€‚', contextBB: 'å†·å†»ç¡çœ æŠ€æœ¯å°šæœªå®Œå–„ï¼Œæœ‰30%çš„å¤±è´¥ç‡ã€‚', a: { text: 'æ¥å—è¶…è½½æ–¹æ¡ˆï¼Œç”¨60%çš„æˆåŠŸç‡æ¢å–æ›´å¤šäººçš„å¸Œæœ›ã€‚', tag: 'å†’é™©æ±‚å…¨Â·èµŒåš', consequence: 'è¶…è½½æ–¹æ¡ˆå¯åŠ¨ï¼Œæ‰€æœ‰äººéƒ½åœ¨ç¥ˆç¥·å¥‡è¿¹å‘ç”Ÿ...' }, b: { text: 'ç»´æŒåŸè®¡åˆ’ï¼Œç¡®ä¿è‡³å°‘ä¸€åŠäººèƒ½å¤Ÿç¡®å®šå­˜æ´»ã€‚', tag: 'ç¨³å¦¥æ±‚å­˜Â·ç°å®', consequence: 'åŸè®¡åˆ’ç»§ç»­æ‰§è¡Œï¼Œä½†ç¤¾ä¼šçš„è£‚ç—•å·²æ— æ³•å¼¥åˆ...' } },
          { contextA: 'é£èˆ¹èµ·é£å‰ï¼ŒAIç³»ç»Ÿæ£€æµ‹åˆ°ä¸€ä¸ªæƒŠäººçš„å¯èƒ½æ€§ï¼šå°è¡Œæ˜Ÿçš„è½¨é“å¯ä»¥è¢«äººä¸ºæ”¹å˜ã€‚', contextB: 'å‘å°„å‡†å¤‡å®Œæˆæ—¶ï¼Œå…ˆé”‹é˜Ÿçªç„¶ä¼ æ¥æ¶ˆæ¯ï¼šå¤–æ˜Ÿæ–‡æ˜å¯ä»¥æä¾›æŠ€æœ¯æ‘§æ¯å°è¡Œæ˜Ÿï¼Œä½†éœ€è¦äººç±»æ”¾å¼ƒæ­¦å™¨ã€‚', a: { text: 'å°è¯•æ”¹å˜å°è¡Œæ˜Ÿè½¨é“ï¼Œå³ä½¿å¤±è´¥ä¹Ÿå€¼å¾—ä¸€è¯•ã€‚', tag: 'é€†å¤©æ”¹å‘½Â·è‹±é›„', consequence: 'å…¨æ®–æ°‘åœ°çš„èƒ½æºè¢«é›†ä¸­ç”¨äºè¿™ä¸ªå¤§èƒ†çš„è®¡åˆ’...' }, b: { text: 'æŒ‰åŸè®¡åˆ’æ’¤ç¦»ï¼Œä¸è¦æŠŠæ‰€æœ‰é¸¡è›‹æ”¾åœ¨ä¸€ä¸ªç¯®å­é‡Œã€‚', tag: 'åˆ†æ•£é£é™©Â·è°¨æ…', consequence: 'é£èˆ¹å¼€å§‹æ’¤ç¦»ï¼Œä½†ç•™ä¸‹çš„äººæ²¡æœ‰æ”¾å¼ƒå¸Œæœ›...' } },
          { contextA: 'æ”¹å˜è½¨é“çš„å°è¯•æ¶ˆè€—äº†80%çš„èƒ½æºï¼Œå°è¡Œæ˜Ÿåç§»äº†ï¼Œä½†ä¸å¤Ÿâ€”â€”å®ƒä»ä¼šæ“¦è¿‡åœ°çƒå¤§æ°”å±‚ï¼Œé€ æˆå·¨å¤§ç¾éš¾ã€‚', contextB: 'å¤–æ˜Ÿæ–‡æ˜çš„æŠ€æœ¯ç¡®å®æœ‰æ•ˆï¼Œä½†ä»–ä»¬è¦æ±‚äººç±»å¿…é¡»å…ˆé”€æ¯æ‰€æœ‰æ ¸æ­¦å™¨ä½œä¸º"å…¥ä¼šè´¹"ã€‚', a: { text: 'æ”¾æ‰‹ä¸€æï¼Œç”¨å‰©ä½™èƒ½æºå†æ¨ä¸€æ¬¡ï¼Œè¦ä¹ˆå…¨èµ¢ï¼Œè¦ä¹ˆå…¨è¾“ã€‚', tag: 'èƒŒæ°´ä¸€æˆ˜Â·æé™', ending: 'å¥‡è¿¹å‘ç”Ÿäº†ï¼å°è¡Œæ˜Ÿåœ¨æœ€åä¸€åˆ»åç¦»äº†æ’å‡»è½¨é“ã€‚äººç±»ç”¨å‹‡æ°”å’Œå›¢ç»“æˆ˜èƒœäº†å‘½è¿ï¼Œè¿™ä¸€å¤©è¢«æ°¸è¿œé“­è®°ä¸º"æ–°å¸Œæœ›æ—¥"ã€‚' }, b: { text: 'æ¥å—éƒ¨åˆ†æŸå¤±ï¼Œå¼€å§‹ç¾åé‡å»ºè®¡åˆ’ï¼Œäººç±»å°†æµ´ç«é‡ç”Ÿã€‚', tag: 'åŠ¡å®é¢å¯¹Â·é‡ç”Ÿ', ending: 'å°è¡Œæ˜Ÿæ“¦è¿‡åœ°çƒï¼Œé€ æˆäº†ä¸¥é‡ä½†éæ¯ç­æ€§çš„ç¾éš¾ã€‚å¹¸å­˜çš„äººç±»å¼€å§‹äº†è‰°éš¾çš„é‡å»ºï¼Œä½†ä»–ä»¬çŸ¥é“ï¼Œåªè¦äººç±»è¿˜åœ¨ï¼Œå¸Œæœ›å°±åœ¨ã€‚' } }
        ]
      },
      mystery: {
        name: 'æ‚¬ç–‘æ¨ç†', icon: 'ğŸ”',
        opening: 'æš´é£é›¨ä¹‹å¤œï¼Œå¯Œè±ªé™ˆå®¶çš„å®¶ä¸»é™ˆè€çˆ·åœ¨ä¹¦æˆ¿è¢«äººæ¯’æ€ã€‚å¤§é—¨ä»å†…åé”ï¼Œçª—æˆ·å®Œå¥½æ— æŸã€‚åœ¨åœºçš„æœ‰ï¼šå¤§å„¿å­é™ˆæ˜ã€äºŒå¥³å„¿é™ˆæœˆã€ç®¡å®¶è€å¼ ã€å¥³ä»†å°èŠ³ï¼Œä»¥åŠåˆšåˆ°è®¿çš„ç¥ç§˜å•†äººæå…ˆç”Ÿã€‚æ¯ä¸ªäººä¼¼ä¹éƒ½æœ‰å«Œç–‘ï¼Œæ¯ä¸ªäººéƒ½æœ‰ç§˜å¯†...',
        rounds: [
          { context: 'è­¦æ–¹å°é”äº†å®…é‚¸ï¼Œæ‰€æœ‰äººéƒ½ä¸èƒ½ç¦»å¼€ã€‚ä½œä¸ºè¢«é‚€è¯·æ¥çš„ä¾¦æ¢ï¼Œä½ å¿…é¡»å¼€å§‹è°ƒæŸ¥ã€‚', a: { text: 'é¦–å…ˆæœæŸ¥æ­»è€…çš„ä¹¦æˆ¿ï¼Œå¯»æ‰¾ç‰©è¯å’Œçº¿ç´¢ã€‚', tag: 'ç‰©è¯ä¼˜å…ˆÂ·ç³»ç»Ÿ', consequence: 'åœ¨ä¹¦æˆ¿å‘ç°äº†ä¸€å°è¢«çƒ§æ¯ä¸€åŠçš„ä¿¡ä»¶ï¼Œéšçº¦å¯è§"èƒŒå›"å’Œ"é—äº§"å­—æ ·...' }, b: { text: 'åˆ†åˆ«è¯¢é—®åœ¨åœºæ¯ä¸ªäººï¼Œè§‚å¯Ÿä»–ä»¬çš„ååº”å’Œæ¼æ´ã€‚', tag: 'å¯Ÿè¨€è§‚è‰²Â·ç›´è§‰', consequence: 'è¯¢é—®ä¸­å‘ç°ç®¡å®¶è€å¼ ç¥è‰²æ…Œå¼ ï¼Œè€Œé™ˆæœˆæåˆ°çˆ¶äº²æœ€è¿‘æ”¶åˆ°è¿‡å¨èƒä¿¡...' } },
          { contextA: 'ä¿¡ä»¶æ˜¾ç¤ºé™ˆè€çˆ·æ›¾æ‰“ç®—æ›´æ”¹é—å˜±ï¼Œå‰¥å¤ºæŸäººçš„ç»§æ‰¿æƒã€‚', contextB: 'è¿›ä¸€æ­¥è°ƒæŸ¥å‘ç°ï¼Œå¨èƒä¿¡æ¥è‡ªä¸€ä¸ªç¥ç§˜ç»„ç»‡ï¼Œè€Œæå…ˆç”Ÿä¼¼ä¹ä¸è¿™ä¸ªç»„ç»‡æœ‰å…³è”ã€‚', a: { text: 'æ·±å…¥è°ƒæŸ¥é—äº§é—®é¢˜ï¼Œè¿½æŸ¥è°æ˜¯è¢«å‰¥å¤ºç»§æ‰¿æƒçš„äººã€‚', tag: 'è¿½è¸ªé‡‘é’±Â·ç°å®', consequenceFromA: 'å‘ç°é™ˆæ˜æ¬ ä¸‹å·¨é¢èµŒå€ºï¼Œè€Œé™ˆæœˆä¸€ç›´åœ¨ç§˜å¯†èµ„åŠ©ä¸€ä¸ªæ…ˆå–„æœºæ„...', consequenceFromB: 'è°ƒæŸ¥æ˜¾ç¤ºé™ˆè€çˆ·æœ€è¿‘è½¬ç§»äº†å¤§ç¬”èµ„äº§ï¼Œä½†å»å‘ä¸æ˜...' }, b: { text: 'è°ƒæŸ¥æå…ˆç”Ÿçš„èº«ä»½å’Œæ¥å†ï¼Œä»–çš„å‡ºç°å¤ªè¿‡å·§åˆã€‚', tag: 'è¿½æŸ¥å¤–äººÂ·æ€€ç–‘', consequenceFromA: 'æå…ˆç”Ÿçš„èº«ä»½è¢«æ­éœ²ï¼šä»–æ˜¯é™ˆè€çˆ·å¤±æ•£å¤šå¹´çš„ç§ç”Ÿå­...', consequenceFromB: 'æå…ˆç”Ÿæ‰¿è®¤è‡ªå·±æ˜¯æ¥è°ˆç”Ÿæ„çš„ï¼Œä½†ä»–å¸¦æ¥äº†ä¸€ä¸ªæƒŠäººçš„ç§˜å¯†...' } },
          { contextAA: 'é™ˆæ˜æœ‰åŠ¨æœºï¼Œä½†ä»–æœ‰ä¸åœ¨åœºè¯æ˜â€”â€”å¥³ä»†å°èŠ³å¯ä»¥ä½œè¯ã€‚', contextAB: 'èµ„äº§è½¬ç§»çš„ç›®çš„åœ°æ˜¯ä¸€ä¸ªæµ·å¤–è´¦æˆ·ï¼Œæˆ·ä¸»åå­—è¢«åŠ å¯†ã€‚', contextBA: 'ç§ç”Ÿå­çš„å‡ºç°æ„å‘³ç€é—äº§å°†è¢«é‡æ–°åˆ†é…ï¼Œæ‰€æœ‰åˆæ³•ç»§æ‰¿äººéƒ½æœ‰äº†åŠ¨æœºã€‚', contextBB: 'æå…ˆç”Ÿé€éœ²é™ˆè€çˆ·ç”Ÿå‰ä¸€ç›´åœ¨è°ƒæŸ¥ä¸€æ¡©é™ˆå¹´æ—§æ¡ˆâ€”â€”ä¸€èµ·è¢«æ©ç›–çš„è°‹æ€ã€‚', a: { text: 'éªŒè¯å°èŠ³çš„è¯è¯ï¼Œå¥¹å¯èƒ½æ˜¯å…³é”®è¯äººï¼Œä¹Ÿå¯èƒ½æ˜¯åŒè°‹ã€‚', tag: 'è´¨ç–‘è¯è¯Â·ç»†è‡´', consequence: 'å‹åŠ›ä¹‹ä¸‹ï¼Œå°èŠ³å´©æºƒäº†ï¼Œæ‰¿è®¤é™ˆæ˜æ›¾å¨èƒå¥¹ä½œä¼ªè¯...' }, b: { text: 'è°ƒæŸ¥é™ˆå¹´æ—§æ¡ˆï¼Œä¹Ÿè®¸è¿‡å»çš„ç§˜å¯†èƒ½æ­ç¤ºç°åœ¨çš„çœŸç›¸ã€‚', tag: 'è¿½æº¯è¿‡å»Â·è€å¿ƒ', consequence: 'æ—§æ¡ˆçš„çº¿ç´¢æŒ‡å‘20å¹´å‰çš„ä¸€åœºç«ç¾ï¼Œé™ˆè€çˆ·çš„åŸé…å¦»å­åœ¨é‚£åœºç«ç¾ä¸­èº«äº¡...' } },
          { contextA: 'ä¼ªè¯è¢«æ­ç©¿åï¼Œé™ˆæ˜çš„ä¸åœ¨åœºè¯æ˜å¤±æ•ˆã€‚ä½†ä»–åšç§°è‡ªå·±æ˜¯æ— è¾œçš„ï¼Œå¹¶æŒ‡æ§é™ˆæœˆæ‰æ˜¯å‡¶æ‰‹ã€‚', contextB: 'è°ƒæŸ¥å‘ç°ï¼Œé‚£åœºç«ç¾å¹¶éæ„å¤–ï¼Œè€Œæ˜¯äººä¸ºçºµç«ã€‚æ›´æƒŠäººçš„æ˜¯ï¼Œé™ˆè€çˆ·å¯èƒ½çŸ¥é“çœŸå‡¶æ˜¯è°ã€‚', a: { text: 'å¯¹é™ˆæ˜å’Œé™ˆæœˆè¿›è¡Œäº¤å‰å®¡é—®ï¼Œæ‰¾å‡ºè°åœ¨è¯´è°ã€‚', tag: 'æ­£é¢å¯¹è´¨Â·æ¿€çƒˆ', consequence: 'å®¡é—®ä¸­ï¼Œä¸€ä¸ªæƒŠå¤©ç§˜å¯†è¢«æ­å¼€ï¼šé™ˆæœˆä¸æ˜¯é™ˆè€çˆ·çš„äº²ç”Ÿå¥³å„¿...' }, b: { text: 'é‡æ–°æ£€éªŒæ¯’è¯æ¥æºï¼Œå‡¶å™¨å¾€å¾€èƒ½æŒ‡å‘çœŸå‡¶ã€‚', tag: 'ç§‘å­¦åˆ†æÂ·ä¸¥è°¨', consequence: 'æ¯’è¯æˆåˆ†åˆ†ææ˜¾ç¤ºï¼Œè¿™ç§æ¯’è¯åªèƒ½ä»ä¸€ç§ç¨€æœ‰æ¤ç‰©ä¸­æå–ï¼Œè€Œç®¡å®¶è€å¼ çš„æˆ¿é—´é‡Œç§ç€è¿™ç§æ¤ç‰©...' } },
          { contextA: 'é™ˆæœˆçš„èº«ä¸–ç§˜å¯†æ­å¼€åï¼ŒçœŸç›¸é€æ¸æµ®å‡ºæ°´é¢ï¼šå¥¹æ˜¯20å¹´å‰ç«ç¾ä¸­"æ­»å»"çš„é‚£ä¸ªäººçš„å¥³å„¿ï¼Œè¢«é™ˆè€çˆ·ç§˜å¯†æ”¶å…»ã€‚', contextB: 'æ‰€æœ‰è¯æ®éƒ½æŒ‡å‘ç®¡å®¶è€å¼ ï¼Œä½†ä»–åœ¨è¢«å®¡é—®æ—¶çªç„¶å¿ƒè„ç—…å‘ä½œï¼Œç•™ä¸‹ä¸€å¥è¯ï¼š"çœŸç›¸...åœ¨èŠ±å›­çš„è€æ§æ ‘ä¸‹..."', a: { text: 'å…¬å¼€æ‰€æœ‰çœŸç›¸ï¼Œè®©æ³•å¾‹æ¥è£å†³ï¼Œæ— è®ºç»“æœå¦‚ä½•ã€‚', tag: 'å…¬æ­£å®¡åˆ¤Â·æ³•æ²»', ending: 'çœŸç›¸å¤§ç™½ï¼šç®¡å®¶è€å¼ æ˜¯20å¹´å‰é™ˆè€çˆ·åŸé…çš„æƒ…äººï¼Œç«ç¾æ˜¯ä»–ä»¬ä¸€èµ·ç­–åˆ’çš„ã€‚é™ˆè€çˆ·å‘ç°çœŸç›¸åæ‰“ç®—æ­å‘ä»–ï¼Œäºæ˜¯è€å¼ ç—›ä¸‹æ€æ‰‹ã€‚é™ˆæœˆå¾—çŸ¥è‡ªå·±çš„èº«ä¸–åé€‰æ‹©åŸè°…ï¼Œå¹¶ç”¨ç»§æ‰¿çš„é—äº§æˆç«‹äº†åŸºé‡‘ä¼šï¼Œå¸®åŠ©é‚£äº›åƒå¥¹ä¸€æ ·å¤±å»å®¶åº­çš„å­©å­ã€‚' }, b: { text: 'ç»™äºˆç›¸å…³äººä¸€ä¸ªé€‰æ‹©çš„æœºä¼šï¼Œæœ‰äº›çœŸç›¸ä¹Ÿè®¸ä¸è¯¥è¢«å…¬å¼€ã€‚', tag: 'äººæƒ…è€ƒé‡Â·ç°è‰²', ending: 'ä½ é€‰æ‹©äº†ä¸€ä¸ªæŠ˜ä¸­çš„æ–¹æ¡ˆï¼šè€å¼ çš„ç½ªè¡Œè¢«ä½è°ƒå¤„ç†ï¼Œå¯¹å¤–å®£å¸ƒé™ˆè€çˆ·æ­»äºæ„å¤–ã€‚é™ˆæ˜æˆ’æ‰äº†èµŒåšï¼Œé™ˆæœˆç»§ç»­å¥¹çš„æ…ˆå–„äº‹ä¸šï¼Œæå…ˆç”Ÿå¸¦ç€çˆ¶äº²çš„é—ç‰©ç¦»å¼€ã€‚æœ‰äº›çœŸç›¸è¢«æ°¸è¿œåŸ‹è‘¬ï¼Œä½†æ´»ç€çš„äººéƒ½æœ‰äº†æ–°çš„å¼€å§‹ã€‚' } }
        ]
      },
      political: {
        name: 'å®«å»·æƒè°‹', icon: 'ğŸ‘‘',
        opening: 'å¤§é½ç‹æœï¼Œæ°¸å®‰ä¸‰åå¹´ã€‚è€çš‡å¸é©¾å´©çš„æ¶ˆæ¯éœ‡æƒŠæœé‡ã€‚é—è¯ä¸­å´å‡ºç°äº†ä»¤äººè´¹è§£çš„å†…å®¹ï¼šçš‡ä½ä¸ä¼ ç»™ä¸‰ä½æˆå¹´çš‡å­ä¸­çš„ä»»ä½•ä¸€ä¸ªï¼Œè€Œæ˜¯ç”±"æœ€èƒ½ä»£è¡¨æ°‘å¿ƒè€…"ç»§æ‰¿ã€‚ä¸€æ—¶é—´ï¼Œæœå ‚æš—æµæ¶ŒåŠ¨ï¼Œå„æ–¹åŠ¿åŠ›è ¢è ¢æ¬²åŠ¨...',
        rounds: [
          { context: 'ä½œä¸ºå…ˆå¸ä¿¡ä»»çš„å†…é˜é¦–è¾…ï¼Œä½ å¿…é¡»åœ¨æ··ä¹±ä¸­ç»´æŒå±€é¢ã€‚ä¸‰ä½çš‡å­å„æœ‰æ”¯æŒè€…ï¼šå¤ªå­ä»åšä½†æ‡¦å¼±ï¼ŒäºŒçš‡å­ç²¾æ˜ä½†æ®‹å¿ï¼Œä¸‰çš‡å­å¹´è½»ä½†é”æ„æ”¹é©ã€‚', a: { text: 'æ”¯æŒå¤ªå­æŒ‰ä¼ ç»Ÿç»§ä½ï¼Œç»´æŠ¤å«¡é•¿å­ç»§æ‰¿åˆ¶åº¦çš„ç¨³å®šã€‚', tag: 'ä¼ ç»Ÿæ­£ç»ŸÂ·ä¿å®ˆ', consequence: 'å¤ªå­è·å¾—ä½ çš„æ”¯æŒåä¿¡å¿ƒå¤§å¢ï¼Œä½†äºŒçš‡å­çš„æ”¯æŒè€…å¼€å§‹æš—ä¸­è”ç»œå†›æ–¹...' }, b: { text: 'æè®®ä¸‰ä½çš‡å­å„é™ˆæ–½æ”¿çº²é¢†ï¼Œç”±ç™¾å®˜å…¬è®®å†³å®šäººé€‰ã€‚', tag: 'å…¬è®®å†³é€‰Â·é©æ–°', consequence: 'è¿™ä¸ªæè®®å¼•å‘è½©ç„¶å¤§æ³¢ï¼Œæ”¹é©æ´¾æ¬¢å‘¼ï¼Œä¿å®ˆæ´¾å¼ºçƒˆåå¯¹...' } },
          { contextA: 'äºŒçš‡å­å‹¾ç»“è¾¹ç–†å°†å†›ï¼Œå¯†è°‹èµ·å…µ"æ¸…å›ä¾§"ï¼Œå±€åŠ¿éª¤ç„¶ç´§å¼ ã€‚', contextB: 'å…¬è®®ä¹‹å‰ï¼Œæœ‰äººæ­å‘ä¸‰çš‡å­ä¸å¤–é‚¦ä½¿èŠ‚æœ‰ç§˜å¯†å¾€æ¥ï¼Œæ¶‰å«Œå›å›½ã€‚', a: { text: 'ç´§æ€¥è°ƒåŠ¨å¾¡æ—å†›å¸ƒé˜²ï¼ŒåŒæ—¶æ´¾å¯†ä½¿åˆ†åŒ–äºŒçš‡å­çš„åŒç›Ÿã€‚', tag: 'åˆ†åŒ–ç“¦è§£Â·æƒè°‹', consequenceFromA: 'ä½ çš„è®¡ç­–æˆåŠŸæ‹–å»¶äº†äºŒçš‡å­çš„è¡ŒåŠ¨ï¼Œä½†ä»–å¼€å§‹æ€€ç–‘å†…éƒ¨æœ‰äººèƒŒå›...', consequenceFromB: 'ä½ åˆ©ç”¨è¿™ä¸ªæœºä¼šæ‰“å‹ä¸‰çš‡å­ï¼Œä½†è°ƒæŸ¥æ˜¾ç¤ºæ­å‘ä¿¡å¯èƒ½æ˜¯ä¼ªé€ çš„...' }, b: { text: 'ä¸»åŠ¨æ‰¾äºŒçš‡å­è°ˆåˆ¤ï¼Œäº†è§£ä»–çš„è¯‰æ±‚ï¼Œå¯»æ‰¾å’Œå¹³è§£å†³çš„å¯èƒ½ã€‚', tag: 'å’Œè°ˆæ­¢å…µÂ·å†’é™©', consequenceFromA: 'äºŒçš‡å­æå‡ºæ¡ä»¶ï¼šä»–è¦å¤ªå­çš„ä½ç½®ï¼Œä½†æ‰¿è¯ºå–„å¾…å…„å¼Ÿ...', consequenceFromB: 'æ­å‘äº‹ä»¶ä½¿ä¸‰çš‡å­é™·å…¥å›°å¢ƒï¼Œä½ å†³å®šäº²è‡ªè°ƒæŸ¥çœŸç›¸...' } },
          { contextAA: 'äºŒçš‡å­çš„ç›Ÿå‹è¢«æˆåŠŸç­–åï¼Œä½†å¯¹æ–¹è¦æ±‚äº‹æˆä¹‹åå°ä¾¯æ‹œç›¸ã€‚', contextAB: 'è°ƒæŸ¥æ˜¾ç¤ºæ­å‘ä¿¡å‡ºè‡ªå¤ªåçš„äº²ä¿¡ï¼Œç›®çš„æ˜¯æ‰¶æŒå¥¹çš„å¤–ç”¥ä¸Šä½ã€‚', contextBA: 'äºŒçš‡å­çš„æ¡ä»¶ä»¤äººéš¾ä»¥æ¥å—ï¼Œä½†ä»–æ‰‹æ¡é‡å…µï¼Œæ‹’ç»å¯èƒ½å¯¼è‡´å†…æˆ˜ã€‚', contextBB: 'å¤ªåå¼€å§‹å…¬å¼€å¹²æ”¿ï¼Œä»¥å…ˆå¸é—å­€çš„èº«ä»½è¦æ±‚"å‚å¸˜å¬æ”¿"ã€‚', a: { text: 'ç­”åº”å°ä¾¯çš„æ¡ä»¶ï¼Œä¸¤å®³ç›¸æƒå–å…¶è½»ï¼Œå…ˆç¨³ä½å±€é¢ã€‚', tag: 'æƒå®œä¹‹è®¡Â·å¦¥å', consequence: 'å±€åŠ¿æš‚æ—¶ç¨³å®šï¼Œä½†ä½ çŸ¥é“è¿™åªæ˜¯å¼€å§‹ï¼Œæ›´å¤§çš„é£æš´è¿˜åœ¨åé¢...' }, b: { text: 'æ­éœ²å¤ªåçš„é˜´è°‹ï¼Œè”åˆä¸‰ä½çš‡å­å…±åŒå¯¹æŠ—å¤–æˆšä¸“æƒã€‚', tag: 'å›¢ç»“æŠ—æ•ŒÂ·æ­£ä¹‰', consequence: 'ä½ çš„æ­éœ²è®©æœå ‚éœ‡åŠ¨ï¼Œä¸‰ä½çš‡å­ç ´å¤©è’åœ°ç«™åœ¨äº†ä¸€èµ·...' } },
          { contextA: 'å„æ–¹åŠ¿åŠ›æš‚æ—¶å¹³è¡¡ï¼Œä½†å‚¨ä½ä¹‹äº‰ä»æ‚¬è€Œæœªå†³ã€‚è¿™æ—¶è¾¹ç–†ä¼ æ¥æ€¥æŠ¥ï¼šåŒ—æ–¹æ¸¸ç‰§æ°‘æ—å¤§å†›å‹å¢ƒã€‚', contextB: 'å¤ªåè¢«è½¯ç¦ï¼Œå¤–æˆšåŠ¿åŠ›ç“¦è§£ã€‚ä½†åœ¨æ•´ç†å¤ªåå¯å®«æ—¶ï¼Œå‘ç°äº†å…ˆå¸çš„å¦ä¸€ä»½é—è¯...', a: { text: 'å»ºè®®ä¸‰ä½çš‡å­äº²å¾åŒ—ç–†ï¼Œè°èƒ½å‡»é€€æ•Œå†›è°å°±æ˜¯æ–°å¸ã€‚', tag: 'ä»¥æˆ˜å®šå¸Â·é­„åŠ›', consequence: 'ä¸‰ä½çš‡å­ç‡å†›åŒ—ä¸Šï¼Œè¿™åœºæˆ˜äº‰å°†å†³å®šå¤§é½çš„æœªæ¥...' }, b: { text: 'æè®®å…ˆé€‰å‡ºæ–°å¸å†åº”å¯¹å¤–æ•Œï¼Œå›½ä¸å¯ä¸€æ—¥æ— å›ã€‚', tag: 'å…ˆå†…åå¤–Â·ç¨³é‡', consequence: 'åœ¨ä½ çš„ä¸»æŒä¸‹ï¼Œä¸€åœºå†³å®šæ€§çš„æœè®®å³å°†å¼€å§‹...' } },
          { contextA: 'åŒ—ç–†æˆ˜äº‹èƒ¶ç€ï¼Œå¤ªå­ä»å¾·æŠšæ°‘ï¼ŒäºŒçš‡å­å‹‡çŒ›ä½œæˆ˜ï¼Œä¸‰çš‡å­åå‹¤è°ƒåº¦æœ‰æ–¹ã€‚ä¸‰äººå„æœ‰åŠŸåŠ³ï¼Œéš¾åˆ†é«˜ä¸‹ã€‚', contextB: 'å…ˆå¸çš„çœŸæ­£é—è¯è¢«æ‰¾åˆ°ï¼Œä¸Šé¢å†™ç€ï¼šçš‡ä½ä¼ ç»™"èƒ½è®©ä¸‰ä¸ªå„¿å­å’Œç¦å…±å¤„è€…"ã€‚è¿™ä¸ªäºº...ç«Ÿç„¶æ˜¯ä½ ã€‚', a: { text: 'å»ºè®®ä¸‰ä½çš‡å­å…±åŒæ‰§æ”¿ï¼Œå»ºç«‹"ä¸‰ç‹è®®æ”¿"çš„æ–°åˆ¶åº¦ã€‚', tag: 'æƒåŠ›å…±äº«Â·å¼€åˆ›', ending: 'å¤§é½ç‹æœè¿›å…¥äº†å‰æ‰€æœªæœ‰çš„"ä¸‰ç‹æ—¶ä»£"ã€‚å¤ªå­ä¸»å†…æ”¿ï¼ŒäºŒçš‡å­æŒå†›äº‹ï¼Œä¸‰çš‡å­è´Ÿè´£æ”¹é©ã€‚è™½ç„¶äº‰åµä¸æ–­ï¼Œä½†åœ¨ä½ çš„è°ƒå’Œä¸‹ï¼Œè¿™ä¸ªåˆ¶åº¦ç«Ÿç„¶è¿è½¬äº†èµ·æ¥ã€‚äºŒåå¹´åï¼Œä½ åœ¨å›å¿†å½•ä¸­å†™é“ï¼š"æœ€å¥½çš„åˆ¶åº¦ä¸æ˜¯å®Œç¾çš„åˆ¶åº¦ï¼Œè€Œæ˜¯èƒ½è‡ªæˆ‘çº é”™çš„åˆ¶åº¦ã€‚"' }, b: { text: 'æŒ‰å†›åŠŸå¤§å°æ’åºï¼Œç”±åŠŸåŠ³æœ€å¤§è€…ç»§æ‰¿çš‡ä½ã€‚', tag: 'åŠŸå‹‹å®šä½Â·å…¬å¹³', ending: 'äºŒçš‡å­å‡­å€Ÿæˆ˜åŠŸç™»åŸºï¼Œä½†ä»–æ²¡æœ‰è¾œè´Ÿä¿¡ä»»ã€‚åœ¨ä½æœŸé—´åŒ—å‡»æ¸¸ç‰§ã€å†…ä¿®æ”¿æ²»ï¼Œå¤§é½è¿æ¥äº†ä¸­å…´ã€‚ä¸‰çš‡å­è¢«å°ä¸ºæ”¹é©ç‰¹ä½¿ï¼Œå¤ªå­ä¸»ç®¡ç¤¼éƒ¨æ•™åŒ–ã€‚ä½ ä»¥ä¸ƒåé«˜é¾„è¾å®˜å½’éšæ—¶ï¼Œæ–°å¸äº²è‡ªé€è¡Œåé‡Œï¼Œè¯´ï¼š"æ²¡æœ‰é¦–è¾…å¤§äººï¼Œå°±æ²¡æœ‰ä»Šæ—¥çš„å¤§é½ã€‚"' } }
        ]
      }
    };
    // ========== AIç©å®¶ ==========
    const AI_PLAYERS = [
      { id: 'ai_1', name: 'æ™ºè€…Â·è‰¾ä¸', avatar: 'ğŸ§™â€â™€ï¸', exp: 1200, isAI: true, style: 'analytical' },
      { id: 'ai_2', name: 'å‹‡è€…Â·å‡¯æ©', avatar: 'âš”ï¸', exp: 1100, isAI: true, style: 'bold' },
      { id: 'ai_3', name: 'å­¦è€…Â·è¯ºäºš', avatar: 'ğŸ“š', exp: 1300, isAI: true, style: 'cautious' },
      { id: 'ai_4', name: 'å•†äººÂ·é©¬å¯', avatar: 'ğŸ’°', exp: 1150, isAI: true, style: 'pragmatic' },
      { id: 'ai_5', name: 'è¯—äººÂ·æœˆå', avatar: 'ğŸ­', exp: 1050, isAI: true, style: 'romantic' },
    ];
    const generateAIDebate = (style) => {
      const debates = {
        analytical: { A: ['ä»é€»è¾‘ä¸Šåˆ†æï¼Œé€‰é¡¹Açš„æˆåŠŸç‡æ›´é«˜', 'æ•°æ®è¡¨æ˜ï¼Œæœæ–­è¡ŒåŠ¨å¾€å¾€æ•ˆæœæ›´å¥½'], B: ['ä»”ç»†åˆ†æåï¼ŒBçš„é•¿æœŸæ”¶ç›Šæ›´å¤§', 'ç»¼åˆè€ƒé‡ï¼ŒBæ˜¯æ›´ç¨³å¦¥çš„æ–¹æ¡ˆ'] },
        bold: { A: ['å‹‡è€…ä¸æƒ§ï¼Aæ‰æ˜¯çœŸæ­£çš„è‹±é›„ä¹‹é€‰', 'æœæ–­å‡ºå‡»ï¼æ”¯æŒAï¼'], B: ['Bæ‰æ˜¯çœŸæ­£çš„å‹‡æ°”ï¼æ•¢äºä¸åŒï¼', 'æ™ºå‹‡åŒå…¨æ‰æ˜¯çœŸè‹±é›„ï¼Œé€‰Bï¼'] },
        cautious: { A: ['è™½ç„¶å†’é™©ï¼Œä½†Aæˆ–è®¸æ˜¯å¿…è¦çš„', 'ä¸¤å®³ç›¸æƒå–å…¶è½»ï¼Œæ”¯æŒA'], B: ['è°¨æ…èµ·è§ï¼ŒBæ›´å®‰å…¨', 'ç•™å¾—é’å±±åœ¨ï¼Œé€‰Bæ›´æ˜æ™º'] },
        pragmatic: { A: ['ä»åˆ©ç›Šè§’åº¦ï¼ŒAå›æŠ¥æ›´é«˜', 'å•†äººçš„ç›´è§‰å‘Šè¯‰æˆ‘ï¼Œé€‰A'], B: ['Bçš„é£é™©æ›´å¯æ§', 'é•¿è¿œæ¥çœ‹ï¼ŒBæ”¶ç›Šæ›´ç¨³å®š'] },
        romantic: { A: ['Aæœ‰ç§æ‚²å£®çš„ç¾æ„Ÿ', 'å‘½è¿çš„è¯—ç¯‡éœ€è¦Aè¿™æ ·çš„è½¬æŠ˜'], B: ['Bä»£è¡¨ç€å¸Œæœ›ä¸å¯èƒ½', 'Bæ‰æ˜¯æœ€åŠ¨äººçš„ç­”æ¡ˆ'] },
      };
      const choice = Math.random() > 0.5 ? 'A' : 'B';
      const options = debates[style]?.[choice] || debates.analytical[choice];
      return { text: options[Math.floor(Math.random() * options.length)], choice };
    };
    // ========== ä¸»ç»„ä»¶ ==========
    function App() {
      const [db, setDb] = useState(null);
      const [walletAddress, setWalletAddress] = useState(null);
      const [walletConnecting, setWalletConnecting] = useState(false);
      const [view, setView] = useState('home');
      const [player, setPlayer] = useState({ id: '', name: '', avatar: 'ğŸ®', exp: 1000 });
      const [roomId, setRoomId] = useState(null);
      const [roomData, setRoomData] = useState(null);
      const [players, setPlayers] = useState([]);
      const [gameState, setGameState] = useState(null);
      const [messages, setMessages] = useState([]);
      const [availableRooms, setAvailableRooms] = useState([]);
      const [debateInput, setDebateInput] = useState('');
      const [myVote, setMyVote] = useState(null);
      const [timer, setTimer] = useState(0);
      const [leaderboard, setLeaderboard] = useState([]);
      const [loading, setLoading] = useState(false);
      const timerRef = useRef(null);
      const messagesEndRef = useRef(null);
      const roomCheckRef = useRef(null);
      // åˆå§‹åŒ–Firebase
      useEffect(() => {
        try {
          if (!firebase.apps.length) firebase.initializeApp(CONFIG.FIREBASE);
          setDb(firebase.database());
        } catch (err) { console.error('Firebase init error:', err); }
        try {
          const saved = localStorage.getItem('consensus_leaderboard');
          if (saved) setLeaderboard(JSON.parse(saved));
        } catch {}
        return () => {
          if (timerRef.current) clearInterval(timerRef.current);
          if (roomCheckRef.current) clearInterval(roomCheckRef.current);
        };
      }, []);
      // ç›‘å¬æˆ¿é—´åˆ—è¡¨ + å¤„ç†è¶…æ—¶æˆ¿é—´
      useEffect(() => {
        if (!db) return;
        const roomsRef = db.ref('rooms');
        roomsRef.on('value', (snapshot) => {
          const data = snapshot.val();
          const now = Date.now();
          if (data) {
            const rooms = [];
            Object.entries(data).forEach(([id, room]) => {
              const age = now - room.createdAt;
              if (room.status === 'waiting' && age > CONFIG.ROOM_TIMEOUT_CLOSE) {
                db.ref(`rooms/${id}`).update({ status: 'closed' });
                return;
              }
              if (room.status === 'waiting') {
                rooms.push({ id, ...room, age });
              }
            });
            setAvailableRooms(rooms);
          } else {
            setAvailableRooms([]);
          }
        });
      }, [db]);
      // ç›‘å¬å½“å‰æˆ¿é—´
      useEffect(() => {
        if (!db || !roomId) return;
        const roomRef = db.ref(`rooms/${roomId}`);
        const gameRef = db.ref(`games/${roomId}`);
       
        roomRef.on('value', (s) => {
          const d = s.val();
          if (d) {
            setRoomData(d);
            if (d.players) setPlayers(Object.values(d.players));
            if (d.status === 'closed') {
              alert('æˆ¿é—´å·²å…³é—­');
              resetGame();
            }
          }
        });
       
        gameRef.on('value', (s) => {
          const d = s.val();
          if (d) {
            setGameState(d);
            if (d.messages) setMessages(Object.values(d.messages).sort((a, b) => a.timestamp - b.timestamp));
            if (d.timerEnd && d.phase !== 'ended') setTimer(Math.max(0, Math.floor((d.timerEnd - Date.now()) / 1000)));
          }
        });
        return () => {
          roomRef.off();
          gameRef.off();
        };
      }, [db, roomId]);
      // æˆ¿é—´è¶…æ—¶æ£€æŸ¥ï¼š1åˆ†é’Ÿæ— äººåŠ å…¥åˆ™æ·»åŠ AI
      useEffect(() => {
        if (!db || !roomId || !roomData || roomData.status !== 'waiting') return;
        if (roomCheckRef.current) clearInterval(roomCheckRef.current);
       
        roomCheckRef.current = setInterval(() => {
          const age = Date.now() - roomData.createdAt;
          const playerCount = Object.keys(roomData.players || {}).filter(id => !id.startsWith('ai_')).length;
         
          if (age > CONFIG.ROOM_TIMEOUT_AI && playerCount === 1 && player.id === roomData.host) {
            const currentPlayerIds = Object.keys(roomData.players || {});
            const availableAI = AI_PLAYERS.filter(ai => !currentPlayerIds.includes(ai.id));
            const aiToAdd = availableAI.slice(0, CONFIG.ROOM_SIZE.min - 1);
           
            aiToAdd.forEach((ai, i) => {
              setTimeout(() => {
                db.ref(`rooms/${roomId}/players/${ai.id}`).set(ai);
                addMessage('system', `${ai.avatar} ${ai.name} åŠ å…¥äº†æˆ¿é—´`);
              }, i * 1000);
            });
          }
        }, 5000);
        return () => { if (roomCheckRef.current) clearInterval(roomCheckRef.current); };
      }, [db, roomId, roomData, player.id]);
      // è®¡æ—¶å™¨åŒæ­¥
      useEffect(() => {
        if (!gameState?.timerEnd || gameState?.phase === 'ended') return;
        if (timerRef.current) clearInterval(timerRef.current);
        timerRef.current = setInterval(() => {
          const remaining = Math.max(0, Math.floor((gameState.timerEnd - Date.now()) / 1000));
          setTimer(remaining);
          if (remaining <= 0 && player.id === roomData?.host) handlePhaseEnd();
        }, 1000);
        return () => { if (timerRef.current) clearInterval(timerRef.current); };
      }, [gameState?.timerEnd, gameState?.phase]);
      useEffect(() => { messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' }); }, [messages]);
      // ========== é’±åŒ…è¿æ¥ ==========
      const connectWallet = async () => {
        if (!window.ethereum) { alert('è¯·å®‰è£…MetaMaské’±åŒ…'); return null; }
        setWalletConnecting(true);
        try {
          const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
          setWalletAddress(accounts[0]);
          setPlayer(p => ({ ...p, id: accounts[0] }));
          return accounts[0];
        } catch (err) { alert('é’±åŒ…è¿æ¥å¤±è´¥: ' + err.message); return null; }
        finally { setWalletConnecting(false); }
      };
      // ========== GenLayeræ‰£è´¹ï¼ˆæµ‹è¯•æ¨¡å¼ï¼šè·³è¿‡ï¼‰==========
      const payEntryFee = async (address) => {
        console.log('ã€æµ‹è¯•æ¨¡å¼ã€‘è·³è¿‡GenLayeræ‰£è´¹ï¼Œç›´æ¥æˆåŠŸ');
        return true; // ç›´æ¥è¿”å›æˆåŠŸï¼Œä¸è°ƒç”¨APIï¼Œé¿å…Failed to fetch
      };
      // ========== GenLayerè®°å½•æ¸¸æˆç»“æœï¼ˆæµ‹è¯•æ¨¡å¼ï¼šè·³è¿‡ï¼‰==========
      const recordGameToGenLayer = async (gameData) => {
        console.log('ã€æµ‹è¯•æ¨¡å¼ã€‘è·³è¿‡è®°å½•æ¸¸æˆç»“æœåˆ°GenLayer', gameData);
        // å¦‚éœ€æ¢å¤çœŸå®è®°å½•ï¼Œè¯·å–æ¶ˆæ³¨é‡ŠåŸfetchä»£ç 
      };
      // ========== åˆ›å»ºæˆ¿é—´ ==========
      const createRoom = async (theme) => {
        if (!db || !player.name) return;
       
        let address = walletAddress;
        if (!address) {
          address = await connectWallet();
          if (!address) return;
        }
       
        const paid = await payEntryFee(address);
        if (!paid) return;
       
        const newRoomId = `room_${Date.now()}`;
        await db.ref(`rooms/${newRoomId}`).set({
          theme,
          host: address,
          status: 'waiting',
          createdAt: Date.now(),
          players: { [address]: { id: address, name: player.name, avatar: player.avatar, exp: player.exp, isAI: false } }
        });
        setRoomId(newRoomId);
        setView('room');
        addMessage('system', `æˆ¿é—´å·²åˆ›å»ºï¼Œç­‰å¾…å…¶ä»–ç©å®¶åŠ å…¥...`);
      };
      // ========== åŠ å…¥æˆ¿é—´ ==========
      const joinRoom = async (targetRoomId) => {
        if (!db || !player.name) return;
       
        let address = walletAddress;
        if (!address) {
          address = await connectWallet();
          if (!address) return;
        }
       
        const paid = await payEntryFee(address);
        if (!paid) return;
       
        await db.ref(`rooms/${targetRoomId}/players/${address}`).set({
          id: address,
          name: player.name,
          avatar: player.avatar,
          exp: player.exp,
          isAI: false
        });
        setRoomId(targetRoomId);
        setView('room');
      };
      // ========== æ·»åŠ AIç©å®¶ ==========
      const addAIPlayers = async () => {
        if (!db || !roomId) return;
        const currentPlayerIds = Object.keys(roomData?.players || {});
        const availableAI = AI_PLAYERS.filter(ai => !currentPlayerIds.includes(ai.id));
        const shuffled = availableAI.sort(() => Math.random() - 0.5);
        const aiToAdd = shuffled.slice(0, Math.min(3, CONFIG.ROOM_SIZE.max - currentPlayerIds.length));
       
        for (let i = 0; i < aiToAdd.length; i++) {
          await new Promise(r => setTimeout(r, 1000));
          await db.ref(`rooms/${roomId}/players/${aiToAdd[i].id}`).set(aiToAdd[i]);
          addMessage('system', `${aiToAdd[i].avatar} ${aiToAdd[i].name} åŠ å…¥äº†æˆ¿é—´`);
        }
      };
      // ========== å¼€å§‹æ¸¸æˆ ==========
      const startGame = async () => {
        if (!db || !roomId || players.length < CONFIG.ROOM_SIZE.min) return;
       
        await db.ref(`rooms/${roomId}`).update({ status: 'playing' });
       
        const theme = roomData?.theme || 'fantasy';
        const arc = STORY_ARCS[theme];
        const initScores = {};
        players.forEach(p => { initScores[p.id] = { influence: 0, debates: 0, wins: 0 }; });
       
        await db.ref(`games/${roomId}`).set({
          round: 1,
          phase: 'debate',
          path: [],
          scores: initScores,
          votes: {},
          story: [{ text: arc.opening, type: 'opening', round: 0 }],
          timerEnd: Date.now() + CONFIG.DEBATE_DURATION * 1000,
          messages: {}
        });
       
        setView('game');
        addMessage('system', `ğŸ“– ${arc.name}å¼€å§‹äº†ï¼ç¬¬ 1/${CONFIG.TOTAL_ROUNDS} è½® - è¾©è®ºé˜¶æ®µ`);
        setTimeout(() => simulateAIDebate(), 3000);
      };
      const simulateAIDebate = () => {
        players.filter(p => p.isAI).forEach((ai, i) => {
          setTimeout(() => {
            const debate = generateAIDebate(ai.style);
            addMessage('chat', debate.text, ai, debate.choice);
          }, (i + 1) * 3000 + Math.random() * 5000);
        });
      };
      const handlePhaseEnd = async () => {
        if (!db || !roomId || !gameState) return;
        if (gameState.phase === 'debate') {
          await db.ref(`games/${roomId}`).update({ phase: 'vote', timerEnd: Date.now() + CONFIG.VOTE_DURATION * 1000, votes: {} });
          addMessage('system', 'ğŸ—³ï¸ æŠ•ç¥¨é˜¶æ®µå¼€å§‹ï¼');
          setMyVote(null);
          players.filter(p => p.isAI).forEach((ai, i) => {
            setTimeout(async () => {
              await db.ref(`games/${roomId}/votes/${ai.id}`).set(Math.random() > 0.5 ? 'A' : 'B');
            }, (i + 1) * 2000);
          });
        } else if (gameState.phase === 'vote') {
          await calculateResult();
        }
      };
      const calculateResult = async () => {
        if (!db || !roomId || !gameState) return;
        const votes = gameState.votes || {};
        const voteCount = { A: 0, B: 0 };
        Object.values(votes).forEach(v => { if (v) voteCount[v]++; });
        const winner = voteCount.A >= voteCount.B ? 'A' : 'B';
       
        const newScores = { ...gameState.scores };
        Object.entries(votes).forEach(([id, v]) => {
          if (v === winner && newScores[id]) {
            newScores[id].influence = (newScores[id].influence || 0) + 30;
            newScores[id].wins = (newScores[id].wins || 0) + 1;
          }
        });
       
        const newPath = [...(gameState.path || []), winner];
        const round = gameState.round;
        const consequence = getConsequence(round, winner, gameState.path || []);
        const winOpt = getOption(round, winner);
        const newStory = [...(gameState.story || []),
          { text: `ã€ä¼—äººé€‰æ‹©ã€‘${winOpt?.text}`, type: 'choice', round, winner },
          { text: consequence, type: 'consequence', round }
        ];
       
        addMessage('system', `ğŸ“œ é€‰é¡¹ ${winner} è·èƒœï¼(${voteCount[winner]}ç¥¨ vs ${voteCount[winner === 'A' ? 'B' : 'A']}ç¥¨)`);
       
        if (round >= CONFIG.TOTAL_ROUNDS) {
          await db.ref(`games/${roomId}`).update({ phase: 'ended', scores: newScores, path: newPath, story: newStory, timerEnd: null });
          addMessage('system', 'ğŸ† ç¼–å¹´å²å®Œæˆï¼');
         
          const topPlayer = Object.entries(newScores).sort((a, b) => (b[1].influence + b[1].debates) - (a[1].influence + a[1].debates))[0];
          await recordGameToGenLayer({
            theme: roomData?.theme,
            winner: topPlayer?.[0],
            path: newPath,
            scores: newScores
          });
         
          const myScore = newScores[player.id] || { influence: 0, debates: 0 };
          const totalScore = (myScore.influence || 0) + (myScore.debates || 0);
          if (player.name && totalScore > 0) {
            const newLeaderboard = [...leaderboard, { id: Date.now(), name: player.name, avatar: player.avatar, score: totalScore, theme: roomData?.theme, date: new Date().toLocaleDateString() }].sort((a, b) => b.score - a.score).slice(0, 50);
            setLeaderboard(newLeaderboard);
            try { localStorage.setItem('consensus_leaderboard', JSON.stringify(newLeaderboard)); } catch {}
          }
        } else {
          const nextRound = round + 1;
          const nextContext = getContext(nextRound, newPath);
          await db.ref(`games/${roomId}`).update({
            round: nextRound,
            phase: 'debate',
            scores: newScores,
            path: newPath,
            story: [...newStory, { text: nextContext, type: 'context', round: nextRound }],
            timerEnd: Date.now() + CONFIG.DEBATE_DURATION * 1000,
            votes: {}
          });
          addMessage('system', `ğŸ“– ç¬¬ ${nextRound}/${CONFIG.TOTAL_ROUNDS} è½® - è¾©è®ºé˜¶æ®µ`);
          setTimeout(() => simulateAIDebate(), 3000);
        }
      };
      // æ•…äº‹è¾…åŠ©å‡½æ•°ï¼ˆä¿æŒä¸å˜ï¼‰
      const getContext = (roundNum, path) => {
        const theme = roomData?.theme || 'fantasy';
        const roundData = STORY_ARCS[theme]?.rounds[roundNum - 1];
        if (!roundData) return '';
        if (roundNum > 1 && path.length > 0) {
          const pathKey = path.slice(-2).join('');
          if (roundData[`context${pathKey}`]) return roundData[`context${pathKey}`];
          if (roundData[`context${path[path.length - 1]}`]) return roundData[`context${path[path.length - 1]}`];
        }
        return roundData.context || '';
      };
      const getOption = (roundNum, choice) => {
        const roundData = STORY_ARCS[roomData?.theme || 'fantasy']?.rounds[roundNum - 1];
        return choice === 'A' ? roundData?.a : roundData?.b;
      };
      const getConsequence = (roundNum, choice, path) => {
        const roundData = STORY_ARCS[roomData?.theme || 'fantasy']?.rounds[roundNum - 1];
        if (!roundData) return '';
        const option = choice === 'A' ? roundData.a : roundData.b;
        if (path.length > 0 && option[`consequenceFrom${path[path.length - 1]}`]) return option[`consequenceFrom${path[path.length - 1]}`];
        if (roundNum === CONFIG.TOTAL_ROUNDS && option.ending) return option.ending;
        return option.consequence || '';
      };
      const getCurrentOptions = () => {
        if (!gameState || !roomData) return { a: null, b: null };
        const roundData = STORY_ARCS[roomData.theme || 'fantasy']?.rounds[(gameState.round || 1) - 1];
        return { a: roundData?.a, b: roundData?.b };
      };
      // æ¶ˆæ¯å‡½æ•°ï¼ˆä¿æŒä¸å˜ï¼‰
      const addMessage = async (type, text, sender = null, choice = null) => {
        if (!db || !roomId) return;
        await db.ref(`games/${roomId}/messages`).push().set({ type, text, sender, choice, timestamp: Date.now() });
      };
      const submitDebate = async () => {
        if (!debateInput.trim() || gameState?.phase !== 'debate') return;
        const choice = debateInput.includes('A') ? 'A' : debateInput.includes('B') ? 'B' : null;
        await addMessage('chat', debateInput, { id: player.id, name: player.name, avatar: player.avatar }, choice);
        setDebateInput('');
        if (gameState?.scores?.[player.id]) await db.ref(`games/${roomId}/scores/${player.id}/debates`).set((gameState.scores[player.id].debates || 0) + 10);
      };
      const submitVote = async (choice) => {
        if (gameState?.phase !== 'vote' || myVote) return;
        setMyVote(choice);
        await db.ref(`games/${roomId}/votes/${player.id}`).set(choice);
      };
      const resetGame = () => {
        if (timerRef.current) clearInterval(timerRef.current);
        if (roomCheckRef.current) clearInterval(roomCheckRef.current);
        setRoomId(null); setRoomData(null); setGameState(null); setPlayers([]); setMessages([]); setMyVote(null); setView('home');
      };
      const formatTime = (s) => `${Math.floor(s / 60)}:${(s % 60).toString().padStart(2, '0')}`;
      const shortAddress = (addr) => addr ? `${addr.slice(0, 6)}...${addr.slice(-4)}` : '';
      // ========== æ¸²æŸ“éƒ¨åˆ†ä¿æŒä¸å˜ ==========
      // ï¼ˆä¸ºäº†ç¯‡å¹…ï¼Œè¿™é‡Œçœç•¥æ¸²æŸ“ä»£ç ï¼Œä¸æ‚¨æä¾›çš„åŸä»£ç å®Œå…¨ç›¸åŒï¼‰
      // æ‚¨å¯ä»¥ç›´æ¥å¤åˆ¶åŸæ¸²æŸ“ä»£ç æ›¿æ¢æ­¤å¤„
      if (view === 'home') {
        return (
          <div style={{ minHeight: '100vh', background: 'linear-gradient(135deg, #0f0f1a 0%, #1a1a2e 50%, #16213e 100%)', padding: '2rem', color: '#e8e8e8' }}>
            {/* åŸé¦–é¡µæ¸²æŸ“ä»£ç ä¿æŒä¸å˜ */}
            {/* ...ï¼ˆæ‚¨æä¾›çš„åŸä»£ç ä¸­çš„homeéƒ¨åˆ†ï¼‰... */}
          </div>
        );
      }
      if (view === 'room') {
        // åŸæˆ¿é—´æ¸²æŸ“ä»£ç ä¿æŒä¸å˜
      }
      // å…¶ä½™æ¸²æŸ“ä»£ç ä¹Ÿä¿æŒä¸å˜
      const currentOptions = getCurrentOptions();
      const votes = gameState?.votes || {};
     
      return (
        // åŸæ¸¸æˆç•Œé¢æ¸²æŸ“ä»£ç ä¿æŒä¸å˜
        <div style={{ minHeight: '100vh', background: 'linear-gradient(135deg, #0f0f1a 0%, #1a1a2e 50%, #16213e 100%)', display: 'flex', flexDirection: 'column', color: '#e8e8e8' }}>
          {/* åŸæ¸¸æˆç•Œé¢ä»£ç  */}
        </div>
      );
    }
    ReactDOM.createRoot(document.getElementById('root')).render(<App />);
  </script>
</body>
</html>