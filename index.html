<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>å…±è¯†ç¼–å¹´å² | Consensus Chronicle</title>
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-database-compat.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: system-ui, -apple-system, sans-serif; background: #0a0a0a; color: #e8e8e8; }
    ::-webkit-scrollbar { width: 6px; }
    ::-webkit-scrollbar-track { background: rgba(0,0,0,0.3); }
    ::-webkit-scrollbar-thumb { background: #d4a574; border-radius: 3px; }
  </style>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
    const { useState, useEffect, useRef } = React;

    const CONFIG = {
      ROOM_SIZE: { min: 2, max: 8 },
      DEBATE_DURATION: 90,
      VOTE_DURATION: 30,
      TOTAL_ROUNDS: 5,
      ROOM_TIMEOUT_AI: 60000,
      ROOM_TIMEOUT_CLOSE: 120000,
      GENLAYER_CONTRACT: '0x4F5F132ba540f1C685B0188D59990302903aE186',
      FIREBASE: {
        apiKey: "AIzaSyBX4tOb30jWKK6aBUsqERQaOAF4CxCfMmQ",
        authDomain: "consensus-chronicle.firebaseapp.com",
        databaseURL: "https://consensus-chronicle-default-rtdb.firebaseio.com",
        projectId: "consensus-chronicle"
      }
    };

    const C = { bg: '#0a0a0a', bgLight: '#111', bgCard: '#1a1a1a', gold: '#d4a574', goldLight: '#e8c9a0', goldDark: '#a67c52', accent: '#fbbf24', text: '#e8e8e8', muted: '#888', border: 'rgba(212,165,116,0.3)', success: '#4ade80', error: '#ef4444', optA: '#ef4444', optB: '#3b82f6' };

    const THEMES = {
      fantasy: { name: 'å¥‡å¹»å†’é™©', icon: 'ğŸ°', opening: 'å¤è€çš„é¢„è¨€ç»ˆäºåº”éªŒâ€”â€”æ²‰ç¡åƒå¹´çš„é»‘é¾™è‹é†’äº†ã€‚ç‹å›½å±åœ¨æ—¦å¤•ï¼Œå›½ç‹ç´§æ€¥å¬é›†äº†å„åœ°è‹±é›„å•†è®®å¯¹ç­–...', rounds: [{ context: 'é»‘é¾™çš„å¨èƒè¿«åœ¨çœ‰ç«ï¼Œç‹å›½å¿…é¡»åšå‡ºç¬¬ä¸€ä¸ªå…³é”®å†³å®šã€‚', a: { text: 'ç«‹å³é›†ç»“å†›é˜Ÿï¼Œä¸»åŠ¨å‡ºå‡»é¾™å·¢ã€‚', tag: 'æ¿€è¿›' }, b: { text: 'æ´¾é£ä½¿è€…å¯»æ±‚ç²¾çµæ—çš„å¸®åŠ©ã€‚', tag: 'ç¨³å¦¥' } }, { context: 'å±€åŠ¿è¿›ä¸€æ­¥å‘å±•ï¼Œæ–°çš„æŠ‰æ‹©æ‘†åœ¨é¢å‰ã€‚', a: { text: 'é‡‡å–æ›´æ¿€è¿›çš„ç­–ç•¥ï¼Œä¸æƒœä¸€åˆ‡ä»£ä»·ã€‚', tag: 'æœæ–­' }, b: { text: 'å¯»æ±‚æ›´å¤šç›Ÿå‹ï¼Œå»ºç«‹ç»Ÿä¸€æˆ˜çº¿ã€‚', tag: 'è°¨æ…' } }, { context: 'å…³é”®æ—¶åˆ»åˆ°æ¥ï¼Œæ¯ä¸ªå†³å®šéƒ½å°†å½±å“æœ€ç»ˆç»“å±€ã€‚', a: { text: 'ä½¿ç”¨ç¦å¿Œä¹‹åŠ›ï¼Œç‰ºç‰²å°æˆ‘å®Œæˆå¤§æˆ‘ã€‚', tag: 'ç‰ºç‰²' }, b: { text: 'ä¿å­˜å®åŠ›ï¼Œç­‰å¾…æ›´å¥½çš„æ—¶æœºã€‚', tag: 'å¿è€' } }, { context: 'æˆ˜å±€è¿›å…¥ç™½çƒ­åŒ–é˜¶æ®µã€‚', a: { text: 'å‘èµ·æ€»æ”»ï¼Œæ¯•å…¶åŠŸäºä¸€å½¹ã€‚', tag: 'å†³æˆ˜' }, b: { text: 'å°è¯•è°ˆåˆ¤ï¼Œå¯»æ‰¾å’Œå¹³è§£å†³æ–¹æ¡ˆã€‚', tag: 'å’Œå¹³' } }, { context: 'æœ€ç»ˆçš„æŠ‰æ‹©æ—¶åˆ»ã€‚', a: { text: 'ä¸æƒœä»£ä»·å–å¾—èƒœåˆ©ã€‚', tag: 'èƒœåˆ©' }, b: { text: 'ä¸æ•Œäººè¾¾æˆå…±è¯†ï¼Œå¼€åˆ›æ–°æ—¶ä»£ã€‚', tag: 'å…±å­˜' } }], endings: { default: 'ç»è¿‡è‰°éš¾æŠ‰æ‹©ï¼Œè‹±é›„ä»¬ä¹¦å†™äº†å±äºè‡ªå·±çš„ä¼ å¥‡ã€‚æ— è®ºç»“æœå¦‚ä½•ï¼Œè¿™æ®µæ•…äº‹éƒ½å°†æ°¸è¿œæµä¼ ã€‚' } },
      scifi: { name: 'ç§‘å¹»æœªæ¥', icon: 'ğŸš€', opening: '2157å¹´ï¼Œç«æ˜Ÿæ®–æ°‘åœ°æ”¶åˆ°äº†æ¥è‡ªæ·±ç©ºçš„ç¥ç§˜ä¿¡å·â€”â€”åœ°çƒå°†åœ¨100å¤©åè¢«å°è¡Œæ˜Ÿæ’å‡»...', rounds: [{ context: 'æ¶ˆæ¯å…¬å¸ƒåï¼Œæ®–æ°‘åœ°é™·å…¥ææ…Œã€‚', a: { text: 'å¯åŠ¨æ–¹èˆŸè®¡åˆ’ï¼ŒæŠ½ç­¾å†³å®šè°èƒ½é€ƒç”Ÿã€‚', tag: 'å…¬å¹³' }, b: { text: 'é›†ä¸­èµ„æºç ”ç©¶ä¿¡å·æ¥æºã€‚', tag: 'æ¢ç´¢' } }, { context: 'æ–°çš„æƒ…å†µå‡ºç°ï¼Œéœ€è¦è¿›ä¸€æ­¥å†³ç­–ã€‚', a: { text: 'ä¼˜å…ˆä¿æŠ¤æ ¸å¿ƒäººå‘˜å’ŒæŠ€æœ¯ã€‚', tag: 'ç²¾è‹±' }, b: { text: 'åšæŒäººäººå¹³ç­‰çš„åŸåˆ™ã€‚', tag: 'å¹³ç­‰' } }, { context: 'èµ„æºå˜å¾—æ›´åŠ ç´§å¼ ã€‚', a: { text: 'é‡‡å–é…ç»™åˆ¶åº¦ï¼Œä¸¥æ ¼ç®¡æ§ã€‚', tag: 'ç®¡æ§' }, b: { text: 'ä¿æŒè‡ªç”±åˆ†é…ã€‚', tag: 'è‡ªç”±' } }, { context: 'å¤–éƒ¨è”ç³»å‡ºç°è½¬æœºã€‚', a: { text: 'æ¥å—å¤–æ˜Ÿæ–‡æ˜çš„å¸®åŠ©æ¡ä»¶ã€‚', tag: 'åˆä½œ' }, b: { text: 'åšæŒäººç±»ç‹¬ç«‹è‡ªä¸»ã€‚', tag: 'ç‹¬ç«‹' } }, { context: 'æœ€åçš„å…³å¤´ã€‚', a: { text: 'æ”¾æ‰‹ä¸€æï¼Œå°è¯•æ”¹å˜å°è¡Œæ˜Ÿè½¨é“ã€‚', tag: 'å†’é™©' }, b: { text: 'æ¥å—å‘½è¿ï¼Œä¸“æ³¨äºæ–‡æ˜å»¶ç»­ã€‚', tag: 'æ¥å—' } }], endings: { default: 'åœ¨å‘½è¿çš„åå­—è·¯å£ï¼Œäººç±»åšå‡ºäº†è‡ªå·±çš„é€‰æ‹©ï¼Œæ— è®ºç»“æœå¦‚ä½•ï¼Œè¿™éƒ½æ˜¯å±äºäººç±»è‡ªå·±çš„å†³å®šã€‚' } },
      mystery: { name: 'æ‚¬ç–‘æ¨ç†', icon: 'ğŸ”', opening: 'æš´é£é›¨ä¹‹å¤œï¼Œå¯Œè±ªé™ˆè€çˆ·åœ¨ä¹¦æˆ¿è¢«æ¯’æ€ã€‚å¤§é—¨ä»å†…åé”ï¼Œäº”ä¸ªå«Œç–‘äººå„æ€€å¿ƒæ€...', rounds: [{ context: 'ä½œä¸ºä¾¦æ¢ï¼Œä½ å¿…é¡»å¼€å§‹è°ƒæŸ¥ã€‚', a: { text: 'æœæŸ¥æ­»è€…çš„ä¹¦æˆ¿ï¼Œå¯»æ‰¾ç‰©è¯ã€‚', tag: 'ç‰©è¯' }, b: { text: 'åˆ†åˆ«è¯¢é—®åœ¨åœºæ¯ä¸ªäººã€‚', tag: 'è¯¢é—®' } }, { context: 'è°ƒæŸ¥æœ‰äº†æ–°å‘ç°ã€‚', a: { text: 'æ·±å…¥è°ƒæŸ¥é—äº§é—®é¢˜ã€‚', tag: 'é‡‘é’±' }, b: { text: 'è°ƒæŸ¥ç¥ç§˜è®¿å®¢çš„èº«ä»½ã€‚', tag: 'èº«ä»½' } }, { context: 'æ¡ˆæƒ…å˜å¾—å¤æ‚ã€‚', a: { text: 'éªŒè¯å«Œç–‘äººçš„ä¸åœ¨åœºè¯æ˜ã€‚', tag: 'éªŒè¯' }, b: { text: 'è°ƒæŸ¥é™ˆå¹´æ—§æ¡ˆçš„å…³è”ã€‚', tag: 'æ—§æ¡ˆ' } }, { context: 'çœŸç›¸é€æ¸æµ®å‡ºæ°´é¢ã€‚', a: { text: 'ç›´æ¥å¯¹è´¨ä¸»è¦å«Œç–‘äººã€‚', tag: 'å¯¹è´¨' }, b: { text: 'é‡æ–°æ£€éªŒå…³é”®ç‰©è¯ã€‚', tag: 'ç‰©è¯' } }, { context: 'æœ€ç»ˆçš„å®¡åˆ¤æ—¶åˆ»ã€‚', a: { text: 'å…¬å¼€æ‰€æœ‰çœŸç›¸ï¼Œè®©æ³•å¾‹è£å†³ã€‚', tag: 'å…¬æ­£' }, b: { text: 'ç»™äºˆç›¸å…³äººé€‰æ‹©çš„æœºä¼šã€‚', tag: 'äººæƒ…' } }], endings: { default: 'è¿™èµ·æ¡ˆä»¶ä»¥å‡ºäººæ„æ–™çš„æ–¹å¼è½å¹•ï¼Œæˆä¸ºäº†äººä»¬èŒ¶ä½™é¥­åè°ˆè®ºçš„ä¼ å¥‡æ•…äº‹ã€‚' } },
      political: { name: 'å®«å»·æƒè°‹', icon: 'ğŸ‘‘', opening: 'å¤§é½ç‹æœï¼Œè€çš‡å¸é©¾å´©ã€‚é—è¯ç§°çš‡ä½ç”±"æœ€èƒ½ä»£è¡¨æ°‘å¿ƒè€…"ç»§æ‰¿ï¼Œä¸‰ä½çš‡å­å„æ€€å¿ƒæ€...', rounds: [{ context: 'ä½œä¸ºå†…é˜é¦–è¾…ï¼Œä½ å¿…é¡»ç»´æŒå±€é¢ã€‚', a: { text: 'æ”¯æŒå¤ªå­æŒ‰ä¼ ç»Ÿç»§ä½ã€‚', tag: 'ä¼ ç»Ÿ' }, b: { text: 'æè®®å…¬å¼€é€‰æ‹”ï¼Œè®©è´¤è€…å±…ä¹‹ã€‚', tag: 'é©æ–°' } }, { context: 'å„æ–¹åŠ¿åŠ›å¼€å§‹è§’åŠ›ã€‚', a: { text: 'è”åˆå†›æ–¹ç¨³å®šå±€åŠ¿ã€‚', tag: 'å†›æƒ' }, b: { text: 'äº‰å–æ–‡å®˜é›†å›¢æ”¯æŒã€‚', tag: 'æ–‡æ²»' } }, { context: 'å¤–éƒ¨åŠ¿åŠ›å¼€å§‹ä»‹å…¥ã€‚', a: { text: 'å¯¹å¤–å¼ºç¡¬ï¼Œæ˜¾ç¤ºå›½å¨ã€‚', tag: 'å¼ºç¡¬' }, b: { text: 'ä»¥å’Œä¸ºè´µï¼Œé¿å…å†²çªã€‚', tag: 'å’Œå¹³' } }, { context: 'å†…éƒ¨çŸ›ç›¾æ¿€åŒ–ã€‚', a: { text: 'æœæ–­æ¸…é™¤å¼‚å·±ã€‚', tag: 'æœæ–­' }, b: { text: 'å¯»æ±‚å¦¥åï¼Œå¹³è¡¡å„æ–¹ã€‚', tag: 'å¹³è¡¡' } }, { context: 'æœ€ç»ˆçš„æŠ‰æ‹©ã€‚', a: { text: 'å»ºç«‹æ–°çš„æƒåŠ›æ¶æ„ã€‚', tag: 'æ”¹é©' }, b: { text: 'ç»´æŠ¤ä¼ ç»Ÿç§©åºã€‚', tag: 'å®ˆæˆ' } }], endings: { default: 'åœ¨æƒåŠ›çš„æ¸¸æˆä¸­ï¼Œæ¯ä¸ªé€‰æ‹©éƒ½å½±å“ç€æ— æ•°äººçš„å‘½è¿ã€‚è¿™å°±æ˜¯å†å²çš„é‡é‡ã€‚' } }
    };

    const AI_PLAYERS = [
      { id: 'ai_1', name: 'æ™ºè€…Â·è‰¾ä¸', avatar: 'ğŸ§™â€â™€ï¸', exp: 1200, isAI: true, style: 'analytical' },
      { id: 'ai_2', name: 'å‹‡è€…Â·å‡¯æ©', avatar: 'âš”ï¸', exp: 1100, isAI: true, style: 'bold' },
      { id: 'ai_3', name: 'å­¦è€…Â·è¯ºäºš', avatar: 'ğŸ“š', exp: 1300, isAI: true, style: 'cautious' }
    ];

    const genAIDebate = (style) => {
      const d = { analytical: { A: ['é€»è¾‘ä¸ŠAæ›´ä¼˜'], B: ['åˆ†æåBæ›´å¥½'] }, bold: { A: ['æœæ–­é€‰Aï¼'], B: ['å‹‡æ•¢é€‰Bï¼'] }, cautious: { A: ['Aæˆ–è®¸å¯è¡Œ'], B: ['Bæ›´å®‰å…¨'] } };
      const c = Math.random() > 0.5 ? 'A' : 'B';
      return { text: (d[style]?.[c] || d.analytical[c])[0], choice: c };
    };

    function App() {
      const [db, setDb] = useState(null);
      const [wallet, setWallet] = useState(null);
      const [connecting, setConnecting] = useState(false);
      const [showConfirm, setShowConfirm] = useState(false);
      const [showRules, setShowRules] = useState(false);
      const [tab, setTab] = useState('game');
      const [view, setView] = useState('home');
      const [player, setPlayer] = useState({ id: '', name: '', avatar: 'ğŸ®', exp: 1000 });
      const [roomId, setRoomId] = useState(null);
      const [roomData, setRoomData] = useState(null);
      const [players, setPlayers] = useState([]);
      const [game, setGame] = useState(null);
      const [msgs, setMsgs] = useState([]);
      const [rooms, setRooms] = useState([]);
      const [input, setInput] = useState('');
      const [myVote, setMyVote] = useState(null);
      const [timer, setTimer] = useState(0);
      const [lb, setLb] = useState([]);
      const [hist, setHist] = useState([]);
      const [loading, setLoading] = useState(false);
      const timerRef = useRef(null);
      const msgsEndRef = useRef(null);
      const roomChkRef = useRef(null);

      useEffect(() => {
        try {
          if (!firebase.apps.length) firebase.initializeApp(CONFIG.FIREBASE);
          const database = firebase.database();
          setDb(database);
          database.ref('leaderboard').orderByChild('score').limitToLast(100).on('value', s => { if (s.val()) setLb(Object.values(s.val()).sort((a,b)=>b.score-a.score).slice(0,50)); });
          database.ref('gameHistory').orderByChild('timestamp').limitToLast(50).on('value', s => { if (s.val()) setHist(Object.values(s.val()).sort((a,b)=>b.timestamp-a.timestamp)); });
        } catch (e) { console.error(e); }
        const sw = localStorage.getItem('cc_wallet');
        const sp = localStorage.getItem('cc_player');
        if (sw && sp) { try { setWallet(sw); setPlayer(JSON.parse(sp)); } catch {} }
        if (window.ethereum && sw) { window.ethereum.request({ method: 'eth_accounts' }).then(a => { if (a[0]?.toLowerCase() === sw.toLowerCase()) setWallet(a[0]); }); }
        return () => { if (timerRef.current) clearInterval(timerRef.current); if (roomChkRef.current) clearInterval(roomChkRef.current); };
      }, []);

      useEffect(() => {
        if (!db) return;
        db.ref('rooms').on('value', s => {
          const d = s.val(); const now = Date.now();
          if (d) {
            const r = [];
            Object.entries(d).forEach(([id, rm]) => {
              if (rm.status === 'waiting' && (now - rm.createdAt) < CONFIG.ROOM_TIMEOUT_CLOSE) r.push({ id, ...rm });
              if (rm.status === 'waiting' && (now - rm.createdAt) > CONFIG.ROOM_TIMEOUT_CLOSE) db.ref(`rooms/${id}`).update({ status: 'closed' });
            });
            setRooms(r);
          } else setRooms([]);
        });
      }, [db]);

      useEffect(() => {
        if (!db || !roomId) return;
        const rRef = db.ref(`rooms/${roomId}`);
        const gRef = db.ref(`games/${roomId}`);
        rRef.on('value', s => {
          const d = s.val();
          if (d) {
            setRoomData(d);
            if (d.players) setPlayers(Object.values(d.players));
            if (d.status === 'closed') { alert('æˆ¿é—´å·²å…³é—­'); reset(); }
            if (d.status === 'playing' && view !== 'game') { setView('game'); setMyVote(null); }
          }
        });
        gRef.on('value', s => {
          const d = s.val();
          if (d) {
            setGame(d);
            if (d.messages) setMsgs(Object.values(d.messages).sort((a,b)=>a.timestamp-b.timestamp));
            if (d.phase === 'debate') setMyVote(null);
            if (d.timerEnd && d.phase !== 'ended') setTimer(Math.max(0, Math.floor((d.timerEnd - Date.now()) / 1000)));
          }
        });
        return () => { rRef.off(); gRef.off(); };
      }, [db, roomId, view]);

      useEffect(() => {
        if (!db || !roomId || !roomData || roomData.status !== 'waiting') return;
        if (roomChkRef.current) clearInterval(roomChkRef.current);
        roomChkRef.current = setInterval(() => {
          const age = Date.now() - roomData.createdAt;
          const realCnt = Object.values(roomData.players || {}).filter(p => !p.isAI).length;
          if (age > CONFIG.ROOM_TIMEOUT_AI && realCnt === 1 && player.id === roomData.host) {
            const curIds = Object.keys(roomData.players || {});
            AI_PLAYERS.filter(ai => !curIds.includes(ai.id)).slice(0, CONFIG.ROOM_SIZE.min - 1).forEach((ai, i) => {
              setTimeout(() => db.ref(`rooms/${roomId}/players/${ai.id}`).set(ai), i * 1000);
            });
          }
        }, 5000);
        return () => { if (roomChkRef.current) clearInterval(roomChkRef.current); };
      }, [db, roomId, roomData, player.id]);

      useEffect(() => {
        if (!game?.timerEnd || game?.phase === 'ended') return;
        if (timerRef.current) clearInterval(timerRef.current);
        timerRef.current = setInterval(() => {
          const rem = Math.max(0, Math.floor((game.timerEnd - Date.now()) / 1000));
          setTimer(rem);
          if (rem <= 0 && player.id === roomData?.host) phaseEnd();
        }, 1000);
        return () => { if (timerRef.current) clearInterval(timerRef.current); };
      }, [game?.timerEnd, game?.phase, player.id, roomData?.host]);

      useEffect(() => { msgsEndRef.current?.scrollIntoView({ behavior: 'smooth' }); }, [msgs]);

      const connectWallet = () => { if (!window.ethereum) { alert('è¯·å®‰è£…MetaMask'); return; } setShowConfirm(true); };
      const confirmConnect = async () => {
        setShowConfirm(false); setConnecting(true);
        try {
          const accs = await window.ethereum.request({ method: 'eth_requestAccounts' });
          const addr = accs[0]; setWallet(addr);
          if (db) {
            const snap = await db.ref(`players/${addr}`).once('value');
            const saved = snap.val();
            if (saved) { setPlayer({ id: addr, name: saved.name || '', avatar: saved.avatar || 'ğŸ®', exp: saved.exp || 1000 }); localStorage.setItem('cc_player', JSON.stringify({ id: addr, name: saved.name || '', avatar: saved.avatar || 'ğŸ®', exp: saved.exp || 1000 })); }
            else { setPlayer(p => ({ ...p, id: addr })); localStorage.setItem('cc_player', JSON.stringify({ ...player, id: addr })); }
          }
          localStorage.setItem('cc_wallet', addr);
          return addr;
        } catch (e) { alert('è¿æ¥å¤±è´¥'); return null; }
        finally { setConnecting(false); }
      };
      const disconnect = () => { setWallet(null); setPlayer({ id: '', name: '', avatar: 'ğŸ®', exp: 1000 }); localStorage.removeItem('cc_wallet'); localStorage.removeItem('cc_player'); };

      const payFee = async (addr) => {
        if (!window.ethereum) return false;
        setLoading(true);
        try { await window.ethereum.request({ method: 'eth_sendTransaction', params: [{ from: addr, to: CONFIG.GENLAYER_CONTRACT, value: '0x0', data: '0x' }] }); return true; }
        catch (e) { alert(e.code === 4001 ? 'ç”¨æˆ·å–æ¶ˆ' : 'äº¤æ˜“å¤±è´¥'); return false; }
        finally { setLoading(false); }
      };

      const recordToGL = async () => {
        if (!wallet || !window.ethereum) return;
        try { await window.ethereum.request({ method: 'eth_sendTransaction', params: [{ from: wallet, to: CONFIG.GENLAYER_CONTRACT, value: '0x0', data: '0x01' }] }); } catch {}
      };

      const createRoom = async (theme) => {
        if (!db || !player.name) { alert('è¯·å…ˆè¾“å…¥åå­—'); return; }
        let addr = wallet;
        if (!addr) { addr = await confirmConnect(); if (!addr) return; }
        if (!await payFee(addr)) return;
        const rid = `room_${Date.now()}`;
        await db.ref(`rooms/${rid}`).set({ theme, host: addr, status: 'waiting', createdAt: Date.now(), players: { [addr]: { id: addr, name: player.name, avatar: player.avatar, exp: player.exp, isAI: false } } });
        setRoomId(rid); setView('room');
      };

      const joinRoom = async (rid) => {
        if (!db || !player.name) { alert('è¯·å…ˆè¾“å…¥åå­—'); return; }
        let addr = wallet;
        if (!addr) { addr = await confirmConnect(); if (!addr) return; }
        if (!await payFee(addr)) return;
        await db.ref(`rooms/${rid}/players/${addr}`).set({ id: addr, name: player.name, avatar: player.avatar, exp: player.exp, isAI: false });
        setRoomId(rid); setView('room');
      };

      const addAI = async () => {
        if (!db || !roomId) return;
        const curIds = Object.keys(roomData?.players || {});
        AI_PLAYERS.filter(ai => !curIds.includes(ai.id)).slice(0, Math.min(3, CONFIG.ROOM_SIZE.max - curIds.length)).forEach(ai => db.ref(`rooms/${roomId}/players/${ai.id}`).set(ai));
      };

      const startGame = async () => {
        if (!db || !roomId || players.length < CONFIG.ROOM_SIZE.min) return;
        await db.ref(`rooms/${roomId}`).update({ status: 'playing' });
        const theme = roomData?.theme || 'fantasy';
        const arc = THEMES[theme];
        const scores = {}; players.forEach(p => { scores[p.id] = { influence: 0, debates: 0, wins: 0 }; });
        await db.ref(`games/${roomId}`).set({ round: 1, phase: 'debate', path: [], scores, votes: {}, story: [{ text: arc.opening, type: 'opening', round: 0 }], timerEnd: Date.now() + CONFIG.DEBATE_DURATION * 1000, messages: {} });
        addMsg('system', `ğŸ“– ${arc.name}å¼€å§‹ï¼ç¬¬1/${CONFIG.TOTAL_ROUNDS}è½® - è¾©è®º`);
        setTimeout(() => aiDebate(), 3000);
      };

      const aiDebate = () => {
        players.filter(p => p.isAI).forEach((ai, i) => {
          setTimeout(() => { const d = genAIDebate(ai.style); addMsg('chat', d.text, ai, d.choice); }, (i+1)*3000 + Math.random()*5000);
        });
      };

      const phaseEnd = async () => {
        if (!db || !roomId || !game) return;
        if (game.phase === 'debate') {
          await db.ref(`games/${roomId}`).update({ phase: 'vote', timerEnd: Date.now() + CONFIG.VOTE_DURATION * 1000, votes: {} });
          addMsg('system', 'ğŸ—³ï¸ æŠ•ç¥¨å¼€å§‹ï¼æ‰€æœ‰ç©å®¶è¯·æŠ•ç¥¨ï¼');
          players.filter(p => p.isAI).forEach((ai, i) => { setTimeout(() => db.ref(`games/${roomId}/votes/${ai.id}`).set(Math.random() > 0.5 ? 'A' : 'B'), (i+1)*2000); });
        } else if (game.phase === 'vote') { await calcResult(); }
      };

      const calcResult = async () => {
        if (!db || !roomId || !game) return;
        const votes = game.votes || {};
        const cnt = { A: 0, B: 0 }; Object.values(votes).forEach(v => { if (v) cnt[v]++; });
        const winner = cnt.A >= cnt.B ? 'A' : 'B';
        const round = game.round;
        const theme = roomData?.theme || 'fantasy';
        const arc = THEMES[theme];
        const rd = arc.rounds[round - 1];
        const winOpt = winner === 'A' ? rd?.a : rd?.b;
        const newScores = { ...game.scores };
        Object.entries(votes).forEach(([id, v]) => { if (v === winner && newScores[id]) { newScores[id].influence = (newScores[id].influence || 0) + 30; newScores[id].wins = (newScores[id].wins || 0) + 1; } });
        const newPath = [...(game.path || []), winner];
        const newStory = [...(game.story || []), { text: `ã€æŠ•ç¥¨ã€‘é€‰é¡¹${winner} (${cnt[winner]}ç¥¨)`, type: 'choice', round, winner }, { text: `é€‰æ‹©äº†ã€Œ${winOpt?.tag}ã€ï¼š${winOpt?.text}`, type: 'consequence', round }];
        addMsg('system', `ğŸ“œ é€‰é¡¹${winner}è·èƒœï¼(${cnt[winner]}ç¥¨)`);

        if (round >= CONFIG.TOTAL_ROUNDS) {
          const ending = arc.endings.default;
          await db.ref(`games/${roomId}`).update({ phase: 'ended', scores: newScores, path: newPath, story: [...newStory, { text: ending, type: 'ending', round }], timerEnd: null });
          addMsg('system', 'ğŸ† ç¼–å¹´å²å®Œæˆï¼');
          await recordToGL();
          db.ref('gameHistory').push().set({ id: Date.now(), timestamp: Date.now(), theme, path: newPath.join(''), ending: ending.slice(0, 80) + '...', date: new Date().toLocaleDateString(), playerCount: players.length, roomId });
          Object.entries(newScores).forEach(([pid, sc]) => {
            const p = players.find(x => x.id === pid);
            if (p && !p.isAI) {
              const total = (sc.influence || 0) + (sc.debates || 0);
              if (total > 0) {
                const newExp = (p.exp || 1000) + total;
                db.ref('leaderboard').push().set({ id: Date.now(), name: p.name, avatar: p.avatar, score: total, exp: newExp, theme, date: new Date().toLocaleDateString(), wallet: pid });
                db.ref(`players/${pid}`).update({ name: p.name, avatar: p.avatar, exp: newExp });
                if (pid === player.id) { setPlayer(prev => ({ ...prev, exp: newExp })); localStorage.setItem('cc_player', JSON.stringify({ ...player, exp: newExp })); }
              }
            }
          });
        } else {
          const nextRd = round + 1;
          const nextCtx = arc.rounds[nextRd - 1]?.context || 'æ•…äº‹ç»§ç»­...';
          await db.ref(`games/${roomId}`).update({ round: nextRd, phase: 'debate', scores: newScores, path: newPath, story: [...newStory, { text: nextCtx, type: 'context', round: nextRd }], timerEnd: Date.now() + CONFIG.DEBATE_DURATION * 1000, votes: {} });
          addMsg('system', `ğŸ“– ç¬¬${nextRd}/${CONFIG.TOTAL_ROUNDS}è½® - è¾©è®º`);
          setTimeout(() => aiDebate(), 3000);
        }
      };

      const addMsg = async (type, text, sender = null, choice = null) => { if (db && roomId) await db.ref(`games/${roomId}/messages`).push().set({ type, text, sender, choice, timestamp: Date.now() }); };
      const submitDebate = async () => {
        if (!input.trim() || game?.phase !== 'debate') return;
        const c = input.toUpperCase().includes('A') ? 'A' : input.toUpperCase().includes('B') ? 'B' : null;
        await addMsg('chat', input, { id: player.id, name: player.name, avatar: player.avatar }, c);
        setInput('');
        if (game?.scores?.[player.id] !== undefined) await db.ref(`games/${roomId}/scores/${player.id}/debates`).set((game.scores[player.id].debates || 0) + 10);
      };
      const vote = async (c) => { if (game?.phase !== 'vote' || myVote) return; setMyVote(c); await db.ref(`games/${roomId}/votes/${player.id}`).set(c); };
      const reset = () => { if (timerRef.current) clearInterval(timerRef.current); if (roomChkRef.current) clearInterval(roomChkRef.current); setRoomId(null); setRoomData(null); setGame(null); setPlayers([]); setMsgs([]); setMyVote(null); setView('home'); };
      const fmtTime = s => `${Math.floor(s/60)}:${(s%60).toString().padStart(2,'0')}`;
      const shortAddr = a => a ? `${a.slice(0,6)}...${a.slice(-4)}` : '';
      const getOpts = () => { if (!game || !roomData) return { a: null, b: null }; const rd = THEMES[roomData.theme]?.rounds[(game.round || 1) - 1]; return { a: rd?.a, b: rd?.b }; };
      const opts = getOpts();
      const votes = game?.votes || {};
      const theme = roomData?.theme ? THEMES[roomData.theme] : THEMES.fantasy;

      const Modal = ({ show, children }) => show ? <div style={{ position: 'fixed', inset: 0, background: 'rgba(0,0,0,0.9)', display: 'flex', alignItems: 'center', justifyContent: 'center', zIndex: 1000, padding: '1rem' }}>{children}</div> : null;

      if (view === 'home') return (
        <div style={{ minHeight: '100vh', background: C.bg, color: C.text }}>
          <Modal show={showConfirm}><div style={{ background: C.bgCard, borderRadius: '16px', padding: '2rem', maxWidth: '400px', border: `1px solid ${C.border}`, textAlign: 'center' }}><div style={{ fontSize: '3rem', marginBottom: '1rem' }}>ğŸ¦Š</div><h2 style={{ color: C.gold, marginBottom: '1rem' }}>è¿æ¥é’±åŒ…</h2><p style={{ color: C.muted, marginBottom: '1.5rem' }}>ç¡®è®¤è¿æ¥MetaMaskï¼Ÿ<br/>é’±åŒ…åœ°å€å°†ä½œä¸ºæ‚¨çš„ID</p><div style={{ display: 'flex', gap: '1rem' }}><button onClick={() => setShowConfirm(false)} style={{ flex: 1, padding: '0.8rem', background: 'transparent', border: `1px solid ${C.border}`, borderRadius: '8px', color: C.muted, cursor: 'pointer' }}>å–æ¶ˆ</button><button onClick={confirmConnect} style={{ flex: 1, padding: '0.8rem', background: `linear-gradient(135deg, ${C.gold}, ${C.goldDark})`, border: 'none', borderRadius: '8px', color: '#000', fontWeight: 600, cursor: 'pointer' }}>ç¡®è®¤</button></div></div></Modal>
          <Modal show={showRules}><div style={{ background: C.bgCard, borderRadius: '16px', padding: '2rem', maxWidth: '600px', maxHeight: '80vh', overflowY: 'auto', border: `1px solid ${C.border}` }}><h2 style={{ color: C.gold, marginBottom: '1rem', textAlign: 'center' }}>ğŸ“– æ¸¸æˆè§„åˆ™</h2><div style={{ color: C.text, lineHeight: 1.8, fontSize: '0.9rem' }}><p><b style={{ color: C.goldLight }}>ğŸ¯ ç›®æ ‡ï¼š</b>ä¸å…¶ä»–ç©å®¶å®Œæˆ5è½®æ•…äº‹å†³ç­–ï¼Œè·å¾—æœ€é«˜ç§¯åˆ†</p><p><b style={{ color: C.goldLight }}>ğŸ”— å…¥åœºï¼š</b>è¿æ¥MetaMask â†’ ç¡®è®¤GenLayeräº¤æ˜“(0 GEN)</p><p><b style={{ color: C.goldLight }}>â° æˆ¿é—´ï¼š</b>æœ€å°‘2äººï¼Œ1åˆ†é’Ÿæ— äººåŠ å…¥AIå¡«å……ï¼Œ2åˆ†é’Ÿæœªå¼€å§‹å…³é—­</p><p><b style={{ color: C.goldLight }}>ğŸ® æµç¨‹ï¼š</b>è¾©è®º(90ç§’) â†’ æŠ•ç¥¨(30ç§’) â†’ ç»“æœ â†’ ä¸‹ä¸€è½®</p><p><b style={{ color: C.goldLight }}>â­ ç§¯åˆ†ï¼š</b>è¾©è®º+10åˆ†ï¼ŒæŠ•ç¥¨è·èƒœ+30åˆ†ï¼Œç´¯è®¡åˆ°ç»éªŒå€¼</p></div><button onClick={() => setShowRules(false)} style={{ width: '100%', padding: '1rem', marginTop: '1rem', background: `linear-gradient(135deg, ${C.gold}, ${C.goldDark})`, border: 'none', borderRadius: '10px', color: '#000', fontWeight: 600, cursor: 'pointer' }}>æˆ‘çŸ¥é“äº†</button></div></Modal>
          <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', padding: '1rem 2rem', borderBottom: `1px solid ${C.border}`, background: C.bgLight }}><div style={{ display: 'flex', alignItems: 'center', gap: '0.8rem' }}><span style={{ fontSize: '1.3rem' }}>ğŸ“œ</span><span style={{ fontSize: '1.1rem', fontWeight: 700, color: C.gold }}>å…±è¯†ç¼–å¹´å²</span></div><div style={{ display: 'flex', alignItems: 'center', gap: '1rem' }}>{player.name && <span style={{ color: C.muted, fontSize: '0.9rem' }}>{player.avatar} {player.name} â€¢ â­{player.exp}</span>}{wallet ? <button onClick={disconnect} style={{ padding: '0.4rem 0.8rem', background: `${C.success}15`, border: `1px solid ${C.success}40`, borderRadius: '20px', fontSize: '0.8rem', color: C.success, cursor: 'pointer' }} title="ç‚¹å‡»æ–­å¼€">ğŸ”— {shortAddr(wallet)}</button> : <button onClick={connectWallet} disabled={connecting} style={{ padding: '0.5rem 1rem', background: `linear-gradient(135deg, ${C.gold}, ${C.goldDark})`, border: 'none', borderRadius: '20px', color: '#000', fontSize: '0.85rem', fontWeight: 600, cursor: 'pointer' }}>{connecting ? 'è¿æ¥ä¸­...' : 'ğŸ¦Š è¿æ¥é’±åŒ…'}</button>}</div></div>
          <div style={{ display: 'flex', justifyContent: 'center', gap: '0.8rem', padding: '1rem', borderBottom: `1px solid ${C.border}20`, background: C.bgLight }}>{[{ k: 'game', l: 'ğŸ® æ¸¸æˆ' }, { k: 'leaderboard', l: 'ğŸ† æ’è¡Œæ¦œ' }, { k: 'history', l: 'ğŸ“š å†å²' }].map(t => <button key={t.k} onClick={() => setTab(t.k)} style={{ padding: '0.5rem 1.2rem', background: tab === t.k ? `${C.gold}20` : 'transparent', border: tab === t.k ? `1px solid ${C.gold}50` : '1px solid transparent', borderRadius: '8px', color: tab === t.k ? C.gold : C.muted, fontSize: '0.9rem', cursor: 'pointer' }}>{t.l}</button>)}<button onClick={() => setShowRules(true)} style={{ padding: '0.5rem 1.2rem', background: `${C.accent}15`, border: `1px solid ${C.accent}30`, borderRadius: '8px', color: C.accent, fontSize: '0.9rem', cursor: 'pointer' }}>ğŸ“– è§„åˆ™</button></div>
          <div style={{ maxWidth: '1000px', margin: '0 auto', padding: '2rem' }}>
            {tab === 'game' && (<>{!player.name ? <div style={{ maxWidth: '400px', margin: '3rem auto', textAlign: 'center' }}><h2 style={{ marginBottom: '1rem', color: C.gold }}>è¾“å…¥ä½ çš„åå­—</h2><input type="text" placeholder="åå­—..." style={{ width: '100%', padding: '1rem', fontSize: '1rem', background: C.bgCard, border: `2px solid ${C.border}`, borderRadius: '12px', color: C.text, outline: 'none', textAlign: 'center' }} onKeyDown={e => { if (e.key === 'Enter' && e.target.value.trim()) { const n = e.target.value.trim(); setPlayer(p => ({ ...p, name: n })); if (wallet) { localStorage.setItem('cc_player', JSON.stringify({ ...player, name: n })); db?.ref(`players/${wallet}`).update({ name: n, avatar: player.avatar }); } } }} /><p style={{ marginTop: '0.5rem', color: C.muted, fontSize: '0.85rem' }}>æŒ‰Enterç¡®è®¤</p></div> : <><div style={{ textAlign: 'center', marginBottom: '1.5rem', padding: '0.8rem', background: `${C.gold}10`, borderRadius: '10px', border: `1px solid ${C.border}` }}><p style={{ color: C.gold }}>âš¡ åˆ›å»º/åŠ å…¥éœ€ç¡®è®¤GenLayeräº¤æ˜“(0 GEN)</p></div>{rooms.length > 0 && <div style={{ marginBottom: '2rem' }}><h3 style={{ color: C.gold, marginBottom: '1rem' }}>ğŸšª å¯åŠ å…¥çš„æˆ¿é—´</h3>{rooms.map(r => <div key={r.id} style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', padding: '1rem', marginBottom: '0.5rem', background: C.bgCard, borderRadius: '10px', border: `1px solid ${C.border}` }}><div style={{ display: 'flex', alignItems: 'center', gap: '0.8rem' }}><span style={{ fontSize: '1.5rem' }}>{THEMES[r.theme]?.icon}</span><div><div style={{ fontWeight: 600 }}>{THEMES[r.theme]?.name}</div><div style={{ fontSize: '0.8rem', color: C.muted }}>{Object.keys(r.players || {}).length}/{CONFIG.ROOM_SIZE.max}</div></div></div><button onClick={() => joinRoom(r.id)} disabled={loading} style={{ padding: '0.5rem 1.5rem', background: loading ? C.bgCard : `linear-gradient(135deg, ${C.gold}, ${C.goldDark})`, border: 'none', borderRadius: '8px', color: loading ? C.muted : '#000', fontWeight: 600, cursor: loading ? 'not-allowed' : 'pointer' }}>{loading ? 'å¤„ç†ä¸­...' : 'åŠ å…¥'}</button></div>)}</div>}<h3 style={{ color: C.gold, marginBottom: '1rem', textAlign: 'center' }}>é€‰æ‹©ä¸»é¢˜åˆ›å»ºæˆ¿é—´</h3><div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(180px, 1fr))', gap: '1rem' }}>{Object.entries(THEMES).map(([k, t]) => <button key={k} onClick={() => createRoom(k)} disabled={loading} style={{ display: 'flex', flexDirection: 'column', alignItems: 'center', padding: '1.5rem', background: C.bgCard, border: `1px solid ${C.border}`, borderRadius: '14px', cursor: loading ? 'not-allowed' : 'pointer', opacity: loading ? 0.5 : 1 }}><span style={{ fontSize: '2.5rem', marginBottom: '0.5rem' }}>{t.icon}</span><span style={{ fontSize: '1rem', fontWeight: 600, color: C.gold }}>{t.name}</span></button>)}</div>{loading && <div style={{ textAlign: 'center', padding: '1.5rem', color: C.accent }}>â³ ç­‰å¾…äº¤æ˜“ç¡®è®¤...</div>}</>}</>)}
            {tab === 'leaderboard' && <div style={{ maxWidth: '600px', margin: '0 auto' }}><h2 style={{ textAlign: 'center', marginBottom: '1.5rem', color: C.gold }}>ğŸ† æ’è¡Œæ¦œ</h2>{lb.length === 0 ? <p style={{ textAlign: 'center', color: C.muted, padding: '3rem' }}>æš‚æ— è®°å½•</p> : <div style={{ maxHeight: '500px', overflowY: 'auto' }}>{lb.map((e, i) => <div key={e.id || i} style={{ display: 'flex', alignItems: 'center', gap: '1rem', padding: '1rem', background: i === 0 ? `${C.gold}15` : C.bgCard, borderRadius: '10px', marginBottom: '0.5rem', border: i === 0 ? `1px solid ${C.gold}40` : `1px solid ${C.border}` }}><span style={{ fontWeight: 700, color: i < 3 ? C.gold : C.muted, width: '2rem' }}>#{i + 1}</span><span style={{ fontSize: '1.5rem' }}>{e.avatar}</span><div style={{ flex: 1 }}><div style={{ fontWeight: 600 }}>{e.name}</div><div style={{ fontSize: '0.75rem', color: C.muted }}>{THEMES[e.theme]?.name} â€¢ {e.date}</div></div><div style={{ textAlign: 'right' }}><div style={{ fontWeight: 700, color: C.gold }}>{e.score}åˆ†</div><div style={{ fontSize: '0.7rem', color: C.muted }}>ç´¯è®¡â­{e.exp || '-'}</div></div></div>)}</div>}</div>}
            {tab === 'history' && <div style={{ maxWidth: '700px', margin: '0 auto' }}><h2 style={{ textAlign: 'center', marginBottom: '1.5rem', color: C.gold }}>ğŸ“š æ¸¸æˆå†å²</h2>{hist.length === 0 ? <p style={{ textAlign: 'center', color: C.muted, padding: '3rem' }}>æš‚æ— è®°å½•</p> : <div style={{ maxHeight: '500px', overflowY: 'auto' }}>{hist.map((g, i) => <div key={g.id || i} style={{ padding: '1rem', background: C.bgCard, borderRadius: '10px', marginBottom: '0.8rem', border: `1px solid ${C.border}` }}><div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '0.5rem' }}><span style={{ fontWeight: 600 }}>{THEMES[g.theme]?.icon} {THEMES[g.theme]?.name}</span><span style={{ fontSize: '0.8rem', color: C.muted }}>{g.date} â€¢ {g.playerCount}äºº</span></div><div style={{ fontSize: '0.8rem', color: C.muted, marginBottom: '0.5rem' }}>è·¯å¾„: {g.path?.split('').map((c, j) => <span key={j} style={{ padding: '0.1rem 0.4rem', margin: '0 0.2rem', background: c === 'A' ? `${C.optA}30` : `${C.optB}30`, borderRadius: '4px', color: c === 'A' ? C.optA : C.optB }}>{c}</span>)}</div><div style={{ fontSize: '0.85rem', color: C.goldLight, fontStyle: 'italic' }}>{g.ending}</div></div>)}</div>}</div>}
          </div>
        </div>
      );

      if (view === 'room') {
        const age = roomData ? Math.floor((Date.now() - roomData.createdAt) / 1000) : 0;
        return (
          <div style={{ minHeight: '100vh', background: C.bg, color: C.text }}>
            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', padding: '1rem 2rem', borderBottom: `1px solid ${C.border}`, background: C.bgLight }}><button onClick={reset} style={{ padding: '0.5rem 1rem', background: 'transparent', border: `1px solid ${C.border}`, borderRadius: '8px', color: C.muted, cursor: 'pointer' }}>â† è¿”å›</button><div><span style={{ fontSize: '1.5rem', marginRight: '0.5rem' }}>{theme?.icon}</span><span style={{ fontWeight: 600, color: C.gold }}>{theme?.name}</span></div><span style={{ color: C.muted, fontSize: '0.9rem' }}>{player.avatar} {player.name} â€¢ â­{player.exp}</span></div>
            <div style={{ maxWidth: '600px', margin: '0 auto', padding: '2rem' }}>
              <div style={{ textAlign: 'center', marginBottom: '2rem' }}><span style={{ fontSize: '4rem' }}>{theme?.icon}</span><h2 style={{ color: C.gold, marginTop: '0.5rem' }}>{theme?.name}</h2><p style={{ color: C.muted }}>{age}ç§’</p></div>
              {age > 60 && <div style={{ textAlign: 'center', marginBottom: '1rem', padding: '0.8rem', background: `${C.accent}15`, borderRadius: '8px', color: C.accent }}>â° è¶…è¿‡1åˆ†é’Ÿï¼ŒAIå°†è‡ªåŠ¨åŠ å…¥</div>}
              <h3 style={{ color: C.muted, marginBottom: '1rem' }}>ç©å®¶ ({players.length}/{CONFIG.ROOM_SIZE.max})</h3>
              <div style={{ display: 'grid', gridTemplateColumns: 'repeat(4, 1fr)', gap: '1rem', marginBottom: '2rem' }}>{players.map(p => <div key={p.id} style={{ display: 'flex', flexDirection: 'column', alignItems: 'center', padding: '1rem', background: p.id === player.id ? `${C.gold}15` : C.bgCard, border: `1px solid ${p.id === player.id ? C.gold : C.border}`, borderRadius: '10px', position: 'relative' }}><span style={{ fontSize: '2rem', marginBottom: '0.3rem' }}>{p.avatar}</span><span style={{ fontSize: '0.85rem' }}>{p.name}</span>{p.isAI && <span style={{ position: 'absolute', top: '0.3rem', left: '0.3rem', fontSize: '0.5rem', padding: '0.1rem 0.3rem', background: C.optB, borderRadius: '3px' }}>AI</span>}{p.id === roomData?.host && <span style={{ position: 'absolute', top: '0.3rem', right: '0.3rem', fontSize: '0.5rem', padding: '0.1rem 0.3rem', background: C.gold, color: '#000', borderRadius: '3px' }}>æˆ¿ä¸»</span>}</div>)}</div>
              {player.id === roomData?.host && <><button onClick={startGame} disabled={players.length < CONFIG.ROOM_SIZE.min} style={{ width: '100%', padding: '1rem', fontSize: '1.1rem', fontWeight: 600, border: 'none', borderRadius: '10px', cursor: players.length >= CONFIG.ROOM_SIZE.min ? 'pointer' : 'not-allowed', background: players.length >= CONFIG.ROOM_SIZE.min ? `linear-gradient(135deg, ${C.gold}, ${C.goldDark})` : C.bgCard, color: players.length >= CONFIG.ROOM_SIZE.min ? '#000' : C.muted, marginBottom: '1rem' }}>{players.length >= CONFIG.ROOM_SIZE.min ? 'ğŸ® å¼€å§‹æ¸¸æˆ' : `ç­‰å¾…(${players.length}/${CONFIG.ROOM_SIZE.min})`}</button><button onClick={addAI} style={{ width: '100%', padding: '0.8rem', border: `1px solid ${C.optB}50`, borderRadius: '10px', background: 'transparent', color: C.optB, cursor: 'pointer' }}>ğŸ¤– æ·»åŠ AI</button></>}
            </div>
          </div>
        );
      }

      return (
        <div style={{ minHeight: '100vh', background: C.bg, display: 'flex', flexDirection: 'column', color: C.text }}>
          <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', padding: '0.8rem 2rem', background: C.bgLight, borderBottom: `1px solid ${C.border}` }}><div><div style={{ fontSize: '0.8rem', color: C.muted }}>ç¬¬{game?.round || 1}/{CONFIG.TOTAL_ROUNDS}è½®</div><div style={{ fontWeight: 600, color: C.gold }}>{game?.phase === 'debate' && 'ğŸ’¬ è¾©è®º'}{game?.phase === 'vote' && 'ğŸ—³ï¸ æŠ•ç¥¨'}{game?.phase === 'ended' && 'ğŸ† ç»“æŸ'}</div></div><div style={{ fontSize: '2.5rem', fontWeight: 700, fontFamily: 'monospace', color: timer <= 10 && game?.phase !== 'ended' ? C.error : C.gold }}>{game?.phase === 'ended' ? '--:--' : fmtTime(timer)}</div><div style={{ textAlign: 'right' }}><div style={{ fontSize: '0.8rem', color: C.muted }}>ç§¯åˆ†</div><div style={{ fontSize: '1.3rem', fontWeight: 700, color: C.accent }}>{(game?.scores?.[player.id]?.influence || 0) + (game?.scores?.[player.id]?.debates || 0)}</div></div></div>
          <div style={{ flex: 1, display: 'flex', gap: '1rem', padding: '1rem', overflow: 'hidden' }}>
            <div style={{ flex: 1, display: 'flex', flexDirection: 'column', gap: '1rem', minWidth: 0 }}>
              <div style={{ flex: 1, background: C.bgCard, borderRadius: '10px', padding: '1rem', overflowY: 'auto', border: `1px solid ${C.border}` }}><h3 style={{ color: C.gold, marginBottom: '1rem', fontSize: '0.95rem' }}>ğŸ“œ {theme?.name}</h3>{(game?.story || []).map((s, i) => <div key={i} style={{ padding: '0.5rem 0', borderBottom: i < (game?.story?.length || 0) - 1 ? `1px solid ${C.border}20` : 'none' }}>{s.type === 'opening' && <p style={{ color: C.goldLight, fontStyle: 'italic', lineHeight: 1.6 }}>{s.text}</p>}{s.type === 'context' && <p style={{ color: C.accent, lineHeight: 1.6 }}><span style={{ background: `${C.accent}20`, padding: '0.15rem 0.4rem', borderRadius: '4px', marginRight: '0.4rem', fontSize: '0.8rem' }}>ç¬¬{s.round}è½®</span>{s.text}</p>}{s.type === 'choice' && <p style={{ color: C.success, lineHeight: 1.6 }}>{s.winner === 'A' ? 'ğŸ…°ï¸' : 'ğŸ…±ï¸'} {s.text}</p>}{s.type === 'consequence' && <p style={{ color: C.muted, lineHeight: 1.6, paddingLeft: '1rem', borderLeft: `2px solid ${C.gold}30` }}>{s.text}</p>}{s.type === 'ending' && <p style={{ color: C.gold, lineHeight: 1.6, padding: '0.5rem', background: `${C.gold}10`, borderRadius: '8px' }}>ğŸ¬ {s.text}</p>}</div>)}</div>
              {(game?.phase === 'debate' || game?.phase === 'vote') && opts.a && <div style={{ background: C.bgCard, borderRadius: '10px', padding: '1rem', border: `1px solid ${C.border}` }}><h4 style={{ textAlign: 'center', marginBottom: '0.8rem', color: C.gold }}>âš”ï¸ æœ¬è½®æŠ‰æ‹©</h4><div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '1rem' }}>{[{ k: 'A', o: opts.a, c: C.optA }, { k: 'B', o: opts.b, c: C.optB }].map(({ k, o, c }) => <div key={k} onClick={() => game?.phase === 'vote' && vote(k)} style={{ padding: '1rem', borderRadius: '8px', border: `2px solid ${myVote === k ? c : `${c}40`}`, background: `${c}10`, cursor: game?.phase === 'vote' && !myVote ? 'pointer' : 'default', opacity: myVote && myVote !== k ? 0.5 : 1 }}><div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '0.5rem' }}><span style={{ fontWeight: 700, color: c }}>é€‰é¡¹{k}</span><span style={{ fontSize: '0.7rem', padding: '0.1rem 0.4rem', background: `${c}20`, borderRadius: '4px', color: c }}>{o?.tag}</span></div><p style={{ lineHeight: 1.4, fontSize: '0.85rem' }}>{o?.text}</p>{game?.phase === 'vote' && <div style={{ marginTop: '0.6rem', textAlign: 'center', fontSize: '1.1rem', fontWeight: 600, color: C.gold }}>{Object.values(votes).filter(v => v === k).length}ç¥¨</div>}{myVote === k && <div style={{ textAlign: 'center', marginTop: '0.3rem', color: c, fontSize: '0.8rem' }}>âœ“ å·²æŠ•ç¥¨</div>}</div>)}</div></div>}
              {game?.phase === 'ended' && <div style={{ background: `linear-gradient(145deg, ${C.gold}15, ${C.bgCard})`, borderRadius: '10px', padding: '1.5rem', textAlign: 'center', border: `1px solid ${C.gold}40` }}><h2 style={{ fontSize: '1.5rem', marginBottom: '1rem', color: C.gold }}>ğŸ† ç¼–å¹´å²å®Œæˆï¼</h2><div style={{ maxWidth: '350px', margin: '0 auto 1rem' }}>{Object.entries(game?.scores || {}).map(([id, sc]) => ({ p: players.find(x => x.id === id), t: (sc.influence || 0) + (sc.debates || 0) })).sort((a, b) => b.t - a.t).map((r, i) => <div key={r.p?.id || i} style={{ display: 'flex', alignItems: 'center', gap: '0.6rem', padding: '0.6rem', marginBottom: '0.3rem', background: i === 0 ? `${C.gold}20` : C.bgCard, borderRadius: '6px', border: i === 0 ? `1px solid ${C.gold}40` : 'none' }}><span style={{ fontWeight: 700, color: i < 3 ? C.gold : C.muted }}>#{i + 1}</span><span>{r.p?.avatar}</span><span style={{ flex: 1 }}>{r.p?.name}</span><span style={{ fontWeight: 600, color: C.gold }}>{r.t}åˆ†</span></div>)}</div><button onClick={reset} style={{ padding: '0.6rem 1.5rem', background: `linear-gradient(135deg, ${C.gold}, ${C.goldDark})`, border: 'none', borderRadius: '8px', color: '#000', fontWeight: 600, cursor: 'pointer' }}>è¿”å›å¤§å…</button></div>}
            </div>
            <div style={{ width: '280px', display: 'flex', flexDirection: 'column', background: C.bgCard, borderRadius: '10px', overflow: 'hidden', border: `1px solid ${C.border}` }}>
              <div style={{ display: 'flex', flexWrap: 'wrap', gap: '0.3rem', padding: '0.6rem', borderBottom: `1px solid ${C.border}` }}>{players.map(p => <div key={p.id} style={{ display: 'flex', alignItems: 'center', gap: '0.2rem', padding: '0.2rem 0.5rem', background: votes[p.id] ? `${C.success}20` : C.bgLight, borderRadius: '12px', fontSize: '0.75rem', border: votes[p.id] ? `1px solid ${C.success}40` : 'none' }}><span>{p.avatar}</span><span style={{ maxWidth: '50px', overflow: 'hidden', textOverflow: 'ellipsis', whiteSpace: 'nowrap' }}>{p.name}</span>{votes[p.id] && <span style={{ color: C.success, fontWeight: 700 }}>{votes[p.id]}</span>}</div>)}</div>
              <div style={{ flex: 1, overflowY: 'auto', padding: '0.6rem' }}>{msgs.map((m, i) => <div key={i} style={{ marginBottom: '0.5rem', fontSize: '0.8rem' }}>{m.type === 'system' ? <div style={{ color: C.gold, fontStyle: 'italic' }}>{m.text}</div> : <div style={{ background: C.bgLight, borderRadius: '6px', padding: '0.4rem 0.6rem' }}><div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '0.2rem' }}><span style={{ color: C.accent, fontWeight: 600 }}>{m.sender?.avatar} {m.sender?.name}</span>{m.choice && <span style={{ fontSize: '0.65rem', padding: '0.1rem 0.3rem', background: m.choice === 'A' ? `${C.optA}30` : `${C.optB}30`, borderRadius: '3px', color: m.choice === 'A' ? C.optA : C.optB }}>{m.choice}</span>}</div><div>{m.text}</div></div>}</div>)}<div ref={msgsEndRef} /></div>
              {game?.phase === 'debate' && <div style={{ padding: '0.6rem', borderTop: `1px solid ${C.border}` }}><div style={{ display: 'flex', gap: '0.4rem', marginBottom: '0.4rem' }}><input type="text" value={input} onChange={e => setInput(e.target.value)} onKeyDown={e => e.key === 'Enter' && submitDebate()} placeholder="è¾“å…¥è§‚ç‚¹..." style={{ flex: 1, padding: '0.5rem', background: C.bgLight, border: `1px solid ${C.border}`, borderRadius: '6px', color: C.text, fontSize: '0.8rem', outline: 'none' }} /><button onClick={submitDebate} style={{ padding: '0.5rem 0.8rem', background: `linear-gradient(135deg, ${C.gold}, ${C.goldDark})`, border: 'none', borderRadius: '6px', color: '#000', fontWeight: 600, cursor: 'pointer' }}>å‘é€</button></div><div style={{ display: 'flex', gap: '0.3rem' }}><button onClick={() => setInput('æˆ‘æ”¯æŒAï¼Œå› ä¸º')} style={{ padding: '0.2rem 0.5rem', background: `${C.optA}20`, border: `1px solid ${C.optA}30`, borderRadius: '10px', color: C.optA, fontSize: '0.7rem', cursor: 'pointer' }}>ğŸ…°ï¸</button><button onClick={() => setInput('æˆ‘æ”¯æŒBï¼Œå› ä¸º')} style={{ padding: '0.2rem 0.5rem', background: `${C.optB}20`, border: `1px solid ${C.optB}30`, borderRadius: '10px', color: C.optB, fontSize: '0.7rem', cursor: 'pointer' }}>ğŸ…±ï¸</button></div></div>}
              {game?.phase === 'vote' && !myVote && <div style={{ padding: '0.8rem', textAlign: 'center', background: `${C.gold}15` }}><p style={{ color: C.accent, fontWeight: 600, fontSize: '0.9rem' }}>â° è¯·åœ¨å·¦ä¾§æŠ•ç¥¨ï¼</p></div>}
            </div>
          </div>
        </div>
      );
    }

    ReactDOM.createRoot(document.getElementById('root')).render(<App />);
  </script>
</body>
</html>
